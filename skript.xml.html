<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>
<body>JavaDie Titelseite
 <h1>1. Einf&uuml;hrung</h1>
<h2>1.1. Ziel der Vorlesung</h2>Java<h2>1.2. Programmieren</h2>
<h3>1.2.1. Disziplinen der Programmierung</h3>
          Spezifikation: Bevor eine Programmieraufgabe
bewerkstelligt werden kann, mu&szlig;  das zu l&ouml;sende
Problem spezifiziert werden. Dieses kann informell durch eine
nat&uuml;rlichsprachliche Beschreibung bis hin zu mathematisch
beschriebenen Funktionen geschehen. Gegen die Spezifikation 
wird programmiert. Sie beschreibt das gew&uuml;nschte Verhalten
des zu erstellenden Programms. 
          Modellieren: Bevor es an die eigentliche Codierung
geht, wird in der Regel die Struktur des Programms modelliert.
Auch dieses kann in unterschiedlichen Detaillierungsgraden geschehen.
Manchmal reichen Karteikarten als hilfreiches Mittel aus,
andernfalls empfiehlt sich eine umfangreiche Modellierung 
mit Hilfe rechnergest&uuml;tzter Werkzeuge. F&uuml;r die objektorientierte
Programmierung hat sich  UML als eine geeignete Modellierungssprache
durchgesetzt. In ihr lassen sich Klassendiagramme, Klassenhierarchien
und Abh&auml;ngigkeiten graphisch darstellen. Mit bestimmten Werkzeugen
wie Together oder Rational Rose l&auml;&szlig;t sich direkt 
f&uuml;r eine UML-Modellierung Programmtext generieren.
          Codieren: Die eigentliche Codierung ist in der
Regel der einzige Schritt, der direkt Code in der gew&uuml;nschten
Programmiersprache von Hand erzeugt. Alle anderen Schritte 
der Programmierung
sind mehr oder weniger unabh&auml;ngig von der zugrundeliegenden
Programmiersprache.
F&uuml;r die Codierung empfiehlt es sich, Konventionen zu verabreden, wie 
der Code geschrieben wird, was f&uuml;r Bezeichner benutzt werden, in
welcher Weise der Programmtext einger&uuml;ckt wird. Entwicklungsabteilungen
haben zumeist schriftlich verbindlich festgeschriebene Richtlinien
f&uuml;r den Programmierstil. Dieses erleichtert, den Code der Kollegen im
Projekt schnell zu verstehen.
          Testen: Beim Testen sind generell zu unterscheiden:
              Entwicklertests: Diese werden von den Entwicklern
w&auml;hrend der Programmierung selbst geschrieben, um einzelne Programmteile
(Methoden, 
Funktionen) separat zu testen. Es gibt eine Schule, die
propagiert, Entwicklertests vor dem Code zu 
schreiben (test first). Die Tests dienen in diesem Fall als
kleine Spezifikationen.
              Qualit&auml;tssicherung: In der Qualit&auml;tssicherung werden
die fertigen Programme gegen ihre Spezifikation getestet (black
box tests). Hierzu
werden in der Regel automatisierte Testl&auml;ufe geschrieben. 
Die Qualit&auml;tssicherung ist  personell von der Entwicklung
getrennt. Es kann
in der Praxis durchaus vorkommen, da&szlig; die Qualit&auml;tsabteilung 
mehr Mitarbeiter hat als die Entwicklungsabteilung.
            
          Optimieren: Sollten sich bei Tests oder in der 
Praxis Performanzprobleme zeigen, sei es durch zu hohen 
Speicherverbrauch als auch durch zu lange Ausf&uuml;hrungszeiten, so wird
versucht, ein Programm zu optimieren. Hierzu bedient man sich
spezieller Werkzeuge (profiler), die f&uuml;r einen Programmdurchlauf
ein Raum- und Zeitprofil erstellen. In diesem Profil k&ouml;nnen 
Programmteile, die besonders h&auml;ufig durchlaufen werden, oder Objekte,
die im gro&szlig;en Ma&szlig;e Speicher belegen, identifiziert werden. Mit diesen 
Informationen lassen sich gezielt inperformante Programmteile 
optimieren.
          Verifizieren: Eine formale Verifikation eines Programms
ist ein mathematischer Beweis der Korrektheit bez&uuml;glich der
Spezifikation. Das setzt nat&uuml;rlich voraus, da&szlig; die Spezifikation
auch formal vorliegt. Man unterscheidet:
              partielle Korrektheit: wenn das Programm f&uuml;r
eine bestimte Eingabe ein Ergebnis liefert, dann ist dieses bez&uuml;glich
der Spezifikation korrekt.
              totale Korrektheit: Das Programm ist partiell korrekt
und terminiert f&uuml;r jede Eingabe, d.h.liefert immer nach endlich
langer Zeit ein Ergebnis.
            
Eine formale Verifikation ist notorisch schwierig und allgemein nicht
automatisch durchf&uuml;hrbar. In der Praxis werden nur in ganz speziellen
kritischen Anwendungen formale Verifikationen durchgef&uuml;hrt, z.B.bei
Steu\-er\-un\-gen gefahrentr&auml;chtiger Maschinen, so da&szlig; Menschenleben von
der Korrektheit eines Programms abh&auml;ngen k&ouml;nnen. 
          Wartung/Pflege: den gr&ouml;&szlig;ten Teil seiner Zeit verbringt
ein Programmierer nicht mit der Entwicklung neuer Software, sondern mit der Wartung bestehender Software. Hierzu geh&ouml;ren
die Anpassung des Programms an neue Versionen benutzter Bibliotheken oder  des Betriebssystems, auf dem das Programm l&auml;uft, 
sowie die Korrektur von Fehlern.
          Debuggen: Bei einem  Programm ist immer damit
zu rechnen, da&szlig; es Fehler enth&auml;lt. Diese Fehler werden im besten
Fall von der Qualit&auml;tssicherung entdeckt, im schlechteren Fall treten 
sie beim Kunden auf. Um  Fehler im Programmtext zu finden,
gibt es Werkzeuge, die ein schrittweises Ausf&uuml;hren des Programms
erm&ouml;glichen (debugger). Dabei lassen sich die Werte, die in
bestimmten Speicherzellen stehen, auslesen und auf diese Weise der Fehler
finden. 
 
          Internationalisieren (I18N)I18N ist eine Abk&uuml;rzung
f&uuml;r das Wort internationalization, das mit einem i beginnt, mit
einem n endet und dazwischen 18 Buchstaben hat.: Softwarefirmen
wollen m&ouml;glichst
viel Geld mit ihrer Software verdienen und streben deshalb an, ihre
Programme m&ouml;glichst weltweit zu vertreiben. Hierzu mu&szlig; gew&auml;hrleistet
sein, da&szlig; das Programm auf weltweit allen Plattformen l&auml;uft und
mit verschiedenen Schriften und Textcodierungen umgehen kann. Das
Programm sollte ebenso wie mit lateinischer Schrift auch mit Dokumenten
in anderen Schriften umgehen k&ouml;nnen. Fremdl&auml;ndische Akzente und  
deutsche Umlaute sollten bearbeitbar sein. Aber auch unterschiedliche
Tastaturbelegungen bis hin zu unterschiedlichen Schreibrichtungen sollten
unterst&uuml;tzt werden. 
Die Internationalisierung ist ein weites Feld, und wenn nicht am Anfang
der Programmerstellung hierauf R&uuml;cksicht genommen wird, so ist es schwer,
nachtr&auml;glich das Programm zu internationalisieren.
          Lokalisieren (L12N): Ebenso wie die 
Internationalisierung besch&auml;ftigt
sich die Lokalisierung damit, da&szlig; ein Programm in anderen L&auml;ndern
eingesetzt werden kann. Besch&auml;ftigt sich die Internationalisierung damit,
da&szlig; fremde Dokumente bearbeitet werden k&ouml;nnen, versucht die Lokalisierung,
das Programm komplett f&uuml;r die fremde Sprache zu &uuml;bersetzen. Hierzu 
geh&ouml;ren Menueintr&auml;ge in der fremden Sprache, Beschriftungen der
Schaltfl&auml;chen oder auch Fehlermeldungen in fremder Sprache und Schrift.
Insbesondere haben verschiedene Schriften unterschiedlichen
Platzbedarf; auch das ist beim Erstellen der Programmoberfl&auml;che
zu ber&uuml;cksichtigen.
          Portieren: Oft wird es n&ouml;tig, ein Programm auf eine andere
Plattform zu portieren. Ein unter Windows erstelltes Programm soll
z.B.auch auf Unix-Systemen zur Verf&uuml;gung stehen. 
          Dokumentieren: Der Programmtext allein reicht in der Regel nicht aus, damit das Programm von Fremden oder 
dem Programmierer selbst nach
geraumer Zeit gut verstanden werden kann. Um ein Programm n&auml;her
zu erkl&auml;ren, wird im Programmtext Kommentar eingef&uuml;gt. Kommentare
erkl&auml;ren die benutzten Algorithmen, die Bedeutung bestimmter Datenfelder
oder die Schnittstellen und Benutzung bestimmter Methoden.
Es ist zu empfehlen, sich anzugew&ouml;hnen, Quelltextdokumentation immer auf
Englisch zu schreiben. Es ist oft nicht abzusehen, wer einmal einen
Programmtext zu sehen bekommt. Vielleicht ein japanischer Kollege,
der das Programm f&uuml;r Japan lokalisiert, oder der irische Kollege, der,
nachdem die Firma mit einer anderen Firma fusionierte, das 
Programm auf ein anderes Betriebssystem portiert, oder vielleicht
die englische Werksstudentin, die f&uuml;r ein Jahr in der Firma arbeitet.
        <h3>1.2.2. Was ist ein Programm</h3>
<h4>1.2.2.1. pragmatische Antwort</h4>compiler<h4>1.2.2.2. mathematische Antwort</h4>
<h4>1.2.2.3. sprachwissenschaftliche Antwort</h4>
<h4>1.2.2.4. operationale Antwort</h4>
<h3>1.2.3. Klassifizierung von Programmiersprachen</h3>Wer Interesse hat, kann 
im Netz einmal suchen, ob er eine Liste
von Programmiersprachen findet.<h4>1.2.3.1. Hauptklassen</h4>imperativ (C, Pascal, Fortran, Cobol): das
Hauptkonstrukt dieser Sprachen sind Befehle, die den Speicher
manipulieren. objektorientiert (Java, C++, C\#, Eiffel, Smalltalk):
Daten werden in Form von Objekten organisiert. Diese Objekte
b&uuml;ndeln mit den Daten auch die auf diesen Daten anwendbaren
Methoden.funktional (Lisp, ML, Haskell, Scheme, Erlang, Clean):
Programme werden als mathematische Funktionen verstanden und auch
Funktionen  k&ouml;nnen Daten sein. Dieses Programmierparadigma versucht,
sich m&ouml;glichst weit von der Architektur des Computers zu l&ouml;sen.
Ver&auml;nderbare Speicherzellen gibt es in rein funktionalen Sprachen
nicht und erst recht keine Zuweisungsbefehle.Skriptsprachen (Perl, AWK): solche Sprachen sind dazu
entworfen, einfache kleine Programme schnell zu erzeugen. Sie haben
meist kein Typsystem und nur eine begrenzte Zahl an 
Strukturierungsm&ouml;glichkeiten, oft aber eine m&auml;chtige Bibliothek, um
Zeichenketten zu manipulieren. logisch (Prolog): aus der KI (k&uuml;nstlichen Intelligenz)
stammen logische Programmiersprachen. Hier wird ein Programm als
logische Formel, f&uuml;r die ein Beweis gesucht wird, verstanden.<h4>1.2.3.2. Ausf&uuml;hrungsmodelle</h4>
            kompiliert (C, Cobol, Fortran): in einem &Uuml;bersetzungsschritt
wird aus dem Quelltext direkt das ausf&uuml;hrbare Programm erzeugt, das dann
unabh&auml;ngig von irgendwelchen Hilfen der Programmiersprache ausgef&uuml;hrt werden
kann.
            interpretiert (Lisp, Scheme): der Programmtext wird nicht
in eine ausf&uuml;hrbare Datei &uuml;bersetzt, sondern durch einen Interpreter
St&uuml;ck f&uuml;r St&uuml;ck anhand des Quelltextes ausgef&uuml;hrt. Hierzu mu&szlig; stets der
Interpreter zur Verf&uuml;gung stehen, um das Programmm auszuf&uuml;hren. 
Interpretierte Programme sind langsamer in der Ausf&uuml;hrung als
&uuml;bersetzte Programme.
            abstrakte Maschine &uuml;ber byte code (Java, ML): dieses ist quasi eine Mischform aus den obigen zwei Ausf&uuml;hrungsmodellen.
Der Quelltext wird &uuml;bersetzt in Befehle nicht f&uuml;r einen konkreten
Computer, sondern f&uuml;r eine abstrakte Maschine. F&uuml;r diese abstrakte Maschine
steht dann ein Interpreter zur Verf&uuml;gung. Der Vorteil ist, da&szlig; durch
die zus&auml;tzliche Abstraktionsebene der &Uuml;bersetzer unabh&auml;ngig von einer konkreten
Maschine Code erzeugen kann und das Programm auf auf allen Systemen laufen
kann, f&uuml;r die es einen Interpreter der abstrakten Maschine gibt.
          
Da Java sich einer abstrakten Maschine bedient, sind, um zur Ausf&uuml;hrung 
zu gelangen, sowohl 
ein &Uuml;bersetzer als auch ein Interpreter notwendig.
Der zu &uuml;bersetzende Quelltext steht in Dateien mit der Endung .java,
der erzeugte byte code in Dateien mit der Endung .class 
Der Java&uuml;bersetzer kann von der Kommandozeile mit dem Befehl javac
aufgerufen werden. Um eine Programmdatei Test.java zu &uuml;bersetzen,
kann folgendes Kommando eingegeben werden:<pre>javac Test.java </pre>
Im  Falle einer fehlerfreien &Uuml;bersetzung wird eine Datei Test.class
im Dateisystem erzeugt. Dieses erzeugte Programm wird allgemein 
durch folgendes Kommando im Javainterpreter ausgef&uuml;hrt:<pre>java Test</pre>
<h4>1.2.3.3. &Uuml;bersetzen eines erste Javaprogramms</h4>
<pre>class FirstProgram{
  public static void main(String [] args){
    System.out.println("hello world");
  }
}</pre>Schreiben Sie das obige Programm mit einen Texteditor ihrer
Wahl. Speichern Sie es als FirstProgram.java ab.
&Uuml;bersetzen Sie es mit dem Java-&Uuml;bersetzer javac.
 Es entsteht eine Datei FirstProgram.class. F&uuml;hren 
Sie das Programm mit
dem Javainterpreter java aus. F&uuml;hren Sie dieses sowohl einmal auf
Linux als auch einmal unter Windows durch."hello world"<pre>class Answer {
  public static void main(String [] args){
    System.out.println(42);
  }
}</pre>
<h3>1.2.4. Arbeitshypothese</h3>Beim Programmieren versuchen wir, zwischen Daten und Programmen 
zu unterscheiden. Programme manipulieren Daten, indem sie sie 
l&ouml;schen, anlegen oder &uuml;berschreiben.
Daten k&ouml;nnen dabei einfache Datentypen sein, die Zahlen, Buchstaben oder
Buchstabenketten (Strings) repr&auml;sentieren, oder aber beliebig strukturierte
Sammlungen von Daten wie z.B.Listen, Tabellen, Baum- oder
Graphstrukturen. <h1>2. Objektorientierte Programmierung</h1>
<h2>2.1. Grundkonzepte der Objektorientierung</h2>
<h3>2.1.1. Objekte und Klassen</h3>subjektorientierte 
Programmierung<h4>2.1.1.1. Objektorientierte Modellierung</h4>
            Personen, die B&uuml;cher ausleihen wollen.
            B&uuml;cher, die ausgeliehen werden k&ouml;nnen.
            Tats&auml;chliche Ausleihvorg&auml;nge, die ausdr&uuml;cken, da&szlig; ein Buch bis zu einem
bestimmten Zeitraum von jemanden ausgeliehen wurde.
            Termine, also Objekte, die ein bestimmtes Datum kennzeichnen.
          PersonPersonEs mag vielleicht verwundern, warum wir den Typ vor
die Eigenschaft und nicht etwa hinter sie schreiben. Dieses ist eine sehr alte
Tradition in der Informatik.PersonBuchDatumAusleihe<h4>2.1.1.2. Klassen in Java</h4>
In Java steht
genau eine KlassendefinitionAuch hier werden wir Ausnahmen
kennenlernen. in genau einer Datei. 
Die Datei hat dabei den Namen der Klasse mit der Endung .java.class<pre>class Minimal {
}</pre>
Beachten Sie, da&szlig; Gro&szlig;- und Kleinschreibung in Java relevant ist.
Alle Schl&uuml;sselw&ouml;rter wie class werden stets klein geschrieben.
Klassennamen starten per Konvention immer mit einem Gro&szlig;buchstaben.
Java kommt bereits mit einer gro&szlig;en Anzahl zur Verf&uuml;gung stehender
Standardklassen. Es m&uuml;ssen also nicht alle Klassen neu vom Programmierer
definiert werden. Eine sehr h&auml;ufig benutzte Klasse ist die 
Klasse String. Sie repr&auml;sentiert Objekte, die eine Zeichenkette
darstellen, also einen Text, wie wir ihn in unserer ersten Modellierung
bereits vorausgesetzt haben.<h4>2.1.1.3. Objekte</h4>new<pre>new Minimal();</pre>Schreiben sie ein Programm, das ein Objekt der Klasse Minimal erzeugt und auf dem Bildschirm ausgibt. Hierzu ersetzen sie
einfach im Programm Answer die 42 durch den 
Ausdruck new Minimal()
F&uuml;r die Klasse String gibt es eine besondere Art, Objekte zu
erzeugen. Ein in Anf&uuml;hrungsstrichen eingeschlossener Text erzeugt ein
Objekt der Klasse String. 
Aus zwei Objekten der Stringklasse
l&auml;&szlig;t sich ein neues Objekt erzeugen, indem diese beiden Objekte mit
einem Pluszeichen verbunden werden:<pre>"hallo "+"welt"</pre>
Hier werden die zwei Stringobjekte "hallo " und "welt"
zum neuen Objekt "hallo welt" verkn&uuml;pft.<h3>2.1.2. Felder und Methoden</h3>FeaturesEigenschaften<h4>2.1.2.1. Felder</h4>
Im Folgenden schreiben wir eine Klasse mit zwei Feldern:<pre>class ErsteFelder {
  Minimal meinFeld;
  String  meinTextFeld;
}</pre>

Das erste 
Feld soll dabei einmal ein Objekt unserer minimalen Klasse sein und
das andere Mal eine Zeichenkette.
Feldnamen werden per Konvention immer klein geschrieben.Schreiben Sie f&uuml;r die vier Karteikarten in der Modellierung eines
Bibliotheksystems entsprechende Klassen mit den entsprechenden Feldern.
In Feldern k&ouml;nnen Objekte gespeichert werden. Hierzu mu&szlig; dem Feld ein
Objekt zugewiesen werden. Syntaktisch geschieht dieses durch ein 
Gleichheitszeichen, auf dessen linker Seite das Feld steht und auf dessen 
rechter Seite das Objekt, das in diesem Feld gespeichert werden soll.
Auch Zuweisungen enden mit einem Semikolon.
In der folgenden Klasse definieren wir nicht nur, da&szlig; die Objekte der Klasse
zwei Felder eines bestimmten Typs haben, sondern weisen auch gleich schon
Werte, d.h. konkrete Daten diesen Feldern zu.<pre>class ErsteFelder2 {
  Minimal meinFeld = new Minimal();
  String  meinTextFeld = "hallo";
}</pre>
Nach einer Zuweisung repr&auml;sentiert das Feld das ihm zugewiesene Objekt.<h4>2.1.2.2. Methoden</h4>Der 
Ausdruck f&uuml;r Methoden kommt speziell aus der
objektorientierten Prorammierung. In der imperativen Programmierung
spricht man von Prozeduren, die funktionale Programmierung 
von Funktionen. Weitere Begriffe, die &Auml;hnliches beschreiben,
sind Unterprogramme und Subroutinen.
In Java wird eine Methode deklariert durch:
den R&uuml;ckgabetyp, den Namen der Methode, der in Klammern eingeschlossenen
durch Kommas getrennten Parameterliste und den in geschweiften Klammern
eingeschlossenen Programmrumpf. Im Programmrumpf wird mit dem 
Schl&uuml;sselwort return angegeben, welches Ergebnisobjekt die
Methode liefert.
Als Beispiel definieren wir eine Klasse, in der es eine 
Methode addString gibt, 
die den Ergebnistyp String und zwei Parameter vom Typ String hat:<pre>class StringUtilMethod {
  String addStrings(String leftText, String rightText){
    return leftText+rightText;
  }
}</pre>
Methoden und Parameternamen werden per Konvention immer klein geschrieben.
In einer Methode stehen die Felder der Klasse zur Verf&uuml;gungDas ist 
wiederum nicht die volle Wahrheit, wie in K&uuml;rze zu sehen sein wird..
Wir k&ouml;nnen mit den bisherigen Mitteln eine kleine Klasse definieren, die
es erlaubt, Personen zu repr&auml;sentieren, so da&szlig; die Objekte dieser Klasse
eine Methode haben, um den vollen Namen der Person anzugeben:<pre>class PersonExample1 {
  String vorname;
  String nachname;

  String getFullName(){
    return (vorname+" "+nachname);
  }
}</pre>
Es lassen sich auch Methoden schreiben, die keinen eigentlichen Wert
berechnen, den sie als Ergebnis zur&uuml;ckgeben. Solche Methoden haben keinen
R&uuml;ckgabetyp. In Java wird dieses gekennzeichnet, indem das
Schl&uuml;sselwort void statt eines Typnamens in der Deklaration
steht. Solche Methoden haben keine return-Anweisung. 
Folgende kleine Beispielklasse enth&auml;lt zwei Methoden zum Setzen neuer Werte f&uuml;r ihre Felder:<pre>class PersonExample2 {
  String vorname;
  String nachname;

  void setVorname(String newName){
    vorname = newName;
  }
  void setNachname(String newName){
    nachname = newName;
  }
}</pre>
Obige Methoden weisen konkrete Objekte den Feldern des Objektes zu.<h4>2.1.2.3. Konstruktoren</h4>new<pre>class Person1 {
  String vorname;
  String nachname;

  Person1(String derVorname, String derNachname){
    vorname  = derVorname;
    nachname = derNachname;
  }  

  String getFullName(){
    return (vorname+" "+nachname);
  }
}</pre>Person
Wir erzeugen ein Personenobjekt mit dem f&uuml;r die entsprechende Klasse geschriebenen Konstruktor:<pre>class TestePerson1 {

  public static void main(String [] _){
    new Person1("Nicolo","Paganini");
  }
}</pre>
Wie man sieht, machen wir mit diesem Personenobjekt noch nichts. Das Programm
    hat keine Ausgabe oder Funktion.<h4>2.1.2.4. lokale Felder</h4>
<pre>class FirstLocalFields{
  public static void main(String [] args){
    String str1 = "hello";
    String str2 = "world";
    System.out.println(str1);
    System.out.println(str2);
    String str3 = str1+" "+str2;
    System.out.println(str3);
  }
}</pre>String<h4>2.1.2.5. Zugriff auf Eigenschaften eines Objektes</h4>
Wenn wir also ein Objekt in einem Feld x abgelegt haben 
und das Objekt ist vom Typ Person, der ein Feld vorname hat,
so erreichen wir das Objekt, das im Feld vorname gespeichert ist,
durch den Ausdruck: x.vorname. <pre>class GetPersonName{
  public static void main (String [] args){
    Person1 p = new Person1("August","Strindberg");

    String name = p.vorname;
    System.out.println(name);
  }
}</pre>
Ebenso k&ouml;nnen wir auf den R&uuml;ckgabewert
einer Methode zugreifen. Wir nennen dieses dann einen Methodenaufruf. 
Methodenaufrufe unterscheiden sich syntaktisch darin von Feldzugriffen,
da&szlig; eine in runden Klammern eingeschlossene Argumentliste folgt:<pre>class CallFullNameMethod{
  public static void main (String [] args){
    Person1 p = new Person1("August","Strindberg");

    String name = p.getFullName();
    System.out.println(name);
  }
}</pre>Schreiben Sie Klassen, die die Objekte des Bibliotheksystems
repr&auml;sentieren k&ouml;nnen:
              Personen mit Namen, Vornamen, Stra&szlig;e, Ort und Postleitzahl.
              B&uuml;cher mit Titel und Autor.
              Datum mit Tag, Monat und Jahr.
              Buchausleihe mit Ausleiher, Buch und Datum.
            


Hinweis: der Typ, der ganze Zahlen in Java bezeichnet, hei&szlig;t int.Schreiben Sie geeignete Konstruktoren f&uuml;r diese Klassen. Schreiben Sie f&uuml;r jede dieser Klassen eine  Methode public String toString() mit dem Ergebnistyp. 
Das Ergebnis soll eine gute textuelle Beschreibung
des Objektes sein.Sie brauchen noch nicht zu verstehen, warum vor
dem R&uuml;ckgabetyp noch ein Attribut public steht. Schreiben Sie eine Hauptmethode in einer Klasse Main, in der Sie
Objekte f&uuml;r jede der obigen Klassen erzeugen und die Ergebnisse der toString-Methode auf den Bildschirm ausgeben. Suchen Sie auf Ihrer lokalen Javainstallation oder im Netz
auf den Seiten von Sun nach
der Dokumentation der Standardklassen von Java. Suchen Sie die
Dokumentation der Klasse String. Testen Sie einige der f&uuml;r
die Klasse String definierten Methoden.<h3>2.1.3. &Uuml;berladen von Methoden</h3>
<h4>2.1.3.1. Variable Parameteranzahl</h4>
Es l&auml;&szlig;t sich so eine Methode schreiben, die mit beliebig vielen
Stringparametern aufgerufen werden kann.<pre>public class VarParams{
  static public String append(String... args){
    String result="";
    for (String a:args)
      result=result+a;
    return result;
  }

  public static void main(String [] _){
    System.out.println(append("hello"," ","world"));
  }
}</pre>
Die Methode append konkateniert endlich 
viele String-Objekte.sep@linux:~/fh/java1.5/examples&gt; javap -classpath classes/ name.panitz.java15.VarParams
Compiled from "VarParams.java"
public class name.panitz.java15.VarParams extends java.lang.Object{
    public name.panitz.java15.VarParams();
    public static java.lang.String append(java.lang.String[]);
    public static void main(java.lang.String[]);
}

sep@linux:~/fh/java1.5/examples&gt;<h3>2.1.4. der this-Bezeichner</h3>thisthisthis<pre>class UseThis {
  String aField ;
  UseThis(String aField){
    this.aField = aField;
  }
}</pre>
<h2>2.2. statische Eigenschaften</h2>static<pre>class StaticTest {
  static void printThisText(String text){
    System.out.println(text);
  }
}</pre>
<pre>class CallStaticTest {
  public static void main(String [] args){
    StaticTest.printThisText("hello");
  }
}</pre>
Erg&auml;nzen Sie jetzt die Klasse Person aus der letzten Aufgabe um ein
statisches Feld letzerVorname mit einer Zeichenkette, 
die angeben soll, welchen Vornamen das zuletzt erzeugte Objekt vom 
Typ Person hatte. Hierzu m&uuml;ssen Sie im Konstruktor der Klasse Person
daf&uuml;r sorgen, da&szlig; nach der Zuweisung der Objektfelder auch noch das
Feld letzerVorname ver&auml;ndert wird. Testen Sie in einer Testklasse, da&szlig;
sich tats&auml;chlich nach jeder Erzeugung einer neuen Person dieses Feld ver&auml;ndert
hat. <h2>2.3. Vererben und Erben</h2>Person<pre>class Person2 {

  String name ;
  String address;

  Person2(String name, String address){
    this.name = name;
    this.address = address;
  }

  public String toString(){
    return name+", "+address;
  }
}</pre>Person<pre>class StudentOhneVererbung {

  String name ;
  String address;
  int matrikelNummer;

  StudentOhneVererbung(String name, String address,int nr){
    this.name = name;
    this.address = address;
    matrikelNummer = nr;
  }

  public String toString(){
    return    name + ", " + address
            + " Matrikel-Nr.: " + matrikelNummer;
  }
}</pre>PersonStudentPersonStudentPersonextends<pre>class Student extends Person2 {</pre>extendsPerson
        Erweitern: zu den Eigenschaften der Oberklasse werden
weitere Eigenschaften hinzugef&uuml;gt. Im Beispiel der Studentenklasse
soll das Feld matrikelNummer hinzugef&uuml;gt werden.
        Ver&auml;ndern: eine Eigenschaft der Oberklasse wird
umdefiniert. Im Beispiel der Studentenklasse soll die 
Methode toString der Oberklasse in ihrer Funktionalit&auml;t
ver&auml;ndert werden.
      Dieses ist z.B.in C++ m&ouml;glich.extends<h3>2.3.1. Hinzuf&uuml;gen neuer Eigenschaften</h3>extends<pre>  int matrikelNummer;</pre>nameadressePersonmatrikelNummerStudent<pre>String writeAllFields(Student s){
   return s.name+" "+s.address+" "+s.matrikelNummer;
}</pre>
<pre>int getMatrikelNummer(){
  return matrikelNummer;
}</pre>
<h3>2.3.2. &Uuml;berschreiben bestehender Eigenschaften</h3>toStringPersonStudent<pre>  public String toString(){
    return    name + ", " + address
            + " Matrikel-Nr.: " + matrikelNummer;
  }</pre>StudentPersontoStringPersonStudent<h3>2.3.3. Konstruktion</h3>StudentPersonStudentPersonStudentPersonsupersuper<pre>   Student(String name,String adresse,int nr){
     super(name,adresse);
     matrikelNummer = nr;
   }
}</pre>StudentPersonStudentStudent<pre>class TestStudent {
  public static void main(String [] _){
    Student s
     = new Student("Martin M&uuml;ller","Hauptstra&szlig;e 2",755423);
    System.out.println(s);
  }
}</pre>
<h3>2.3.4. Zuweisungskompatibilit&auml;t</h3>StudentPersonPerson<pre>class TestStudent1{
  public static void main(String [] args){
    Person2 p 
     = new Student("Martin M&uuml;ller","Hauptstra&szlig;e",7463456);
  }
}</pre>
<pre>class StudentError1{
  public static void main(String [] args){
    Student s
      = new Person2("Martin M&uuml;ller","Hauptstra&szlig;e");
  }
}</pre>StudentError1.java:3: incompatible types
found   : Person
required: Student
    Student s = new Person2("Martin M&uuml;ller","Hauptstra&szlig;e");
                ^
1 errorPersonStudent<pre>class TestStudent2 {
   
  static void printPerson(Person2 p){
    System.out.println(p.toString());
  }

  public static void main(String [] args){
     Student s
       = new Student("Martin M&uuml;ller","Hauptstra&szlig;e",754545);
     printPerson(s);
  }
}</pre>Student<pre>class StudentError2{
   
  static void printStudent(Student s){
    System.out.println(s.toString());
  }

  public static void main(String [] args){
     Person2 p = new Person2("Martin M&uuml;ller","Hauptstra&szlig;e");
     printStudent(p);
  }
}</pre>StudentError2.java:9: printStudent(Student) in StudentError2 
                      cannot be applied to (Person2)
     printStudent(p);
     ^
1 error<h3>2.3.5. Sp&auml;te Bindung (late binding)</h3>toStringPersonStudent<pre>class TestLateBinding {
 
  public static void main(String [] args){
    Student s = new Student("Martin M&uuml;ller","Hauptstra&szlig;e",756456);
    Person2 p1 = new Person2("Harald Schmidt","Marktplatz");
    
    System.out.println(s.toString());
    System.out.println(p1.toString());

    Person2 p2 = new Student("Martin M&uuml;ller","Hauptstra&szlig;e",756456);
    System.out.println(p2.toString());
  }
}</pre>sep@swe10:~/fh/&gt; java TestLateBinding
Martin M&uuml;ller, Hauptstra&szlig;e Matrikel-Nr.: 756456
Harald Schmidt, Marktplatz
Martin M&uuml;ller, Hauptstra&szlig;e Matrikel-Nr.: 756456<pre>System.out.println(p2.toString());</pre>toStringPersontoStringStudentp2p2toStringp2.toString()Objekt, das in Feld p2 gespeichert ist, f&uuml;hre bitte
deine Methode toString aus.StudentStudentPersonlate bindingAchtung: late binding funktioniert in
Java nur bei Methoden, nicht bei Feldern.
In dieser Aufgabe sollen Sie eine Gui-Klasse benutzen und ihr eine eigene
Anwendungslogik &uuml;bergeben. Gegeben seien die folgenden Javaklassen, wobei Sie die 
Klasse Dialogue nicht zu analysieren oder zu verstehen brauchen:
            
              <pre>class ButtonLogic {
  String getDescription(){
    return "in Gro&szlig;buchstaben umwandeln";
  }
  String eval(String x){return x.toUpperCase();}
}</pre>
            
            
              
<pre>import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
class Dialogue extends JFrame{

  final ButtonLogic logic; 

  final JButton button;
  final JTextField inputField  = new JTextField(20) ;
  final JTextField outputField = new JTextField(20) ;
  final JPanel p = new JPanel();

  Dialogue(ButtonLogic l){
    logic = l;
    button=new JButton(logic.getDescription());
    button.addActionListener
     (new ActionListener(){
        public void actionPerformed(ActionEvent _){
          outputField.setText
             (logic.eval(inputField.getText().trim()));
        }
      });
    p.setLayout(new BorderLayout());
    p.add(inputField,BorderLayout.NORTH);
    p.add(button,BorderLayout.CENTER);
    p.add(outputField,BorderLayout.SOUTH);
    getContentPane().add(p);
    pack();
    setVisible(true);
  }
}</pre>
            
            
              
<pre>class TestDialogue {
  public static void main(String [] _){
    new Dialogue(new ButtonLogic());
  }
}</pre>
            
            
              &Uuml;bersetzen Sie die drei Klassen und starten Sie das Programm.
              Schreiben Sie eine Unterklasse der Klasse ButtonLogic. Sie
sollen dabei die Methoden getDescription und eval so
&uuml;berschreiben, da&szlig; der Eingabestring in Kleinbuchstaben umgewandelt wird. Schreiben Sie eine Hauptmethode, in der Sie ein Objekt der 
Klasse Dialogue mit einem Objekt Ihrer Unterklasse 
von ButtonLogic erzeugen.
              Schreiben Sie jetzt eine Unterklasse der 
Klasse ButtonLogic, so da&szlig; Sie im Zusammenspiel mit der 
Guiklasse Dialogue ein Programm erhalten, in dem Sie r&ouml;mische Zahlen
in arabische Zahlen umwandeln k&ouml;nnen. Testen Sie Ihr Programm.
              Schreiben Sie jetzt eine Unterklasse der 
Klasse ButtonLogic, so da&szlig; Sie im Zusammenspiel mit der 
Guiklasse Dialogue ein Programm erhalten, in dem Sie arabische Zahlen
in r&ouml;mische Zahlen umwandeln k&ouml;nnen. Testen Sie Ihr Programm.
              Schreiben Sie jetzt ein Guiprogramm, da&szlig; eine Zahl aus ihrer Darstellung
zur Basis 10 in eine Darstellung zur Basis 2 umwandelt. Testen Sie.
            
          <h4>2.3.5.1. Methoden als Daten</h4>Dialogue<pre>  Dialogue(ButtonLogic l){
    logic = l;
    button=new JButton(logic.getDescription());</pre>ButtonLogicString eval(String x)String getDescription()DialogueButtonLogicDialogue<h3>2.3.6. Zugriff auf Methoden der Oberklasse</h3>toStringPersonStudentStudent<pre>  public String toString(){
    return    name + ", " + address
            + " Matrikel-Nr.: " + matrikelNummer;
  }</pre>
<pre>name + ", " + address</pre>toStringPersonsupersupertoStringStudent<pre>  public String toString(){
    return      //call toString of super class
                super.toString()  
                //add the Matrikelnummer
            + " Matrikel-Nr.: " + matrikelNummer;
  }</pre>
<h3>2.3.7. Die Klasse Object</h3>extendsObjectObjectextendsObjectObjectJava kennt acht eingebaute primitive Typen
f&uuml;r Zahlen, Wahrheitswerte und Buchstaben. Diese sind zwar keine Objekte,
werden notfalls von Java aber in entsprechende Objektklassen automatisch konvertiert.ObjecttoStringtoStringObjectObject<h4>2.3.7.1. Die Methode equals</h4>Objectequals<pre>public boolean equals(Object other)</pre>equals<pre>public boolean equals(Object other){
  return        this.name.equals(other.name) 
             &amp;&amp; this.adresse.equals(other.adresse);
}</pre>otherObjectnameadresse<h3>2.3.8. Klassentest</h3>instanceof<pre>class InstanceOfTest {
  public static void main(String [] str){
     Person2 p1 = new Person2("Strindberg","Skandinavien");
     Person2 p2 = new Student("Ibsen","Skandinavien",789565);
     if (p1 instanceof Student) 
       System.out.println("p1 ist ein  Student.");
     if (p2 instanceof Student) 
       System.out.println("p2 ist einStudent.");
     if (p1 instanceof Person2) 
       System.out.println("p1 ist eine Person.");
     if (p2 instanceof Person2) 
       System.out.println("p2 ist eine Person.");
  }
}</pre>instanceofsep@swe10:~/fh&gt; java InstanceOfTest
p2 ist einStudent.
p1 ist eine Person.
p2 ist eine Person.<h3>2.3.9. Typzusicherung (Cast)</h3>p2p2Student<pre>class CastTest {
  public static void main(String [] str){
    Person2 p = new Student("Ibsen","Skandinavien",789565);

    if (p instanceof Student){ 
      Student s = (Student)p;
      System.out.println(s.matrikelNummer);
    }
  }
}</pre>s = (Student)p;pStudent<pre>class CastError {
  public static void main(String [] str){
    Person2 p = new Person2("Strindberg","Skandinavien");
    Student s = (Student)p;
    System.out.println(s.matrikelNr);
  }
}</pre>Studentsep@swe10:~/fh&gt; java CastError       
Exception in thread "main" java.lang.ClassCastException: Person2
        at CastError.main(CastError.java:4)PersoninstanceofequalsPerson<pre>public boolean equals(Object other){
  boolean erg = false;
  if (other instanceof Person2){
     Person2 p = (Person2) other;
     erg = this.name.equals(p.name) 
             &amp;&amp; this.adresse.equals(p.adresse);
  }
  return erg;        
}</pre>Person<h1>3. Imperative Konzepte</h1>Gerade in diesem
Bereich wollten die Entwickler von Java einen leichten Umstieg von der
C-Programmierung nach Java erm&ouml;glichen. Leider hat Java in dieser
Hinsicht auch ein C-Erbe und ist nicht in allen Punkte so sauber
entworfen, wie es ohne diese Designvorgabe w&auml;re.<h2>3.1. Primitive Typen, die klassenlose Gesellschaft</h2>
<h3>3.1.1. Zahlenmengen in der Mathematik</h3>
          nat&uuml;rliche Zahlen: Eine induktiv definierbare Menge
mit einer kleinsten Zahl, so da&szlig; es f&uuml;r jede Zahl eine eindeutige
Nachfolgerzahl gibt.
          ganze Zahlen: Die nat&uuml;rlichen Zahlen erweitert um die
mit einem negativen Vorzeichen behafteten Zahlen, die sich ergeben, wenn man
eine gr&ouml;&szlig;ere Zahl von einer nat&uuml;rlichen Zahl abzieht.
          rationale Zahlen: Die ganzen Zahlen erweitert um
Br&uuml;che, die sich ergeben, wenn man eine Zahl durch eine Zahl teilt, von der
sie kein Vielfaches ist.
          reelle Zahlen: Die ganzen Zahlen erweitert um
irrationale Zahlen, die sich z.B.aus der Quadratwurzel von Zahlen 
ergeben, die nicht das Quadrat einer rationalen Zahl sind. 
          komplexe Zahlen: Die reellen Zahlen erweitert um
imagin&auml;re Zahlen, wie sie ben&ouml;tigt werden, um einen Wurzelwert
f&uuml;r  negative Zahlen darzustellen.
        
          
          
          
          
          
          
          
          
          
        <h3>3.1.2. Zahlenmengen im Rechner</h3>ein anderes selten
gebrauchtes  Wort aus dem Franz&ouml;sischen ist: Oktett<h3>3.1.3. nat&uuml;rliche Zahlen</h3>bbb &gt; 10b-1an-1a0b
            i=0
            n-1
           ai*bi
= a0*b0 +  + an-1*b n-1
          2: Dualsystem
          8: Oktalsystem
          10: Dezimalsystem
          16: HexadezimalsystemEine etwas ungl&uuml;ckliche Namensgebung aus
der Mischung eines griechischen mit einem lateinischen Wort.
         Die Zahl 10 in Bezug auf unterschiedliche Basen dargestellt:(10)10=
(A)16=
(12)8=
(1010)20232-1<h3>3.1.4. ganze Zahlen</h3>Wobei
wir gro&szlig;z&uuml;gig den Typ char ignorieren.int<h4>3.1.4.1. Vorzeichen und Betrag</h4>nn-1In der Darstellung durch Vorzeichen und Betrag werden bei einer
Wortl&auml;nge von 8 Bit die Zahlen 10 und -10 durch folgende 
Bitmuster repr&auml;sentiert: 00001010 und 10001010. 1000000000000000n-2n-1-12n-1-1Versuchen wir, das g&auml;ngige Additionsverfahren 
f&uuml;r 10 und -10 in der Vorzeichendarstellung anzuwenden, so
erhalten wir:
              
                
                  0
                  0
                  0
                  0
                  1
                  0
                  1
                  0
                
                
                  1
                  0
                  0
                  0
                  1
                  0
                  1
                  0
                
                
                
                  1
                  0
                  0
                  1
                  0
                  1
                  0
                  0
                
              
            



Das Ergebnis stellt keinenfalls die 
Zahl 0 dar, sondern die Zahl -20.<h4>3.1.4.2. Einerkomplement</h4>Bei einer Wortl&auml;nge von 8 Bit werden die 
Zahlen 10 und -10 durch folgende Bitmuster 
dargestellt: 00001010 und 11110101.

Jetzt k&ouml;nnen auch negative Zahlen mit dem g&auml;ngigen Additionsverfahren addiert
werden, also kann die Subtraktion durch ein Additionsverfahren durchgef&uuml;hrt
werden. 
              
                
                  0
                  0
                  0
                  0
                  1
                  0
                  1
                  0
                
                
                  1
                  1
                  1
                  1
                  0
                  1
                  0
                  1
                
                
                
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                
              
            

Das errechnete Bitmuster stellt die negative Null
dar.0n-2n-1-12n-1-1<h4>3.1.4.3. Zweierkomplement</h4>Bei einer Wortl&auml;nge von 8 Bit werden die 
Zahlen 10 und -10 durch folgende Bitmuster 
dargestellt: 00001010 und 11110110.

Jetzt k&ouml;nnen weiterhin auch negative Zahlen mit dem 
g&auml;ngigen Additionsverfahren addiert
werden, also kann die Subtraktion durch ein Additionsverfahren durchgef&uuml;hrt
werden. 
              
                
                  0
                  0
                  0
                  0
                  1
                  0
                  1
                  0
                
                
                  1
                  1
                  1
                  1
                  0
                  1
                  1
                  0
                
                
                
                  0
                  0
                  0
                  0
                  0
                  0
                  0
                  0
                
              
            


Das errechnete Bitmuster stellt die  Null
dar.negative-1
          
            
            
              
                Typname
              
              
                L&auml;nge
              
              
                Wertebereich
              
            
            
            
              
                byte
              
              8 Bit 
              -128=-27 bis 127=27-1
            
            
            
              
                short
              
              16 Bit
              -32768=-215 bis 32767=215-1
            
            
            
              
                int
              
              32 Bit
              -2147483648=-231 bis 2147483647=232-1
            
            
            
              
                long
              
              64 Bit
              -9223372036854775808 bis 9223372036854775807
            
            
          
        
Starten Sie folgendes Javaprogramm:<pre>class TestInteger {
  public static void main(String [] _){
    System.out.println(2147483647+1);
    System.out.println(-2147483648-1);
  }
}</pre>
Erkl&auml;ren Sie die Ausgabe.<h4>3.1.4.4. Frage eines Softwaremenschen an die Hardwarebauer</h4>nannot a numbernan<h3>3.1.5. Kommazahlen</h3>diskretisieren<h4>3.1.5.1. Festkommazahlen</h4>nnan-1an/2,an/2-1a0b
              i=0
              n-1
             aii-n/2
= a0*b-n/2 +  + an-1*bn-1-n/20,1<h4>3.1.5.2. Flie&szlig;kommazahlen</h4>b
            die Mantisse f&uuml;r die darstellbaren Ziffern. Die Mantisse
charakterisiert die Genauigkeit der Flie&szlig;kommazahl.
            der Exponent, der angibt, wie weit die Mantisse hinter bzw. vor dem
Komma liegt. 
          mbexpz = m * b exp
            float: 32 Bit Flie&szlig;kommazahl nach IEEE 754. Kleinste positive
Zahl: 2-149. 
Gr&ouml;&szlig;te positive 
Zahl: (2-2-23)*127
            double: 64 Bit Flie&szlig;kommazahl nach IEEE 754. Kleinste positive
Zahl: 2-1074. 
Gr&ouml;&szlig;te positive 
Zahl: (2-2-52)*1023
          doublefloat
Der folgende Test zeigt, da&szlig; bei einer Addition von zwei Flie&szlig;kommazahlen die
kleinere Zahl das Nachsehen hat:  <pre>class DoubleTest{
  public static void main(String [] args){
    double x = 325e200;
    double y = 325e-200;
    System.out.println(x);
    System.out.println(y);
    System.out.println(x+y);
    System.out.println(x+100000);
  } 
}</pre>

Wie man an der Ausgabe erkennen kann: selbst die Addition der 
Zahl 100000 bewirkt keine Ver&auml;nderung auf einer gro&szlig;en
Flie&szlig;kommazahl: sep@linux:~/fh/prog3/examples/src&gt; java DoubleTest
3.25E202
3.25E-198
3.25E202
3.25E202
sep@linux:~/fh/prog3/examples/src&gt;
Das folgende kleine Beispiel zeigt, inwieweit und f&uuml;r den Benutzer oft auf
&uuml;berraschende Weise die Flie&szlig;kommadarstellung zu Rundungen f&uuml;hrt:<pre>class Rounded {
  public static void main(String [] args){
    System.out.println(8f);
    System.out.println(88f);
    System.out.println(8888f);
    System.out.println(88888f);
    System.out.println(888888f);
    System.out.println(8888888f);
    System.out.println(88888888f);
    System.out.println(888888888f);
    System.out.println(8888888888f);
    System.out.println(88888888888f);
    System.out.println(888888888888f);
    System.out.println(8888888888888f);

    System.out.println(1f+1000000000000f-1000000000000f);
  } 
}
</pre>
Das Programm hat die folgende Ausgabe. Insbesondere in der letzten Zeile
  f&auml;llt auf, da&szlig; Addition und anschlie&szlig;ende Subtraktion ein und derselben Zahl
  nicht die Identit&auml;t ist. F&uuml;r Flie&szlig;kommazahlen gilt 
nicht: x + y - y = x.sep@linux:~/fh/prog3/examples/src&gt; java Rounded
8.0
88.0
8888.0
88888.0
888888.0
8888888.0
8.8888888E7
8.888889E8
8.8888893E9
8.8888885E10
8.8888889E11
8.8888889E12
0.0
sep@linux:~/fh/prog3/examples/src&gt;<h3>3.1.6. Der Typ: boolean</h3>Wahr oder falsch, eine dritte M&ouml;glikchkeit gibt es
nicht. Logiker postulieren dieses als tertium non
datur.booleantruefalse<pre>class Testbool{
  boolean boolFeld;

  Testbool(boolean b){
    boolFeld = b;
  }

  boolean getBoolFeld(){
    return this.boolFeld;
  }

  public static void main(String [] args){
    Testbool t = new Testbool(true);
    System.out.println(t.getBoolFeld());
    t = new Testbool(false);
    System.out.println(t.getBoolFeld());
  }
}</pre>
<h3>3.1.7. Boxen f&uuml;r primitive Typen</h3>java.langByteShortIntegerLongFloatDoubleBooleanCharacterboxingunboxingintValue()
In diesem Beispiel sieht man das manuelle Verpacken und Auspacken primitiver
Daten. <pre>package name.panitz.boxing;
public class ManualBoxing{
  public static void main(String [] _){
    int i1 = 42;
    Object o = new Integer(i1);
    System.out.println(o);
    Integer i2 = new Integer(17);
    Integer i3 = new Integer(4);
    int i4 = 21;
    System.out.println((i2.intValue()+i3.intValue())*i4);
  }
}</pre>boxingunboxing
Jetzt das vorherige kleine Programm ohne 
explizite boxing- und unboxing-Aufrufe.<pre>package name.panitz.boxing;
public class AutomaticBoxing{
  public static void main(String [] _){
    int i1 = 42;
    Object o = i1;
    System.out.println(o);
    Integer i2 = 17;
    Integer i3 = 4;
    int i4 = 21;
    System.out.println((i2+i3)*i4);
  }
}</pre>
<h2>3.2. Operatoren</h2>*, -, /
        Pr&auml;fix: Der Operator wird vor den Operanden geschrieben,
also z.B.(* 2 21). Im urspr&uuml;nglichen Lisp gab es die
Prefixnotation f&uuml;r Operatoren.
 
        Postfix: Der Operator folgt den Operanden, also 
z.B.(21 2 *). Forth und Postscript sind Beispiele von
Sprachen mit Postfixnotation.
        Infix: Der Operator steht zwischen den Operanden. Dieses
ist die g&auml;ngige Schreibweise in der Mathematik und f&uuml;r das Auge die
gewohnteste. Aus diesem Grunde bedient sich Java der 
Infixnotation: 42 * 2.
      <h4>3.2.1. Die Grundrechenarten</h4>
<pre>class PunktVorStrich{
  public static void main(String [] args){
    System.out.println(2 + 20 * 2);
    System.out.println((2 + 20) * 2);
  }
}</pre>
<pre>class Square{
  static int square(int i){
    return i*i;
  }
}</pre>
<h4>3.2.2. Vergleichsoperatoren</h4>&lt;, &lt;=, &gt;, &gt;=, !=, ====!=<pre>class Vergleich{

  public static void main(String[] args){
    System.out.println(1+1 &lt; 42);
    System.out.println(1+1 &lt;= 42);
    System.out.println(1+1 &gt;  42);
    System.out.println(1+1 &gt;= 42);
    System.out.println(1+1 == 42);
    System.out.println(1+1 != 42);
  }
}</pre>
<h4>3.2.3. Bool'sche Operatoren</h4>&amp;&amp;
          
        ||
          
        !&amp;&amp;||<pre>class TestboolOperator{
  public static void main(String [] args){
    System.out.println(true &amp;&amp; false);
    System.out.println(true || false);
    System.out.println(!true || false);
    System.out.println(true || true &amp;&amp; false);
  }
}</pre>
<pre>class TestboolOperator2{
  static boolean implication(boolean a, boolean b){
    return !a || b;
  }

  public static void main(String [] args){
    System.out.println(implication(true, false));
  }
}</pre>
<h2>3.3. Zusammengesetzte Befehle</h2>Konstrukte mit Operatoren nennt man dagegen
Ausdr&uuml;cke.<h3>3.3.1. Bedingungsabfrage mit: if</h3>ififelse<pre>class FirstIf {

  static void firstIf(boolean bedingung){
    if (bedingung) {
      System.out.println("Bedingung ist wahr");
    } else {
      System.out.println("Bedingung ist falsch");
    }
  }
 
  public static void main(String [] args){
     firstIf(true || false);
  }

}</pre>if<pre>class FirstIf2 {

  static void firstIf(boolean bedingung){
    if (bedingung) System.out.println("Bedingung ist wahr");
    else System.out.println("Bedingung ist falsch");
  }
 
  public static void main(String [] args){
     firstIf(true || false);
  }

}</pre>ififelse<pre>class ElseIf {

  static String lessOrEq(int i,int j){
    if (i&lt;10)  return "i kleiner zehn";
    else if (i&gt;10)  return "i gr&ouml;&szlig;er zehn";
    else if (j&gt;10)  return "j gr&ouml;&szlig;er zehn";
    else if (j&lt;10)  return "j kleiner zehn";
    else return "j=i=10";
  }
 
  public static void main(String [] args){
     System.out.println(lessOrEq(10,9));
  }

}</pre>ifSpaghetti-codei1n<pre>class Summe{
  static int summe(int i){
    if (i==1)  {
      return 1;
    }else {
      return summe(i-1) + i;
    }
  }
}</pre>summeisumme(4)summe(4-1)+4summe(3)+4summe(3-1)+3+4summe(2)+3+4summe(2-1)+2+3+4summe(1)+2+3+41+2+3+43+3+46+410i=4summe1RekursionErg&auml;nzen Sie ihre Klasse Ausleihe um eine 
Methode void verlaengereEinenMonat(), die den R&uuml;ckgabetermin des
Buches um einen Monat erh&ouml;ht.Modellieren und schreiben Sie eine Klasse Counter,
die einen Z&auml;hler darstellt. Objekte dieser Klasse sollen folgende
Funktionalit&auml;t bereitsstellen:
            Eine Methode click(), die den internen Z&auml;hler um eins
erh&ouml;ht. 
            Eine Methode reset(), die den Z&auml;hler wieder auf den
Wert 0 setzt.
            Eine Methode, die den aktuellen Wert des Z&auml;hlers ausgibt.
          
Testen Sie Ihre Klasse.Schreiben Sie mit den bisher vorgestellten Konzepten ein Programm,
das unendlich oft das Wort Hallo auf den Bildschirm ausgibt. Was
beobachten Sie, wenn sie das Programm lange laufen lassen?Schreiben Sie eine Methode, die f&uuml;r eine ganze Zahl die
Fakult&auml;t dieser Zahl berechnet. Testen Sie die Methode zun&auml;chst mit
kleinen Zahlen, anschlie&szlig;end mit gro&szlig;en Zahlen. Was stellen Sie fest?Modellieren und schreiben Sie eine Klasse, die ein Bankkonto
darstellt. Auf das Bankkonto sollen Einzahlungen und Auszahlungen
vorgenommen werden k&ouml;nnen. Es gibt einen maximalen Kreditrahmen. Das
Konto soll also nicht beliebig viel in die Miese gehen
k&ouml;nnen. Schlie&szlig;lich mu&szlig; es eine M&ouml;glichkeit geben, Zinsen zu berechnen
und dem Konto gutzuschreiben.<h3>3.3.2. Iteration</h3>
<h4>3.3.2.1. Schleifen mit: while</h4>while
            die Bedingung
            und den Schleifenrumpf.
          while
Die vorgepr&uuml;ften Schleifen haben folgendes Schema in Java:
              
                while (
                pred
                )
                body
                
                  
                
              
             pred ist hierbei ein Ausdruck, der zu einem bool'schen Wert
auswertet. body ist eine Folge von Befehlen. Java arbeitet
die vorgepr&uuml;fte Schleife ab, indem erst die Bedingung pred
ausgewertet wird. Ist das Ergebnis true, dann wird der 
Rumpf (body) der Schleife durchlaufen. Anschlie&szlig;end wird
wieder die Bedingung gepr&uuml;ft. Dieses wiederholt sich so lange, bis die
Bedingung zu false auswertet.
Ein simples Beispiel einer vorgepr&uuml;ften Schleife ist folgendes Programm,  das
die Zahlen von 0 bis 9 auf dem Bildschirm ausgibt:<pre>class WhileTest {
  public static void main(String [] args){
    int i = 0;
    while (i &lt; 10){
      i = i+1;
      System.out.println(i);    
    }
  }
}</pre>

Mit diesen Mitteln k&ouml;nnen wir jetzt versuchen, die im letzten
Abschnitt rekursiv geschriebene Methode summe iterativ zu
schreiben:<pre>class Summe2 {
  public static int summe(int n){

    int erg = 0 ;              // Feld f&uuml;r Ergebnis.
    int j   = n ;              // Feld zur Schleifenkontrolle.

    while (j&gt;0){               // j l&auml;uft von n bis 1.     
      erg = erg + j;           // akkumuliere das Ergebnis.
      j = j-1;                 // verringere Laufz&auml;hler.
    }

    return erg;
  }
}</pre> 

Wie man an beiden Beispielen oben sieht, gibt es oft ein Feld, das zur
Steuerung der Schleife benutzt wird. Dieses Feld ver&auml;ndert innerhalb
des Schleifenrumpfes seinen Wert. Abh&auml;ngig von diesem Wert wird die
Schleifenbedingung beim n&auml;chsten Bedingungstest wieder wahr oder
falsch.
Schleifen haben die unangenehme Eigenschaft, da&szlig; sie eventuell nie
verlassen werden. Eine solche Schleife l&auml;&szlig;t sich minimal wie folgt
schreiben: <pre>class Bottom {
   static public void bottom(){
     while (wahr()){};
   }

   static boolean wahr(){return true;}

   public static void main(String [] _){bottom();}
}</pre>

Ein Aufruf der Methode bottom startet eine nicht endende
Berechnung.  H&auml;ufige Programmierfehler sind inkorrekte Schleifenbedingungen oder
falsch kontrollierte Schleifenvariablen. Das Programm terminiert dann
mitunter nicht. Solche Fehler sind in komplexen Programmen oft schwer
zu finden.
In der zweiten Variante der while-Schleife steht die
Schleifenbedingung syntaktisch nach dem Schleifenrumpf: 
              
                do 
                body
                 while (
                pred
                )
              
            
Bei der Abarbeitung einer solchen Schleife wird entsprechend der
Notation, die Bedingung erst nach der Ausf&uuml;hrung des Schleifenrumpfes 
gepr&uuml;ft. Am Ende wird also gepr&uuml;ft, ob die Schleife ein weiteres Mal
zu durchlaufen ist. Das impliziert insbesondere, da&szlig; der Rumpf
mindestens einmal durchlaufen wird.
Die erste Schleife, die wir f&uuml;r die vorgepr&uuml;fte Schleife geschrieben
haben, hat folgende  nachgepr&uuml;fte Variante:<pre>class DoTest {
  public static void main(String [] args){
    int i = 0;
    do {
      System.out.println(i);    
      i = i+1;
    } while (i &lt; 10);
  }
}</pre>

Man kann sich leicht davon vergewissern, da&szlig; die nachgepr&uuml;fte Schleife
mindestens einmal durchlaufenDer Java&uuml;bersetzer macht kleine
Pr&uuml;fungen auf konstanten Werten, ob Schleifen jeweils durchlaufen
werden oder nicht terminieren. Deshalb brauchen wir 
die Hilfsmethode {\tt falsch()}. wird:<pre>class VorUndNach {

  public static void main(String [] args){

      while (falsch()) 
         {System.out.println("vorgepr&uuml;fte Schleife");};

      do {System.out.println("nachgepr&uuml;fte Schleife");} 
      while (false);
  }

  public static boolean falsch(){return false;}
}</pre>
<h4>3.3.2.2. Schleifen mit: for</h4>forforintIteratorfor
             eine Initialisierung der
relevanten Schleifensteuerungsvariablen (init),
            ein Pr&auml;dikat als 
Schleifenbedingung (pred)
            und einen
Befehl, der die Schleifensteuerungsvariable 
weiterschaltet (step).
          
            
              for (
              init, pred, step
              )
              body
              
                
              
            
          for<pre>class ForTest {
  public static void main(String [] args){

    for (int i=0; i&lt;10; i=i+1){
      System.out.println(i);    
    }  

  }
}</pre>forforwhilesummefor<pre>class Summe3 {
  public static int summe(int n){

    int erg = 0 ;                   // Feld f&uuml;r Ergebnis

    for (int j = n;j&gt;0;j=j-1){      // j l&auml;uft von n bis 1     
      erg = erg + j;                // akkumuliere das Ergebnis
    }

    return erg;
  }
}</pre>whileforforfor<pre>class Summe4 {
  public static int summe(int n){

    int erg = 0 ;              // Feld f&uuml;r Ergebnis.
    int j   = n;              // Feld zur Schleifenkontrolle

    for (;j&gt;0;){               // j l&auml;uft von n bis 1     
      erg = erg + j;           // akkumuliere das Ergebnis.
      j = j-1;                 // verringere Laufz&auml;hler  
    }

    return erg;
  }
}</pre>whilefor<h4>3.3.2.3. Vorzeitiges Beenden von Schleifen</h4>
Der Befehl, um eine Schleife komplett zu verlassen, 
hei&szlig;t break. Der break f&uuml;hrt zum sofortigen Abbruch der n&auml;chsten &auml;u&szlig;eren Schleife.
Der break-Befehl wird in der Regel mit 
einer if-Bedingung auftreten. Mit diesem Befehl l&auml;&szlig;t sich die Schleifenbedingung auch im Rumpf der
Schleife ausdr&uuml;cken. Das Programm der Zahlen 0 bis 9 l&auml;&szlig;t sich
entsprechend unsch&ouml;n auch mit Hilfe des break-Befehls wie
folgt schreiben.<pre>class BreakTest {
  public static void main(String [] args){
    int i = 0;
    while (true){
      if (i&gt;9) {break;};
      i = i+1;
      System.out.println(i);    
    }
  }
}</pre>

Gleichfalls l&auml;&szlig;t sich der break-Befehl in 
der for-Schleife anwenden. Dann wird der Kopf  der for-Schleife vollkommen leer: <pre>class ForBreak {
  public static void main(String [] args){
    int i = 0;
    for (;;){
        if (i&gt;9) break;
        System.out.println(i);
        i=i+1; 
    }  
  }
}</pre>

In der Praxis wird der break-Befehl gerne f&uuml;r besondere Situationen inmitten einer l&auml;ngeren Schleife benutzt, z.B. f&uuml;r externe
Signale.  Die zweite M&ouml;glichkeit, den Schleifendurchlauf zu unterbrechen, ist der
Befehl continue. Diese Anweisung bricht nicht die Schleife
komplett ab, sondern nur den aktuellen Durchlauf. Es wird zum n&auml;chsten 
Durchlauf gesprungen. 
Folgendes kleines Programm druckt mit Hilfe 
des continue-Befehls die Zahlen aus, die durch 17 oder 19 teilbar sind:<pre>class ContTest{
  public static void main(String [] args){
     for (int i=1; i&lt;1000;i=i+1){           
        if (!(i % 17 == 0 || i % 19 == 0) )
   //wenn nicht die Zahl durch 17 oder 19 ohne Rest teilbar ist
            continue;
	System.out.println(i);  
     }
  }
}</pre>

Wie man an der Ausgabe dieses Programms sieht, wird mit dem 
Befehl continue der Schleifenrumpf verlassen und die
Schleife im Kopf weiter abgearbeitet. F&uuml;r die for-Schleife
hei&szlig;t das insbesondere, da&szlig; die Schleifenweiterschaltung der n&auml;chste
Ausf&uuml;hrungsschritt ist. 
 Schreiben Sie jetzt die Methode zur Berechnung der Fakult&auml;t, indem
Sie eine Iteration und nicht eine Rekursion benutzen.Schreiben Sie eine 
Methodestatic String darstellungZurBasis(int x,int b), 
die als Parameter eine  
Zahl x und eine zweite Zahl b erh&auml;lt. 
Sie d&uuml;rfen annehmen, da&szlig; x&gt;0 und 1&lt;b&lt;11.
Das Ergebnis soll 
eine Zeichenkette vom Typ String sein, in der die 
Zahl x zur Basis b dargestellt ist. Testen Sie ihre Methode mit
unterschiedlichen Basen.Hinweis: Der zweistellige Operator % berechnet den
ganzzahligen Rest einer Division. Bei einem geschickten Umgang mit den
Operatoren %, / und + und einer while-Schleife
kommen Sie mit sechs Zeilen im Rumpf der Methode aus. Schreiben Sie eine Methode static int readIntBase10(String str). Diese 
Methode soll einen String, der nur aus Ziffern besteht, in die von ihm repr&auml;sentierte Zahl umwandeln. Benutzen sie
hierzu die Methode charAt der String-Klasse, 
die es erlaubt, einzelne
Buchstaben einer Zeichenkette zu selektieren. <h3>3.3.3. die switch Anweisung</h3>switchswitchifthenswitchswitch
          
            
              switch (
              expr
              )
              
              
                case 
              const
              : 
              stats
              
              
              
              
              
              
              
                case 
              const
              : 
              stats
              
              
                default: 
              stats
              
              
                case 
              const
              : 
              stats
              
              
              
              
              
              
              
                case 
              const
              : 
              stats
              
              
                
              
            
          
        switchcasedefaultswitch
Ein kleines Beispiel soll die operationale Semantik dieser Anweisung
verdeutlichen. <pre>class Switch {

  public static void main (String [] args){
    switch (4*new Integer(args[0]).intValue()){
      case 42 : System.out.println(42);
      case 52 : System.out.println(52);
      case 32 : System.out.println(32);
      case 22 : System.out.println(22);
      case 12 : System.out.println(12);
      default : System.out.println("default");
    }
  }
}</pre>
Starten wir das Programm mit dem Wert 13, so da&szlig; der
    Ausdruck, nach dem wir die Fallunterscheidung durchf&uuml;hren 
zu 52 auswertet, so bekommen wir folgende Ausgabe:sep@swe10:~/fh/internal/beispiele&gt; java Switch 13
52
32
22
12
default
sep@swe10:~/fh/internal/beispiele&gt;

Wie man sieht, springt die switch-Anweisung zum Fall f&uuml;r den
Wert 52, f&uuml;hrt aber nicht nur dessen Anweisungen aus, sondern
alle folgenden Anweisungen.breakbreak
Das obige Beispiel l&auml;&szlig;t sich durch Hinzuf&uuml;gen 
der break-Anweisung so &auml;ndern, da&szlig; immer nur ein Fall
ausgef&uuml;hrt wird.<pre>class Switch2 {

  public static void main (String [] args){
    switch (4*new Integer(args[0]).intValue()){
      case 42 : System.out.println(42);break;
      case 52 : System.out.println(52);break;
      case 32 : System.out.println(32);break;
      case 22 : System.out.println(22);break;
      case 12 : System.out.println(12);break;
      default : System.out.println("default");
    }
  }
}</pre>
An der Ausgabe sehen wir, da&szlig; zu einem Fall gesprungen wird und am
    Ende dieses Falls die Anweisung verlassen wird. sep@swe10:~/fh/internal/beispiele&gt; java Switch2 13
52
sep@swe10:~/fh/internal/beispiele&gt;<h3>3.3.4. Rekursion und Iteration</h3>stackstack<pre>class StackTest {
  public static void main(String [] args){
    System.out.println(count1(0));
    System.out.println(count2(0));
  }

  public static int count1(int k){
    int j = 2;
    for (int i= 0;i&lt;1000000000;i=i+1){
      j=j+1;
    }  
    return j;
  }

  public static int count2(int i){
      if (i&lt;1000000000) return count2(i+1) +1; else return 2;
  }

}
</pre>
<h2>3.4. Ausdr&uuml;cke und Befehle</h2>In der Literatur findet man mitunter auch den
Ausdruck Anweisung f&uuml;r das, was wir als Befehl
bezeichnen. Befehl bezeichnet dann den Oberbegriff f&uuml;r
Anweisungen und 
Ausdr&uuml;cke.expressionsstatements
        
          
            Ausdr&uuml;cke
          
          
            Befehle
          
        
        
        
        
          Literale: 1, "fgj"
          Zuweisung: x=1;
        
        
        
          Operatorausdr&uuml;cke: 1*42
          Felddeklaration: int i;
        
        
        
          Feldzugriffe: obj.myField
          
            zusammengesetzte 
Befehle (if, while, for)
          
        
        
        
          
            Methodenaufrufe 
mit Methodenergebnis:obj.toString()
          
          
            Methodenaufrufe 
ohne Methodenergebnis:System.out.println("hallo")
          
        
        
        
          
             
Erzeugung neuer
Objektenew MyClass(56)
          
          
             
Ablaufsteuerungsbefehle 
wiebreak, continue, return
          
        
        
      boolean<h3>3.4.1. Bedingungen als Befehl oder als Ausdruck</h3>if
          
            pred
            ?
            alt1
            :
            alt2
          
        ifelse<pre>class CondExpr {
  public static void main(String [] _){
    System.out.println(true?1:2);
    System.out.println(false?3:4);
  }
}</pre>sep@linux:~/fh/prog1/examples/classes&gt; java CondExpr
1
4
sep@linux:~/fh/prog1/examples/classes&gt;<h3>3.4.2. Auswertungsreihenfolge und Seiteneffekte von Ausdr&uuml;cken</h3>(23-1)*(4-2)4223-14-2<h4>3.4.2.1. Reihenfolge der Operanden</h4>
<pre>class Minus {

  static public int sub(int x,int y){
    int erg = x-y;
    System.out.println("eine Subtraktion mit Ergebnis: "
                       +erg+" wurde durchgef&uuml;hrt.");
    return erg;
  }
}</pre>subsub<pre>class Operatorauswertung {

   public static void main(String [] args){
     System.out.println(Minus.sub(23,1)*Minus.sub(4,2));
   }
}</pre>sep@swe10:~/fh/prog1/beispiele&gt; java Operatorauswertung 
eine Subtraktion mit Ergebnis: 22 wurde durchgef&uuml;hrt.
eine Subtraktion mit Ergebnis: 2 wurde durchgef&uuml;hrt.
44
sep@swe10:~/fh/prog1/beispiele&gt; <h4>3.4.2.2. Auswertung der Methodenargumente</h4>
<pre>public class Reihenfolge{

    /**
       Returns second argument.
       @param x ignored  argument.
       @param y returned argument.
       @return projection on second argument.
     **/
  public static int snd(int x,int y){return y;}
</pre>
<pre>    /**
       Returns the constants 1 and prints its argument.  
       @param  str The String that is printed as side effect.
       @return constantly 1. 
    **/
  public static int eins(String str){
    System.out.println(str); return 1;
  }</pre>snd<pre>  public static void main(String [] args){
    //&lt;bluev&gt;test, in which order arguments are evaluated.&lt;/bluev&gt;
    snd(eins("a"),eins("b"));
}}</pre>
<h4>3.4.2.3. Terminierung</h4>
<pre>class TerminationTest {
    /**
      Nonterminating method.
      @return never returns anything.
     **/
  public static int bottom( ){while(wahr()){};return 1; }

    /**
       Returns the constants 1 and prints its argument.  
       @param  str The String that is printed as side effect.
       @return constantly 1. 
    **/
  public static int eins(String str){
    System.out.println(str); return 1;
  }

    /**
       Constantly true method.
       @return constantly the value true.
    **/
  public static boolean wahr( ){return true; }</pre>
<pre>    /**
       Method mimicking conditional expression.
       @param pre The boolean condition.
       @param a1 The positive alternative.
       @param a2 The negative alternative.
       @return in case of pre the second otherwise third argument
     **/
  public static int wenn(boolean pre,int a1,int a2 ){
    return pre?a1:a2; }</pre>
<pre>  public static void main(String [] args){

    //test, whether both alternatives of conditional
    //expression are evaluated or just one.

    //this will terminate:
    System.out.println(      false?bottom():eins("b")   );
    
    //this won't terminate:
    System.out.println(wenn( false,bottom(),eins("b") )  );
  }
}</pre>nicht striktstrikt<h3>3.4.3. Auswertung der bool'schen Operatoren</h3>und&amp;&amp;oder||true  A = true und false  A = false<pre>class LazyBool {

  static boolean booleanExpr(){
    System.out.println("in booleanExpr");
    return true;
  }

  static public void main(String [] _){
    System.out.println(true || booleanExpr());
    System.out.println(false &amp;&amp; booleanExpr());
  }

}</pre>sep@linux:~/fh/prog1/examples/classes&gt; java LazyBool
true
false
sep@linux:~/fh/prog1/examples/classes&gt;booleanExpr&amp;&amp;||<h4>3.4.3.1. strikte bool'sche Operatoren</h4>&amp;&amp;||&amp;|undoderstriktKommt zur nicht-strikten
Strategie noch eine Strategie hinzu, die verhindert, da&szlig; Ausdr&uuml;cke
doppelt ausgewertet werden, so spricht man von einer 
faulen (lazy) Auswertung.booleanExpr<pre>class StrictBool {

  static boolean booleanExpr(){
    System.out.println("in booleanExpr");
    return true;
  }

  static public void main(String [] _){
    System.out.println(true | booleanExpr());
    System.out.println(false &amp; booleanExpr());
  }

}</pre>sep@linux:~/fh/prog1/examples/classes&gt; java StrictBool
in booleanExpr
true
in booleanExpr
false
sep@linux:~/fh/prog1/examples/classes&gt;F&uuml;r die L&ouml;sung dieser Aufgabe gibt es 3 Punkte, die auf die
Klausur angerechnet werden. Voraussetzung hierzu ist, da&szlig; die L&ouml;sung
mir  in der &Uuml;bung gezeigt und erkl&auml;rt werden
kann. 
In dieser Aufgabe sollen Sie eine Klasse f&uuml;r r&ouml;mische Zahlen entwickeln. 
            Schreiben Sie eine Klasse Roman. Diese Klasse soll 
eine nat&uuml;rliche Zahl
darstellen. 
            Schreiben Sie f&uuml;r Ihre Klasse Roman einen Konstruktor, der ein
Stringobjekt als Parameter hat. Dieser Stringparameter soll eine r&ouml;mische Zahl
darstellen. Der Konstruktor soll diese Zahl lesen und in einem Feld des 
Typs int abspeichern.
            Implementieren Sie die Methode public String toString() f&uuml;r
Ihre Klasse Roman, die die intern gespeicherte Zahl als r&ouml;mische Zahl
dargestellt zur&uuml;ckibt.
            F&uuml;gen Sie ihrer Klasse Roman die folgenden Methoden f&uuml;r
arithmetische Rechnungen hinzu.
                
                  Roman add(Roman other)
                
                
                  Roman sub(Roman other)
                
                
                  Roman mul(Roman other)
                
                
                  Roman div(Roman other)
                
              
            Testen Sie Ihre Klasse Roman.
          <h2>3.5. Reihungen</h2>In der
deutschen Literatur findet man oft den Ausdruck Datenfeld f&uuml;r
Reihungen. Wir haben uns gegen diesen Ausdruck entschieden, um nicht
mit Feldern einer Klasse durcheinander zu kommen.<h3>3.5.1. Deklaration von Reihungen</h3>Dies
wird sich mit den generischen Typen ab Java1.5  &auml;ndern.String []int []boolean []lengthint<pre>class ObjectArray {
  public static void main(String [] args){
    Object as = args;
    System.out.println(((String [])as).length);
  }
}</pre>
<h3>3.5.2. Erzeugen von Reihungen</h3>
<h4>3.5.2.1. Aufz&auml;hlung der Reihung</h4>
<pre>class FirstArray {

 static String [] komponisten
  = {"carcassi","carulli","giuliani"
    ,"molino","monzino","paganini","sor"};

  public static void main(String [] args){
    System.out.println(komponisten.length);
    System.out.println(komponisten.toString());
  }
}</pre>toString<h4>3.5.2.2. Uninitialisierte Reihungen</h4>
<pre>class SecondArray {

  static int [] zahlenReihung = new int[10];

  public static void main(String [] args){
    System.out.println(zahlenReihung);
  }
}</pre>
<h3>3.5.3. Zugriff auf Elemente</h3>0length-1<pre>String [] stra = {"hallo","welt"};
String str = stra[1];</pre>for<pre>public class ArrayToString{
  static public String arrayToString(String [] obja){
    StringBuffer result = new StringBuffer("{");
    for (int i=0;i&lt;obja.length;i=i+1){
      if (i&gt;0) result.append(",");
      result.append(obja[i].toString());
    }
    result.append("}");
    return result.toString();
  }
}</pre>
<h3>3.5.4. &Auml;ndern von Elementen</h3>
<pre>String [] stra = {"hello","world"};
stra[0]="hallo";
stra[1]="welt";</pre>
<h3>3.5.5. Das Kovarianzproblem</h3>ABB extends AB []A []Und daher in
generischen Klassen in Java1.5 nicht zul&auml;ssig, 
sprich List&lt;Object&gt; darf z.B.~ kein Objekt des 
Typs List&lt;String&gt; zugewiesen werden.<pre>class Kovarianz {

  static String [] stra = {"hallo","welt"};

  //gef&auml;hrliche Zuweisung  
  static Object [] obja = stra;

  public static void main(String [] args) {
    //dieses &auml;ndert auch stra. Laufzeitfehler!
    obja[0]=new Integer(42);     

    String str = stra[0];
    System.out.println(str);
  }
}</pre>obja = stra;straobjastraStringobjaobja[0]=new Integer(42);objaIntegersep@swe10:~/fh/beispiele&gt; java Kovarianz
Exception in thread "main" java.lang.ArrayStoreException
        at Kovarianz.main(Kovarianz.java:10)
straStringArrayStoreExceptionstra[0];Stringobja = stra;ArrayToString.arrayToStringPrimitive Typen sind dabei ausgenommen.<h3>3.5.6. Weitere Methoden f&uuml;r Reihungen</h3>java.utilArraysjava.lang.System<pre>public static void arraycopy(Object src,
                             int srcPos,
                             Object dest,
                             int destPos,
                             int length)</pre>
<h3>3.5.7. Reihungen von Reihungen</h3>Schachfigur<pre>class SchachFeld {
  Schachfigur [][] spielFeld
    =  {new Schachfigur[8]
       ,new Schachfigur[8]
       ,new Schachfigur[8]
       ,new Schachfigur[8]
       ,new Schachfigur[8]
       ,new Schachfigur[8]
       ,new Schachfigur[8]
       ,new Schachfigur[8]
       };

  public void zug(int vonX,int vonY,int nachX,int nachY){
    spielFeld[nachX][nachY] = spielFeld[vonX][vonY];
    spielFeld[vonX][vonY] = null;
  }
}
class Schachfigur {}</pre>
<h3>3.5.8. Iteration durch Reihungen</h3>
<pre>package name.panitz.crempel.util;

import java.util.Iterator;

public class FromTo implements Iterable&lt;Integer&gt;,Iterator&lt;Integer&gt;{
  private final int to; 
  private int from; 
  public FromTo(int f,int t){to=t;from=f;}
  public boolean hasNext(){return from&lt;=to;}
  public Integer next(){int result = from;from=from+1;return result;}
  public Iterator&lt;Integer&gt; iterator(){return this;}
  public void remove(){new UnsupportedOperationException();}
}</pre>
<h3>3.5.9. Blubbersortierung</h3>bubble sortBlubbersortierungbubble sort("z","b","c","a")bubble sort 1. Bubble-Durchlauf("z","b","c","a")("b","z","c","a")("b","c","z","a")("b","c","a","z")"z" 2. Bubble-Durchlauf("b","c","a","z")("b","a","c","z")"c" 3. Bubble-Durchlauf("b","a","c","z")("a","b","c","z")"b"<pre>class BubbleSort {
  static void bubbleSort(Comparable [] obja){
    boolean toBubble = true;
    while (toBubble){ toBubble = bubble(obja);}
  }

  static boolean bubble(Comparable [] obja){
    boolean result = false;
    for (int i=0;i&lt;obja.length;i=i+1){
      try {
        if (obja[i].compareTo(obja[i+1])&gt;0){
          Comparable o = obja[i];
          obja[i]=obja[i+1];
          obja[i+1]=o;
          result=true;
        }
      }catch (ArrayIndexOutOfBoundsException _){}
    }
    return result;
  }  

  static public void main(String [] args){
    String [] stra = {"a","zs","za","bb","aa","aa","y"};
    System.out.println(ArrayToString.arrayToString(stra));
    bubbleSort(stra);
    System.out.println(ArrayToString.arrayToString(stra));
  }

}</pre>quicksort(3 Punkte) In dieser Aufgabe soll ein Spielbrett f&uuml;r das Spiel Vier gewinnt
implementiert werden. Laden Sie hierzu die 
Dateivier.zip
          Schreiben Sie eine Klasse VierImplementierung, die die
Schnittstelle VierLogik entsprechend der Dokumentation 
implementiert.
          Schreiben Sie folgende Hauptmethode und starten Sie diese. Sie sollten jetzt in der Lage sein, &uuml;ber die Eingabekonsole Vier
gewinnt zu spielen.<pre>public static void main(String[] args) {
  new VierKonsole().spiel(new VierImplementierung());
}</pre> Suchen Sie sich einen Spielpartner und versuchen Sie, gegen ihn zu gewinnen.
        <h2>3.6. Aufz&auml;hlungstypen</h2>intclassenum
Ein erster Aufz&auml;hlungstyp f&uuml;r die Wochentage. <pre>package name.panitz.enums;
public enum Wochentage {
  montag,dienstag,mittwoch,donnerstag
 ,freitag,sonnabend,sonntag;
}</pre>

Auch dieses neue Konstrukt wird von Java&uuml;bersetzer in eine herk&ouml;mmlige
Javaklasse &uuml;bersetzt. Wir k&ouml;nnen uns davon &uuml;berzeugen, indem wir uns einmal
den Inhalt der erzeugten Klassendatei mit javap wieder anzeigen
lassen: sep@linux:fh/&gt; javap name.panitz.enums.Wochentage
Compiled from "Wochentage.java"
public class name.panitz.enums.Wochentage extends java.lang.Enum{
    public static final name.panitz.enums.Wochentage montag;
    public static final name.panitz.enums.Wochentage dienstag;
    public static final name.panitz.enums.Wochentage mittwoch;
    public static final name.panitz.enums.Wochentage donnerstag;
    public static final name.panitz.enums.Wochentage freitag;
    public static final name.panitz.enums.Wochentage sonnabend;
    public static final name.panitz.enums.Wochentage sonntag;
    public static final name.panitz.enums.Wochentage[] values();
    public static name.panitz.enums.Wochentage valueOf(java.lang.String);
    public name.panitz.enums.Wochentage(java.lang.String, int);
    public int compareTo(java.lang.Enum);
    public int compareTo(java.lang.Object);
    static {};
}switch
Wir f&uuml;gen der Aufz&auml;hlungsklasse eine Methode zu, um zu testen ob der Tag ein
Werktag ist. Hierbei l&auml;&szlig;t sich eine switch-Anweisung benutzen.<pre>package name.panitz.enums;
public enum Tage {
  montag,dienstag,mittwoch,donnerstag
 ,freitag,sonnabend,sonntag;

  public boolean isWerktag(){
    switch (this){
      case sonntag    :
      case sonnabend  :return false;
      default         :return true;
    }
  }

  public static void main(String [] _){
    Tage tag = freitag;
    System.out.println(tag);
    System.out.println(tag.ordinal());
    System.out.println(tag.isWerktag());
    System.out.println(sonntag.isWerktag());
  }
}</pre>
Das Programm gibt die erwartete Ausgabe:sep@linux:~/fh/java1.5/examples&gt; java -classpath classes/ name.panitz.enums.Tage
freitag
4
true
false
sep@linux:~/fh/java1.5/examples&gt;for
Wir iterieren in diesem Beispiel einmal &uuml;ber alle Wochentage. <pre>package name.panitz.enums;
public class IterTage {
  public static void main(String [] _){
    for (Tage tag:Tage.values()) 
      System.out.println(tag.ordinal()+": "+tag);
  }
}</pre>
Die erwarttete Ausgabe ist:sep@linux:~/fh/java1.5/examples&gt; java -classpath classes/ name.panitz.enums.IterTage
0: montag
1: dienstag
2: mittwoch
3: donnerstag
4: freitag
5: sonnabend
6: sonntag
sep@linux:~/fh/java1.5/examples&gt;Wir schreiben eine Aufz&auml;hlung f&uuml;r die Euroscheine. Jeder
Scheinkonstante wird noch eine ganze Zahl mit &uuml;bergeben. Es mu&szlig; hierf&uuml;r ein
allgemeiner Konstruktor geschrieben werden, der diesen Parameter &uuml;bergeben
bekommt. <pre>package name.panitz.enums;
public enum Euroschein {
   f&uuml;nf(5),zehn(10),zwanzig(20),f&uuml;nfzig(50),hundert(100)
  ,zweihundert(200),tausend(1000);
  private int value;
  Euroschein(int v){value=v;}
  public int value(){return value();}

  public static void main(String [] _){
    for (Euroschein schein:Euroschein.values()) 
      System.out.println
        (schein.ordinal()+": "+schein+" -&gt; "+schein.value);
  }
}</pre>
Das Programm hat die folgende Ausgabe:sep@linux:~/fh/java1.5/examples&gt; java -classpath classes/ name.panitz.enums.Euroschein
0: f&uuml;nf -&gt; 5
1: zehn -&gt; 10
2: zwanzig -&gt; 20
3: f&uuml;nfzig -&gt; 50
4: hundert -&gt; 100
5: zweihundert -&gt; 200
6: tausend -&gt; 1000
sep@linux:~/fh/java1.5/examples&gt;<h1>4. Weiterf&uuml;hrende Konzepte</h1>
<h2>4.1. Pakete</h2>
<h3>4.1.1. Paketdeklaration</h3>packagetestPackage<pre>package testPackage;
class MyClass {
}</pre>testPackagespanitzname<pre>package name.panitz.testPackages;
class TestPaket {
  public static void main(String [] args){
    System.out.println("hello from package \'testpackages\'");
  }
}</pre>Leider ist es in Deutschland weit verbreitet, einen
Bindestrich in Webadressen zu verwenden. Der Bindestrich ist leider eines der wenigen Zeichen, die Java in Klassen- und Paketnamen nicht
zul&auml;&szlig;t.Testname.panitz.testPackagesvollqualifizierte Namename.panitz.testPackages.Test<h3>4.1.2. &Uuml;bersetzen von Paketen</h3>javajavaTesttestPackagespanitztfhberlinjavaCLASSPATH-classpathjavacjavac.class-d-d-ddestinationjavac -d . Test.javaDer Punkt steht in den
meisten Betriebssystemen f&uuml;r den aktuellen Ordner, in dem gerade ein Befehl
ausgef&uuml;hrt wird.detfhberlin<h3>4.1.3. Starten von Klassen in Paketen</h3>sep@swe10:~/&gt; java name.panitz.testPackages.Test
hello from package 'testpackages'
sep@swe10:~/&gt;.class'enth&auml;lt ein'name.panitz.testPackages.Test.main(args)detfhberlinpanitztestpackagesTestmain<h3>4.1.4. Das Java Standardpaket</h3>StringSystemObjectjava.langjava.utiljava.appletjava.io<h3>4.1.5. Benutzung von Klassen in anderen Paketen</h3>ArrayListArrayList ist eine
generische Klasse, ein Konzept, das wir erst in einem sp&auml;teren Kapitel
kennenlernen werden.java.util<pre>package name.panitz.utilTest;
class TestArrayList {
  public static void main(String [] args){
    java.util.ArrayList&lt;String&gt; xs = new java.util.ArrayList&lt;String&gt;();
    xs.add("friends");
    xs.add("romans");
    xs.add("countrymen");
    System.out.println(xs);
  }
}</pre>
<h3>4.1.6. Importieren von Paketen und Klassen</h3>
<h4>4.1.6.1. Importieren von Klassen</h4>java.langArrayListAus historischen Gr&uuml;nden
wird in diesem Kapitel als Beispiel bereits mit den  generischen 
Klassen ArrayList und Vector ein Konzept benutzt, das
erst im n&auml;chsten Kapitel erkl&auml;rt wird.<pre>package name.panitz.utilTest;

import java.util.ArrayList;

class TestImport {
  public static void main(String [] args){
    ArrayList&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add("friends");
    xs.add("romans");
    xs.add("countrymen");
    System.out.println(xs);
  }
}</pre>Vector<pre>package name.panitz.utilTest;

import java.util.ArrayList;
import java.util.Vector;

class TestImport2 {
  public static void main(String [] args){
    ArrayList&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add("friends");
    xs.add("romans");
    xs.add("countrymen");
    System.out.println(xs);

    Vector&lt;String&gt; ys = new Vector&lt;String&gt;();
    ys.add("friends");
    ys.add("romans");
    ys.add("countrymen");
    System.out.println(ys);
  }
}</pre>
<h4>4.1.6.2. Importieren von Paketen</h4>*<pre>package name.panitz.utilTest;

import java.util.*;

class TestImport3 {
  public static void main(String [] args){
    List&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add("friends");
    System.out.println(xs);

    Vector&lt;String&gt; ys = new Vector&lt;String&gt;();
    ys.add("romans");
    System.out.println(ys);
  }
}</pre>
<h3>4.1.7. Statische Imports</h3>importstaticWir schreiben eine Hilfsklasse zum Arbeiten mit Strings, in der wir
eine Methode zum umdrehen eines Strings vorsehen:<pre>package name.panitz.staticImport;
public class StringUtil {
  static public String reverse(String arg) {
    StringBuffer result = new StringBuffer();
    for (char c:arg.toCharArray()) result.insert(0,c);
    return result.toString();
  }
}</pre>
Die Methode reverse wollen wir in einer anderen Klasse
benutzen. Importieren wir  die statischen Eigenschaften 
von StringUtil, so k&ouml;nnen wir auf die Qualifizierung des Namens der
Methode reverse verzichten:<pre>package name.panitz.staticImport;
import static name.panitz.staticImport.StringUtil.*;
public class UseStringUtil {
  static public void main(String [] args) {
    for (String arg:args) 
     System.out.println(reverse(arg));
  }
}</pre>

Die Ausgabe dieses programms:sep@linux:fh&gt; java -classpath classes/ name.panitz.staticImport.UseStringUtil hallo welt
ollah
tlew
sep@linux:~/fh/java1.5/examples&gt;<h2>4.2. Sichtbarkeitsattribute</h2>Man findet in der Literatur auch den AusdruckErreichbarkeiten.wer<h3>4.2.1. Sichtbarkeitsattribute f&uuml;r Klassen</h3>public<pre>package name.panitz.p1;
public class MyPublicClass {
}</pre>
<pre>package name.panitz.p1;
class MyNonPublicClass {
}</pre>
<pre>package name.panitz.p2;

import name.panitz.p1.*;

class UsePublic {
  public static void main(String [] args){
    System.out.println(new MyPublicClass());
  }
}</pre>
<pre>package name.panitz.p2;

import name.panitz.p1.*;

class UseNonPublic {
  public static void main(String [] args){
    System.out.println(new MyNonPublicClass());
  }
}</pre>sep@swe10:~&gt; javac -d . UseNonPublic.java
UseNonPublic.java:7: name.panitz.p1.MyNonPublicClass is not
public in name.panitz.pantitz.p1; 
cannot be accessed from outside package
        System.out.println(new MyNonPublicClass());
                               ^
UseNonPublic.java:7: MyNonPublicClass() is not 
public in name.panitz.p1.MyNonPublicClass; 
cannot be accessed from outside package
        System.out.println(new MyNonPublicClass());
                           ^
2 errors
sep@swe10:~&gt;<h3>4.2.2. Sichtbarkeitsattribute f&uuml;r Eigenschaften</h3>publicprotectedprivate
          
              Attribut
              Sichtbarkeit
             
              
                public
              
              Die Eigenschaft darf von jeder Klasse aus
benutzt werden. 
            
              
                protected
              
               Die Eigenschaft darf f&uuml;r jede Unterklasse und jede Klasse im gleichen Paket 
benutzt werden. 
            
              kein Attribut
              Die Eigenschaft darf nur von  Klassen im gleichen Paket benutzt werden. 
            
              
                private
              
              Die Eigenschaft darf nur von  der Klasse, in der sie definiert ist, benutzt werden.
            
        p1<pre>package name.panitz.p1;

public class VisibilityOfFeatures{
  private   String s1 = "private";
            String s2 = "package";
  protected String s3 = "protected";
  public    String s4 = "private";

  public static void main(String [] args){
    VisibilityOfFeatures v = new VisibilityOfFeatures();
    System.out.println(v.s1);
    System.out.println(v.s2);
    System.out.println(v.s3);
    System.out.println(v.s4);
  }
}</pre>
<pre>package name.panitz.p1;

public class PrivateTest 
{

  public static void main(String [] args){
    VisibilityOfFeatures v = new VisibilityOfFeatures();
    //s1 is private and cannot be accessed; 
    //we are in a  different class.
    //System.out.println(v.s1);
    System.out.println(v.s2);
    System.out.println(v.s3);
    System.out.println(v.s4);
  }
}</pre>gesch&uuml;tztenpackage<pre>package name.panitz.p2;
import name.panitz.p1.VisibilityOfFeatures;

public class  PackageTest extends VisibilityOfFeatures{

  public static void main(String [] args){
    PackageTest v = new PackageTest();
    //s1 is private and cannot be accessed
    // System.out.println(v.s1);

    //s2 is package visible and cannot be accessed;
    //we are in a different package.
    //System.out.println(v.s2);

    System.out.println(v.s3);
    System.out.println(v.s4);
  }
}</pre>
<pre>package name.panitz.p2;
import name.panitz.p1.VisibilityOfFeatures;

public class ProtectedTest  {

  public static void main(String [] args){
    VisibilityOfFeatures v = new VisibilityOfFeatures();
    //s1 is private and cannot be accessed
    // System.out.println(v.s1);
    
    //s2 is package visible and cannot be accessed. We are
    //in a different package
    //System.out.println(v.s2);

    //s2 is protected and cannot be accessed. 
    //We are not a subclass
    //System.out.println(v.s3);

    System.out.println(v.s4);
  }
}</pre>
<h3>4.2.3. Private Felder mit get- und set-Methoden</h3>privatenamegetNamesetNameEine kleine Klasse mit Kapselung eines privaten Feldes:<pre>package name.panitz.sep.skript;

public class GetSetMethod {
  private int value=0;

  public void setValue(int newValue) {value=newValue;}
  public int  getvalue(){return value;} 
}</pre>
<h3>4.2.4. &Uuml;berschriebene Methodensichtbarkeiten</h3>
<pre>class OverrideToString {
  String toString(){return "Objekt der Klasse OverrideToString";}
}</pre>ep@linux:~/fh/prog1/examples/src&gt; javac OverrideToString.java
OverrideToString.java:2: 
toString() in OverrideToString cannot override toString() in java.lang.Object; 
attempting to assign weaker access privileges; 
was public
  String toString(){return "Objekt der Klasse OverrideToString";}
         ^
1 error
sep@linux:~/fh/prog1/examples/src&gt;ObjecttoString<h2>4.3. Schnittstellen (Interfaces) und abstrakte Klassen</h2>ButtonLogic<h3>4.3.1. Schnittstellen</h3>
<h4>4.3.1.1. Schnittstellendeklaration</h4>
            statt des Schl&uuml;sselworts class steht das 
Schl&uuml;sselwort interface.
            die Methoden haben keine R&uuml;mpfe, sondern nur eine Signatur.
          ButtonLogic<pre>package name.panitz.dialoguegui;

public interface DialogueLogic {
  public String getDescription();
  public String eval(String input);
}</pre>.class<h4>4.3.1.2. Implementierung von Schnittstellen</h4>extendsimplementsimplements vs extends erkl&auml;rem<pre>package name.panitz.dialoguegui;

public class ToUpperCase implements DialogueLogic{
  protected String result;

  public String getDescription(){
    return "convert into upper cases";
  }
  public String eval(String input){
    result = input.toUpperCase();
    return result;
  }
}</pre>implements DialogueLogicevalgetDescription()extendsimplements<pre>package name.panitz.html;

public interface ToHTMLString {
  public String toHTMLString();
}</pre>
<pre>package name.panitz.dialoguegui;

import name.panitz.html.*;

public class ToUpper extends    ToUpperCase 
                     implements ToHTMLString, DialogueLogic {

  public String toHTMLString(){
     return   "&lt;html&gt;&lt;head&gt;&lt;title&gt;"+getDescription()
            + "&lt;/title&gt;&lt;/head&gt;"
            + "&lt;body&gt;&lt;b&gt;Small Gui application&lt;/b&gt;"
            + " for convertion of "
            + " a &lt;b&gt;String&lt;/b&gt; into &lt;em&gt;upper&lt;/em&gt;"
            + " case letters.&lt;br&gt;&lt;/br&gt;"
            + "The result of your query was: &lt;p&gt;"
            + "&lt;span style=\"font-family: monospace;\"&gt;"
            + result
            + "&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;";
  }
}</pre>extends<pre>package name.panitz.dialoguegui;

import name.panitz.html.*;

public interface DialogueLogics 
        extends ToHTMLString, DialogueLogic {}</pre>
<pre>package name.panitz.dialoguegui;

class UpperConversion extends ToUpper
                      implements DialogueLogics{}</pre>
<h4>4.3.1.3. Benutzung von Schnittstellen</h4>
            primitive Typen
            Klassen
            Schnittstellen
          CICIDialogueLogicsnew<pre>package name.panitz.dialoguegui;
import java.awt.event.*;
import java.awt.*;
import javax.swing.*;
import javax.swing.plaf.basic.*; 
import javax.swing.text.*; 
import javax.swing.text.html.*; 

public class HtmlDialogue extends JFrame{
  final DialogueLogics logic; 
  final JButton button;
  final JTextField inputField = new JTextField(20) ;
  final JTextPane outputField = new JTextPane();
  final JPanel p = new JPanel();

  public HtmlDialogue(DialogueLogics l){
    outputField.setEditorKit(new HTMLEditorKit());
    logic = l;
    button=new JButton(logic.getDescription());
    button.addActionListener
     (new ActionListener(){
        public void actionPerformed(ActionEvent _){
          logic.eval(inputField.getText().trim());
          outputField.setText(logic.toHTMLString());
          pack();
        }
      });

    p.setLayout(new BorderLayout());
    p.add(inputField,BorderLayout.NORTH);
    p.add(button,BorderLayout.CENTER);
    p.add(outputField,BorderLayout.SOUTH);
    getContentPane().add(p);
    pack();
    setVisible(true);
  }
}</pre>UpperConversionDialogueLogics<pre>package name.panitz.dialoguegui;
public class HtmlDialogueTest {
  public static void main(String [] args){
    new HtmlDialogue(new UpperConversion());
  }
}</pre>
<h4>4.3.1.4. Semantische Einschr&auml;nkungen f&uuml;r Schnittstellen</h4>Schnittstellen k&ouml;nnen nur Schnittstellen, nicht 
aber Klassen erweitern.Jede Methode einer Schnittstelle mu&szlig; &ouml;ffentlich sein, braucht also das
Attribut public. Wenn dieses f&uuml;r eine Methode nicht
deklariert ist, so wird Java dieses von selbst hinzuf&uuml;gen. Trotzdem m&uuml;ssen implementierende Klassen diese Methode dann als &ouml;ffentlich deklarieren. Daher ist es besser, das Attribut public auch
hinzuschreiben.Es gibt keine statischen Methoden in Schnittstellen. Jede Methode ist abstrakt, d.h.hat keinen 
Rumpf. Man kann dieses noch
zus&auml;tzlich deutlich machen, indem man das 
Attribut abstract f&uuml;r die Methode mit angibt. Felder einer Schnittstelle sind immer statisch, brauchen also das Attribut static und  zus&auml;tzlich
noch das Attribut final.<h4>4.3.1.5. Iteratorschnittstellen</h4>foreiner Methode next, die jeweils das n&auml;chste Element der Iteration zur&uuml;ckgibt. einer Methode hasNext, die in einem bool'schen R&uuml;ckgabewert
angibt, ob es weitere Elemente gibt, die &uuml;ber next erfragt werden
k&ouml;nnten. Und das wird auch
tats&auml;chlich in Javas Standardklassen so gemacht.int<pre>package name.panitz.iterator;
public interface IntIterator{
  public int next();
  public boolean hasNext();
}</pre>hasNext()false<pre>package name.panitz.iterator;
public class PrintIntIteratorElements{ 
  static void print(IntIterator it){
    while (it.hasNext()) System.out.print(it.next()+" ");
  }
}</pre>int<pre>package name.panitz.iterator;
public class FromToStep implements IntIterator{
  private int from; 
  private int to; 
  private int step; 

  public FromToStep(int from,int to,int step){
    this.from=from;this.to=to;this.step=step;}

  public boolean hasNext(){return from&lt;=to;}
  public int next(){
    int result = from;
    from=from+step;
    return result;
  }
}</pre>1<pre>package name.panitz.iterator;
public class FromTo extends FromToStep{
  public FromTo(int from,int to){super(from,to,1);}
}</pre>print<pre>package name.panitz.iterator;
public class TestFromTo {
  public static void main(String []_){
    PrintIntIteratorElements.print(new FromTo(17,42));
  }
}</pre>sep@linux:~/fh/prog1/examples/src&gt; java name.panitz.iterator.TestFromTo
17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 
sep@linux:~/fh/prog1/examples/src&gt;In dieser Aufgabe sollen Sie ein Programm schreiben, das nach und
nach die Primzahlen ausgibt. 
              Schreiben sie eine Unterklasse From der 
Klasse FromTo, die von einem Startwert an in Einerschritten 
ganze Zahlen zur&uuml;ckgibt und f&uuml;r die hasNext immer wahr ist.
              Schreiben Sie eine Klasse Sieb, die die 
Schnittstelle IntIterator implementiert. Die Klasse soll zwei Felder haben: eine ganze Zahl und ein weiteres Objekt, das die 
Schnittstelle IntIterator implementiert. Der Konstruktor habe die
Signatur:public Sieb(int i,IntIterator it)
Die Methode next soll das n&auml;chste Element des inneren 
Iterators it zur&uuml;ckgeben, das nicht durch die 
Zahl i teilbar ist.
Beispiel: PrintIntIteratorElements.print(new Sieb(3,new From(1))) gibt alle nicht
durch 3 teilbaren nat&uuml;rlichen Zahlen auf dem Bildschirm aus.
              &Uuml;bersetzen Sie ihren Code mit folgender Klasse:<pre>package name.panitz.iterator;
class PrimIterator implements IntIterator{
  private IntIterator sieb = new From(2);
  public boolean hasNext(){return sieb.hasNext();}
  public int next(){
    int result = sieb.next();
    sieb= new Sieb(result,sieb);
    return result;
  }
}</pre>
Lassen Sie sich alle Werte von PrimIterator mit der 
Methode PrintIntIteratorElements.print ausgeben. 
            <h3>4.3.2. Abstrakte Klassen</h3>
<h4>4.3.2.1. Definition abstrakter Klassen</h4>classabstractabstract<h4>4.3.2.2. Abstrakte Klassen und Schnittstellen</h4>
<h2>4.4. Ausnahme- und Fehlerbehandlung</h2>
<h3>4.4.1. Ausnahme- und Fehlerklassen</h3>java.lang.Throwable
          java.lang.Error: alle Objekte dieser Klasse dr&uuml;cken
aus, da&szlig; ein ernsthafter Fehlerfall aufgetreten ist, der in der Regel
von dem Programm selbst nicht zu beheben ist.
          java.lang.Exception: alle Objekte dieser Klasse stellen
Ausnahmesituationen dar. Im Programm kann eventuell beschrieben sein,
wie bei einer solchen Ausnahmesituation weiter zu verfahren ist.
Eine Unterklasse von Exception ist die 
Klasse java.lang.RuntimeException.
        <h3>4.4.2. Werfen von Ausnahmen</h3>ThrowablethrowthrowThrowablethrow<pre>package name.panitz.exceptions;
public class FirstThrow {

  public static int fakult&auml;t(int n){
    if (n==0) return 1;
    if (n&lt;0) throw new RuntimeException();
    return n*fakult&auml;t(n-1);
  }

  public static void main(String [] args){
    System.out.println(fakult&auml;t(5));
    System.out.println(fakult&auml;t(-3));
    System.out.println(fakult&auml;t(4));
  }
}</pre>swe10:~&gt; java name.panitz.exceptions.FirstThrow
120
Exception in thread "main" java.lang.RuntimeException
  at name.panitz.exceptions.FirstThrow.fakult&auml;t(FirstThrow.java:6)
  at name.panitz.exceptions.FirstThrow.main(FirstThrow.java:12)
swe10:~&gt;RuntimeExceptionfakult&auml;tFirstThrowstack tracethrow<pre>package name.panitz.exceptions;
public class NonThrow {

  public static int fakult&auml;t(int n){
    if (n==0) return 1;
    if (n&lt;0) new RuntimeException();
    return n*fakult&auml;t(n-1);
  }

  public static void main(String [] args){
    System.out.println(fakult&auml;t(5));
    System.out.println(fakult&auml;t(-3));
    System.out.println(fakult&auml;t(4));
  }
}</pre>swe10:~&gt; java name.panitz.exceptions.NonThrow
120

An irrecoverable stack overflow has occurred.
throwThrowable<pre>package name.panitz.exceptions;
public class NotThrowable {

  public static void main(String [] args){
      throw "i am not throwable";
  }
}</pre>swe10:~&gt; javac -d . NotThrowable.java
NotThrowable.java:5: incompatible types
found   : java.lang.String
required: java.lang.Throwable
      throw "i am not throwable";
            ^
1 error
swe10:~&gt;charAtString<pre>package name.panitz.exceptions;
public class ThrowIndex {

  public static void main(String [] args){
      "i am too short".charAt(120);
  }
}</pre>swe10:~&gt; java name.panitz.exceptions.ThrowIndex
Exception in thread "main" java.lang.StringIndexOutOfBoundsException: 
                                    String index out of range: 120
  at java.lang.String.charAt(String.java:516)
  at name.panitz.exceptions.ThrowIndex.main(ThrowIndex.java:5)
swe10:~&gt;
java.lang.StringIndexOutOfBoundsException:Throwable<pre>package name.panitz.exceptions;

public class SecondThrow {
  public static int fakult&auml;t(int n){
    if (n==0) return 1;
    if (n&lt;0) 
     throw
      new RuntimeException
           ("negative Zahl f&uuml;r Fakult&auml;tsberechnung");
    return n*fakult&auml;t(n-1);
  }

  public static void main(String [] args){
    System.out.println(fakult&auml;t(5));
    System.out.println(fakult&auml;t(-3));
    System.out.println(fakult&auml;t(4));
  }
}</pre>swe10:~&gt; java name.panitz.exceptions.SecondThrow
120
Exception in thread "main" java.lang.RuntimeException: 
                                    negative Zahl f&uuml;r Fakult&auml;tsberechnung
  at name.panitz.exceptions.SecondThrow.fakult&auml;t(SecondThrow.java:6)
  at name.panitz.exceptions.SecondThrow.main(SecondThrow.java:12)
swe10:~&gt;<h3>4.4.3. Deklaration von geworfenen  Ausnahmen</h3>RuntimeExceptionRuntimeException<pre>package name.panitz.exceptions;
public class ThirdThrow {

  public static int fakult&auml;t(int n){
    if (n==0) return 1;
    if (n&lt;0) throw new Exception
             ("negative Zahl f&uuml;r Fakult&auml;tsberechnung");
    return n*fakult&auml;t(n-1);
  }

  public static void main(String [] args){
    System.out.println(fakult&auml;t(5));
    System.out.println(fakult&auml;t(-3));
    System.out.println(fakult&auml;t(4));
  }
}</pre>swe10:~&gt; javac -d . ThirdThrow.java
ThirdThrow.java:6: unreported exception java.lang.Exception; 
                                      must be caught or declared to be thrown
    if (n&lt;0) throw new Exception("negative Zahl f&uuml;r Fakult&auml;tsberechnung");
             ^
1 error
fakult&auml;tthrowsthrowsExceptionmainfakult&auml;t<pre>package name.panitz.exceptions;
public class FourthThrow {

  public static int fakult&auml;t(int n) throws Exception{
    if (n==0) return 1;
    if (n&lt;0) 
     throw 
      new Exception("negative Zahl f&uuml;r Fakult&auml;tsberechnung");
    return n*fakult&auml;t(n-1);
  }

  public static void main(String [] args) throws Exception{
    System.out.println(fakult&auml;t(5));
    System.out.println(fakult&auml;t(-3));
    System.out.println(fakult&auml;t(4));
  }
}</pre>
<h3>4.4.4. Eigene Ausnahmeklassen</h3>Exception<pre>package name.panitz.exceptions;
public class NegativeNumberException extends Exception {
}</pre>
<pre>package name.panitz.exceptions;
public class FifthThrow {

  public static int fakult&auml;t(int n) throws Exception{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    return n*fakult&auml;t(n-1);
  }

  public static void main(String [] args) throws Exception{
    System.out.println(fakult&auml;t(5));
    System.out.println(fakult&auml;t(-3));
    System.out.println(fakult&auml;t(4));
  }
}</pre>sep@swe10:~/fh/beispiele&gt; java name.panitz.exceptions.FifthThrow
120
Exception in thread "main" name.panitz.exceptions.NegativeNumberException
        at name.panitz.exceptions.FifthThrow.fakult&auml;t(FifthThrow.java:6)
        at name.panitz.exceptions.FifthThrow.main(FifthThrow.java:12)
sep@swe10:~/fh/beispiele&gt;
<h3>4.4.5. Fangen von Ausnahmen</h3>
<h4>4.4.5.1. Syntax</h4>trycatch
            
              try 
              stats
               catch (
              ExceptionName
              
              ident
               )
              stats
              
                
              
            
          trycatch<pre>package name.panitz.exceptions;
public class Catch1 {

  public static int fakult&auml;t(int n) throws Exception{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    return n*fakult&auml;t(n-1);
  }

  public static void main(String [] args){
    try {
      System.out.println(fakult&auml;t(5));
      System.out.println(fakult&auml;t(-3));
      System.out.println(fakult&auml;t(4));
    }catch (Exception e){
      System.out.println("Ausnahme aufgetreten: "+e);
    }
  }
}</pre>mainswe10:~&gt; java name.panitz.exceptions.Catch1
120
Ausnahme aufgetreten: name.panitz.exceptions.NegativeNumberException
swe10:~&gt;
catchcatchcatch<h4>4.4.5.2. Granularit&auml;t des Abfangens</h4>fakult&auml;t<pre>package name.panitz.exceptions;
public class Catch2 {

  public static int fakult&auml;t(int n) throws Exception{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    return n*fakult&auml;t(n-1);
  }

  public static void main(String [] args){
    try {
      System.out.println(fakult&auml;t(5));
    }catch (Exception _){
      System.out.println("Ausnahme f&uuml;r Fakult&auml;t von 5");
    } 
    try {
      System.out.println(fakult&auml;t(-3));
    }catch (Exception _){
      System.out.println("Ausnahme f&uuml;r Fakult&auml;t von -3");
    } 
    try {
      System.out.println(fakult&auml;t(4));
    }catch (Exception _){
      System.out.println("Ausnahme f&uuml;r Fakult&auml;t von 4");
    } 
  }
}</pre>Eine Konvention, die ich in funktionalen
  Programmiersprachen kennengelernt habe, benutzt f&uuml;r
    nichtgebrauchte Variablen den Unterstrich als Bezeichner. Da mich
     in den einzelnen {\tt catch}-Klauseln das Ausnahmeobjekt nicht
    interessiert, benutze ich jeweils den Unterstrich als
Bezeichner  daf&uuml;r.swe10:~/fh/beispiele&gt; java name.panitz.exceptions.Catch2
120
Ausnahme f&uuml;r Fakult&auml;t von -3
24
swe10:~/fh/beispiele&gt;<h4>4.4.5.3. Abfangen spezifischer Ausnahmen</h4>catchExceptionthrowsfakult&auml;tExceptionException<pre>package name.panitz.exceptions;
public class Catch3 {

  public static int fakult&auml;t(int n) 
                        throws NegativeNumberException{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    return n*fakult&auml;t(n-1);
  }

  public static void main(String [] args){
    try {
      System.out.println(fakult&auml;t(5));
      System.out.println(fakult&auml;t(-3));
      System.out.println(fakult&auml;t(4));
    }catch (NegativeNumberException e){
      System.out.println("Ausnahme aufgetreten: "+e);
    } 
  }
}</pre>
<h4>4.4.5.4. Abfangen mehrerer Ausnahmen</h4>catch<pre>package name.panitz.exceptions;
public class NumberTooLargeException extends Exception {
}</pre>
<pre>package name.panitz.exceptions;
public class Catch4 {

  public static int fakult&auml;t(int n) 
        throws NegativeNumberException, NumberTooLargeException{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    if (n&gt;20) throw new NumberTooLargeException();
    return n*fakult&auml;t(n-1);
  }

  public static void printFakult&auml;t(int i){
    try {
      System.out.println(fakult&auml;t(i));
    }catch (NegativeNumberException _){
      System.out.println("Fakult&auml;t von negativer Zahl");
    } 
    catch (NumberTooLargeException _){
      System.out.println("Fakult&auml;t von zu gro&szlig;er Zahl");
    } 
  }

  public static void main(String [] args){
    printFakult&auml;t(30);
    printFakult&auml;t(-3);
    printFakult&auml;t(4);
  }
}
</pre>swe10:~/fh/beispiele&gt; java name.panitz.exceptions.Catch4
Fakult&auml;t von zu gro&szlig;er Zahl
Fakult&auml;t von negativer Zahl
24
swe10:~/fh/beispiele&gt;
<h4>4.4.5.5. Zusammenspiel mit R&uuml;ckgabewerten</h4>
<pre>package name.panitz.exceptions;
public class WrongCatch {

  public static int fakult&auml;t(int n) 
        throws NegativeNumberException, NumberTooLargeException{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    if (n&gt;20) throw new NumberTooLargeException();
    return n*fakult&auml;t(n-1);
  }

  public static int checkFakult&auml;t(int i){
    try {
      return fakult&auml;t(i);
    }catch (Exception e){
      System.out.println("Ausnahme "+e+" aufgetreten");
    } 
  }

  public static void main(String [] args){
    System.out.println(checkFakult&auml;t(30));
    System.out.println(checkFakult&auml;t(-3));
    System.out.println(checkFakult&auml;t(4));
  }
}</pre>sep@swe10:~/fh/beispiele&gt; javac -d . WrongCatch.java
WrongCatch.java:12: missing return statement
  public static int checkFakult&auml;t(int i){
                                        ^
1 error
sep@swe10:~/fh/beispiele&gt;
trytryreturnreturncatch<pre>package name.panitz.exceptions;
public class Catch5 {

  public static int fakult&auml;t(int n) 
        throws NegativeNumberException, NumberTooLargeException{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    if (n&gt;20) throw new NumberTooLargeException();
    return n*fakult&auml;t(n-1);
  }

  public static int checkFakult&auml;t(int i){
    try {
      return fakult&auml;t(i);
    }catch (Exception e){
      System.out.println("Ausnahme "+e+" aufgetreten");
      return 0;
    } 
  }

  public static void main(String [] args){
    System.out.println(checkFakult&auml;t(30));
    System.out.println(checkFakult&auml;t(-3));
    System.out.println(checkFakult&auml;t(4));
  }
}
</pre>[sep@swe10:~/fh/beispiele&gt; java name.panitz.exceptions.Catch5
Ausnahme name.panitz.exceptions.NumberTooLargeException aufgetreten
0
Ausnahme name.panitz.exceptions.NegativeNumberException aufgetreten
0
24
sep@swe10:~/fh/beispiele&gt;
<h3>4.4.6. Der Aufrufkeller</h3>printStackTraceprintStackTrace<pre>package name.panitz.exceptions;
public class StackTrace {

    public static int fakult&auml;t(int n) {
    if (n==0) {
	new Exception().printStackTrace();
      return 1;
    }
    return n*fakult&auml;t(n-1);
  }

  public static void main(String [] args){
    System.out.println(fakult&auml;t(4));
  }
}
</pre>sep@swe10:~/fh/beispiele&gt; java name.panitz.exceptions.StackTrace
java.lang.Exception
        at name.panitz.exceptions.StackTrace.fakult&auml;t(StackTrace.java:6)
        at name.panitz.exceptions.StackTrace.fakult&auml;t(StackTrace.java:9)
        at name.panitz.exceptions.StackTrace.fakult&auml;t(StackTrace.java:9)
        at name.panitz.exceptions.StackTrace.fakult&auml;t(StackTrace.java:9)
        at name.panitz.exceptions.StackTrace.fakult&auml;t(StackTrace.java:9)
        at name.panitz.exceptions.StackTrace.main(StackTrace.java:13)
24
sep@swe10:~/fh/beispiele&gt;
<h3>4.4.7. Schlie&szlig;lich und finally</h3>trycatchfinallyfinallyfinallyfinally<pre>class Finally {
 
  static void m(int i) throws Exception{
    if (i&gt;0) throw new Exception();
  }

  public static void main(String [] args){
    try {m(1);}
    catch (Exception _){System.out.println("Ausnahme gefangen");}
    finally {System.out.println("erster Test");}

    try {m(-1);}
    catch (Exception _){System.out.println("Ausnahme gefangen");}
    finally {System.out.println("zweiter Test");}
  }
}</pre>finallycatchAnsonsten w&auml;re  die finally-Klausel ein &uuml;berfl&uuml;ssiges Konstrukt, k&ouml;nnte man
seinen Code ja direkt anschlie&szlig;end an das try-catch-Konstrukt
anh&auml;ngen.finally<pre>class MoreFinally {

    static void m(int i){
	if (i&lt;0) throw new NullPointerException();
    }

    public static void main(String [] args){
	try {m(-1);}
	catch (IndexOutOfBoundsException _){}
	finally 
	{System.out.println("wird trotzdem ausgegeben");}
   }

}</pre>finallyfinally<h3>4.4.8. Anwendungslogik per Ausnahmen</h3>trycatchif<pre>class CatchOutOfBounds{
  public static void main(String [] args){
    int[] xs = {1,2,3,4,5,6,5,5,2,4,5,7,4,3,2,2,5,6};
    int result = 0;
    try{
      int i =0;
      while (true) {result=result+xs[i];i=i+2;}
    }catch (IndexOutOfBoundsException e){}
    System.out.println(result);
  }
}</pre>
<h1>5. Generische Programmierung</h1>
<h2>5.1. Generische Typen</h2>pattern
matchingGJGeneric JavaPizzaGJGJ<h3>5.1.1. Generische Klassen</h3>Object<pre>class OldBox {
  Object contents;
  OldBox(Object contents){this.contents=contents;}
}</pre>ObjectOldBoxcontents<pre>class UseOldBox{
  public static void main(String [] _){
    OldBox b = new OldBox("hello");
    String s = (String)b.contents;
    System.out.println(s.toUpperCase());
    System.out.println(((String) s).toUpperCase());
  }
}</pre>contents<pre>class UseOldBoxError{
  public static void main(String [] _){
    OldBox b = new OldBox(new Integer(42));
    String s = (String)b.contents;
    System.out.println(s.toUpperCase());
  }
}</pre>sep@linux:~/fh/java1.5/examples/src&gt; javac UseOldBoxError.java
sep@linux:~/fh/java1.5/examples/src&gt; java UseOldBoxError
Exception in thread "main" java.lang.ClassCastException
        at UseOldBoxError.main(UseOldBoxError.java:4)
sep@linux:~/fh/java1.5/examples/src&gt;ObjectOldBoxObjectObjectOldBoxBox<pre>class Box&lt;elementType&gt; {
  elementType contents;
  Box(elementType contents){this.contents=contents;}
}</pre>elementTypeelementTypeBoxBoxBoxBoxBox&lt;String&gt;Box&lt;Integer&gt;<pre>class UseBox{
  public static void main(String [] _){
    Box&lt;String&gt; b1 = new Box&lt;String&gt;("hello");
    String s = b1.contents;
    System.out.println(s.toUpperCase());
    System.out.println(b1.contents.toUpperCase());

    Box&lt;Integer&gt; b2 = new Box&lt;Integer&gt;(new Integer(42));

    System.out.println(b2.contents.intValue());
  }
}</pre>b1b2BoxBox&lt;String&gt;Box&lt;Integer&gt;<pre>class UseBoxError{
  public static void main(String [] _){
    Box&lt;String&gt; b = new Box&lt;String&gt;(new Integer(42));
    String s = b.contents;
    System.out.println(s.toUpperCase());
  }
}</pre>sep@linux:~/fh/java1.5/examples/src&gt; javac UseBoxError.java
UseBoxError.java:3: cannot find symbol
symbol  : constructor Box(java.lang.Integer)
location: class Box&lt;java.lang.String&gt;
    Box&lt;String&gt; b = new Box&lt;String&gt;(new Integer(42));
                    ^
1 error
sep@linux:~/fh/java1.5/examples/src&gt;<h4>5.1.1.1. Vererbung</h4>
<pre>class GPair&lt;at,bt&gt; extends Box&lt;at&gt;{
  GPair(at x,bt y){
    super(x);
    snd = y; 
  }

  bt snd;

  public String toString(){
    return "("+contents+","+snd+")";
  }
}</pre>GPairGPair<pre>class UsePair{
  public static void main(String [] _){
    GPair&lt;String,Integer&gt; p
     = new GPair&lt;String,Integer&gt;("hallo",new  Integer(40));
    
    System.out.println(p);
    System.out.println(p.contents.toUpperCase());
    System.out.println(p.snd.intValue()+2);
  }
}</pre>sep@linux:~/fh/java1.5/examples/classes&gt; java UsePair
(hallo,40)
HALLO
42
sep@linux:~/fh/java1.5/examples/classes&gt;<pre>class UniPair&lt;at&gt; extends GPair&lt;at,at&gt;{
  UniPair(at x,at y){super(x,y);}
  void swap(){
    final at z = snd;
    snd = contents;
    contents = z;
  }
}</pre>
<pre>class UseUniPair{
  public static void main(String [] _){
    UniPair&lt;String&gt; p
     = new UniPair&lt;String&gt;("welt","hallo");
    
    System.out.println(p);
    p.swap();
    System.out.println(p);
  }
}</pre>UniPairsep@linux:~/fh/java1.5/examples/classes&gt; java UseUniPair
(welt,hallo)
(hallo,welt)
sep@linux:~/fh/java1.5/examples/classes&gt;Box<pre>class StringBox extends Box&lt;String&gt;{
  StringBox(String x){super(x);}
}</pre>
<pre>class UseStringBox{
  public static void main(String [] _){
    StringBox b = new StringBox("hallo");
    System.out.println(b.contents.length());
  }
}</pre>
<h4>5.1.1.2. Einschr&auml;nken der Typvariablen</h4>BoxsetComparable<pre>class CollectMaxOld{
  private Comparable value;

  CollectMaxOld(Comparable x){value=x;}

  void setValue(Comparable x){
    if (value.compareTo(x)&lt;0) value=x;
  }

  Comparable getValue(){return value;}
}</pre>CollectMaxOldComparableOldBoxgetValueBoxOldBoxObjectComparableComparableextendsCollectMax<pre>class CollectMax &lt;elementType extends Comparable&gt;{
  private elementType value;

  CollectMax(elementType x){value=x;}

  void setValue(elementType x){
    if (value.compareTo(x)&lt;0) value=x;
  }

  elementType getValue(){return value;}
}</pre>getValueComparable<pre>class UseCollectMax {
  public static void main(String [] _){
    CollectMax&lt;String&gt; cm = new CollectMax&lt;String&gt;("Brecht");
    cm.setValue("Calderon");
    cm.setValue("Horvath");
    cm.setValue("Shakespeare");
    cm.setValue("Schimmelpfennig");
    System.out.println(cm.getValue().toUpperCase());
  }
}</pre>
<h3>5.1.2. Generische Schnittstellen</h3>ObjectObjectObjectObjectequalsObject<h4>5.1.2.1. &Auml;pfel mit Birnen vergleichen</h4>
<pre>interface EQ&lt;otherType&gt; {
  public boolean eq(otherType other);
}</pre>ApfelimplementsEQ&lt;Apfel&gt;eqApfel<pre>class Apfel implements EQ&lt;Apfel&gt;{
  String typ;

  Apfel(String typ){
    this.typ=typ;}

  public boolean eq(Apfel other){
    return this.typ.equals(other.typ); 
  }    
}</pre>
<pre>class TestEq{
  public static void main(String []_){
    Apfel a1 = new Apfel("Golden Delicious");
    Apfel a2 = new Apfel("Macintosh");
    System.out.println(a1.eq(a2));
    System.out.println(a1.eq(a1));
  }
}</pre>EQ<pre>class Birne implements EQ&lt;Birne&gt;{
  String typ;

  Birne(String typ){
    this.typ=typ;}

  public boolean eq(Birne other){
    return this.typ.equals(other.typ); 
  }    
}</pre>
<pre>class TesteEqError{
  public static void main(String []_){
    Apfel a = new Apfel("Golden Delicious");
    Birne b = new Birne("williams");
    System.out.println(a.equals(b));
    System.out.println(a.eq(b));
  }
}</pre>./TestEQError.java:6: eq(Apfel) in Apfel cannot be applied to (Birne)
    System.out.println(a.eq(b));
                        ^
1 errorequalseqBirne<pre>class BirneError implements EQ&lt;Apfel&gt;{
  String typ;

  BirneError(String typ){
    this.typ=typ;}

  public boolean eq(Birne other){
    return this.typ.equals(other.typ); 
  }    
}</pre>sep@linux:~/fh/java1.5/examples/src&gt; javac BirneError.java
BirneError.java:1: BirneError is not abstract and does not override abstract method eq(Apfel) in EQ
class BirneError implements EQ&lt;Apfel&gt;{
^
1 error
sep@linux:~/fh/java1.5/examples/src&gt;<h3>5.1.3. Kovarianz gegen Kontravarianz</h3>ABABABABAB\sqsubseteqA \sqsubseteq BCC&lt;A&gt;\sqsubseteqC&lt;B&gt;<pre>class Kontra{
  public static void main(String []_){
    Box&lt;Object&gt; b  = new Box&lt;String&gt;("hello");
  }
}</pre>sep@linux:~/fh/java1.5/examples/src&gt; javac Kontra.java
Kontra.java:4: incompatible types
found   : Box&lt;java.lang.String&gt;
required: Box&lt;java.lang.Object&gt;
    Box&lt;Object&gt; b  = new Box&lt;String&gt;("hello");
                     ^
1 error
sep@linux:~/fh/java1.5/examples/src&gt;Box&lt;String&gt;Box&lt;Object&gt;Box&lt;String&gt;Box&lt;Object&gt;contentsBox&lt;String&gt;contents<pre>class Ko{
  public static void main(String []_){
    String [] x = {"hello"};
    Object [] b  = x;
    b[0]=new Integer(42);
    x[0].toUpperCase();
  }
}</pre>sep@linux:~/fh/java1.5/examples/classes&gt; java Ko
Exception in thread "main" java.lang.ArrayStoreException
        at Ko.main(Ko.java:5)
sep@linux:~/fh/java1.5/examples/classes&gt;<h3>5.1.4. Sammlungsklassen</h3>java.util<pre>import java.util.*;
import java.util.List;
class ListTest{
  public static void main(String [] _){
    List&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add("Schimmelpfennig");
    xs.add("Shakespeare");
    xs.add("Horvath");
    xs.add("Brecht");
    String x2 = xs.get(1);
    System.out.println(xs);
  }
}</pre>
<pre>import java.util.*;
import java.util.List;
class WarnTest{
  public static void main(String [] _){
    List xs = new ArrayList&lt;String&gt;();
    xs.add("Schimmelpfennig");
    xs.add("Shakespeare");
    xs.add("Horvath");
    xs.add("Brecht");
    String x2 = (String)xs.get(1);
    System.out.println(xs);
  }
}</pre>sep@linux:~/fh/java1.5/examples/src&gt; javac WarnList.java
Note: WarnList.java uses unchecked or unsafe operations.
Note: Recompile with -warnunchecked for details.
sep@linux:~/fh/java1.5/examples/src&gt;<h3>5.1.5. Generische Methoden</h3>tracetrace<pre>class Trace {

  static &lt;elementType&gt;  elementType trace(elementType x){
    System.out.println(x);
    return x;
  }
  
  public static void main(String [] _){
    String x = trace ((trace ("hallo")
                      +trace( " welt")).toUpperCase());

    Integer y = trace (new Integer(40+2));
  }
}</pre>traceelementType<h2>5.2. Iteration</h2>
In diesen Beispiel finden sich die zwei wahrscheinlich am h&auml;ufigsten
programmierten Schleifentypen. Einmal iterieren wir &uuml;ber alle Elemente einer
Reihung und einmal iterieren wir mittels eines Iteratorobjekts &uuml;ber alle
Elemente eines Sammlungsobjekts:<pre>import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

class OldIteration{

  public static void main(String [] _){
    String [] ar
      = {"Brecht","Horvath","Shakespeare","Schimmelpfennig"};
    List xs = new ArrayList();

    for (int i= 0;i&lt;ar.length;i++){
      final String s = ar[i];
      xs.add(s);
    }  
 
    for (Iterator it=xs.iterator();it.hasNext();){
      final String s = (String)it.next();
      System.out.println(s.toUpperCase());
    }
  }
}</pre>
Die Codemenge zur Schleifensteuerung ist gewaltig und &uuml;bersteigt hier sogar die
eigentliche Anwendungslogik.
        for (Typeidentifier : expr)body
            
          
      identifierTypeexprbodyEin noch sprechenderes Konstrukt w&auml;re gewesen, wenn man statt des
Doppelpunkts das Schl&uuml;sselwort in benutzt h&auml;tte. Aus
Aufw&auml;rtskompatibilit&auml;tsgr&uuml;nden wird  jedoch darauf verzichtet, neue
Schl&uuml;sselw&ouml;rter in Java einzuf&uuml;hren.
Damit lassen sich jetzt die Iterationen der letzten beiden Schleifen
wesentlich eleganter ausdr&uuml;cken. <pre>import java.util.List;
import java.util.ArrayList;

class NewIteration{

  public static void main(String [] _){
    String [] ar
     = {"Brecht","Horvath","Shakespeare","Schimmelpfennig"};
    List&lt;String&gt; xs = new ArrayList&lt;String&gt;();

    for (String s:ar) xs.add(s); 
    for (String s:xs) System.out.println(s.toUpperCase());
  }
}</pre>
Der gesamte Code zur Schleifensteuerung ist entfallen. Zus&auml;tzlich ist
    garantiert, da&szlig; f&uuml;r endliche Sammlungsiteratoren auch die Schleife
    terminiert. for<h3>5.2.1. Die neuen Schnittstellen Iterable</h3>
          
<pre>package sep.util.io;

import java.io.Reader;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.Iterator;


public class ReaderIterator 
              implements Iterable&lt;Character&gt;
                        ,Iterator&lt;Character&gt;{
  private Reader reader;
  private int n;
  public ReaderIterator(Reader r){
    reader=new BufferedReader(r);
    try{n=reader.read();
    }catch(IOException _){n=-1;}
  }
  public Character next(){
    Character result = new Character((char)n);   
    try{n=reader.read();
    }catch(IOException _){n=-1;}
    return result;
  }

  public boolean hasNext(){
    return n!=-1;
  }

  public void remove(){
    throw new UnsupportedOperationException();
  }

  public Iterator&lt;Character&gt; iterator(){return this;}
}</pre>
          
<pre>import sep.util.io.ReaderIterator;
import java.io.FileReader;

class TestReaderIterator {
  public static void main(String [] args) throws Exception{
      Iterable&lt;Character&gt; it
        =new ReaderIterator(new FileReader(args[0]));
      for (Character c:it){
      System.out.print(c);
    }
  }
}</pre>
        
Ein abschlie&szlig;endes kleines Beispiel f&uuml;r generische Sammlungsklassen und die
neue for-Schleife. Die folgende Klasse stellt Methoden zur Verf&uuml;gung,
um einen String in eine Liste von W&ouml;rtern zu spalten und umgekehrt aus einer
Liste von W&ouml;rtern wieder einen String zu bilden:<pre>import java.util.*;
import java.util.List;

class TextUtils {

  static List&lt;String&gt; words (String s){
    final List&lt;String&gt; result = new ArrayList&lt;String&gt;();

    StringBuffer currentWord = new StringBuffer();

    for (char c:s.toCharArray()){
      if (Character.isWhitespace(c)){
        final String newWord = currentWord.toString().trim();
        if(newWord.length()&gt;0){
          result.add(newWord);
          currentWord=new StringBuffer();
        }
      }else{currentWord.append(c);} 
    }
    return result;
  }

  static String unwords(List&lt;String&gt; xs){
    StringBuffer result=new StringBuffer();
    for (String x:xs) result.append(" "+x);
    return result.toString().trim();
  }

  public static void main(String []_){
    List&lt;String&gt; xs = words("  the   world  is my Oyster  ");

    for (String x:xs) System.out.println(x);

    System.out.println(unwords(xs));
  }
}</pre>
<h1>6. Datentypen und Algorithmen</h1>
<h2>6.1. Listen</h2>
<h3>6.1.1. Formale Spezifikation</h3>Man vergleiche es mit der Definition der nat&uuml;rlichen Zahlen: die 0  entspricht der leeren
Liste, der Schritt von n nach n+1 dem Hinzuf&uuml;gen eines neuen
Elements zu einer Liste.<h4>6.1.1.1. Konstruktoren</h4>
             einem Konstruktor f&uuml;r neue Listen, die noch leer sind.
             einem Konstruktor, der aus einem Element und einer bereits
bestehenden Liste eine neue Liste konstruiert, indem an  die
Ursprungsliste das Element angeh&auml;ngt wird.
          Entgegen der Notation in Java, in der
der R&uuml;ckgabetyp kurioser Weise vor den Namen der Methode geschrieben
wird.
            Empty: () List
            Cons: (Object,List) List
          <h4>6.1.1.2. Selektoren</h4>ConsConsheadtail
            head: (List)Object
            tail: (List)List
          
head(Cons(x,xs)) x
tail(Cons(x,xs)) xs<h4>6.1.1.3. Testmethoden</h4>ConsisEmpty
            isEmpty: Listboolean
          
isEmpty(Empty())  true
isEmpty(Cons(x,xs))  false<h4>6.1.1.4. Listenalgorithmen</h4>
Und ebenso l&auml;&szlig;t sich durch zwei Gleichungen spezifizieren, was die L&auml;nge einer
Liste ist:
length(Empty())0
length(Cons(x,xs))1+length(xs)


Mit Hilfe dieser Gleichungen l&auml;&szlig;t sich jetzt schrittweise die Berechnung einer Listenl&auml;nge auf Listen durchf&uuml;hren. Hierzu benutzen wir die Gleichungen als Ersetzungsregeln. Wenn ein Unterausdruck in der Form der linken Seite 
einer Gleichung gefunden wird, so kann diese durch die entsprechende rechte Seite ersetzt werden. Man spricht bei so einem Ersetzungsschritt von einem
Reduktionsschritt. Wir errechnen in diesem Beispiel die L&auml;nge einer Liste, indem wir die obigen
Gleichungen zum Reduzieren auf die Liste anwenden:length(Cons(a,Cons(b,Cons(c,Empty()))))1+length(Cons(b,Cons(c,Empty())))1+(1+length(Cons(c,Empty())))1+(1+(1+length(Empty())))1+(1+(1+0))1+(1+1)1+23
Wir k&ouml;nnen mit einfachen Gleichungen spezifizieren, was wir unter dem letzten
Element einer Liste verstehen.
last(Cons(x,Empty()))) x
last(Cons(x,xs)))last(xs)

Auch die Funktion last k&ouml;nnen wir von Hand auf einer Beispielliste einmal per Reduktion ausprobieren:last(Cons(a,Cons(b,Cons(c,Empty()))))last(Cons(b,Cons(c,Empty())))last(Cons(c,Empty()))c
Die folgenden Gleichungen spezifizieren, wie zwei Listen aneinandergeh&auml;ngt
werden: 
concat(Empty(),ys)ys
concat(Cons(x,xs),ys)Cons(x,concat(xs,ys)) Auch diese Funktion l&auml;&szlig;t sich beispielhaft mit der Reduktion einmal
durchrechnen: concat(Cons(i,Cons(j,Empty())),Cons(a,Cons(b,Cons(c,Empty()))))Cons(i,concat(Cons(j,Empty()),Cons(a,Cons(b,Cons(c,Empty())))))Cons(i,Cons(j,concat(Empty(),Cons(a,Cons(b,Cons(c,Empty()))))))Cons(i,Cons(j,Cons(a,Cons(b,Cons(c,Empty())))))<h4>6.1.1.5. Schachtel- und Zeiger-Darstellung</h4>headtailCons(a,Cons(b,Cons(c,Empty())))concatconcatconcatconcatconcat<h3>6.1.2. Modellierung</h3>PizzaPizza<h4>6.1.2.1. Modellierung als Klassenhierarchie</h4>Consheadtail<h4>6.1.2.2. In einer Klasse</h4>List<h3>6.1.3. Codierung</h3>
<h4>6.1.3.1. Implementierung als Klassenhierarchie</h4>
Die zusammenfassende Oberklasse der Listenstruktur List
stellt f&uuml;r die 
Listenmethoden head, tail und isEmpty jeweils 
eine prototypische Implementierung zur Verf&uuml;gung. Die 
Methode isEmpty setzen wir in unserer Umsetzung standardm&auml;&szlig;ig
auf false. <pre>package name.panitz.data.list;
class List&lt;a&gt;{
 boolean isEmpty(){return false;}
 a head(){return null;}
 List&lt;a&gt; tail(){return null;}</pre>
Die Methoden tail und head k&ouml;nnen nur f&uuml;r nichtleere
Listen Objekte zur&uuml;ckgeben. Daher haben wir uns f&uuml;r die prototypischen
Implementierung in der Klasse List dazu entschieden, den 
Wert null zur&uuml;ckzugeben. null steht in Java f&uuml;r das

Fehlen eines Objektes. Der Versuch, auf Felder und Methoden 
von null zuzugreifen, f&uuml;hrt in Java zu einem Fehler.
F&uuml;r die Klasse List schreiben wir keinen Konstruktor. Wir
wollen diese Klasse nie direkt instanziieren, d.h.nie einen
Konstruktor f&uuml;r die Klasse List aufrufen.In diesem
Fall generiert Java automatisch einen Konstruktor ohne Argumente, doch
dazu mehr an anderer Stelle. Die Klasse, die die leere Liste darstellt, ist relativ leicht
abzuleiten. Wir stellen einen Konstruktor zur Verf&uuml;gung und
&uuml;berschreiben die Methode isEmpty.<pre>package name.panitz.data.list;
class Empty&lt;a&gt; extends List&lt;a&gt; {
  Empty(){}  
  boolean isEmpty(){return true;}
}</pre>
Schlie&szlig;lich ist noch die Klasse Cons zu codieren.  Diese
Klasse ben&ouml;tigt nach unserer Modellierung zwei Felder, in denen Kopf
und Schwanz der Liste abgespeichert werden k&ouml;nnen. 
Die Methoden head und tail werden so &uuml;berschrieben,
da&szlig; sie entsprechend den Wert eines dieser Felder zur&uuml;ckgeben. Der
Konstruktor initialisiert diese beiden Felder.<pre>package name.panitz.data.list;
class Cons&lt;a&gt; extends List&lt;a&gt;{

  a hd;
  List&lt;a&gt; tl ;

  Cons(a x,List&lt;a&gt; xs){
    hd = x;
    tl = xs;
  }

  a head(){
    return hd;
  }

  List&lt;a&gt; tail(){
    return tl;
  }</pre>
F&uuml;r Algorithmen auf Listen werden wir nur
die zwei Konstruktoren, die zwei Selektoren und die 
Testmethode isEmpty benutzen. Folgendes kleine Testprogramm
konstruiert eine Liste mit drei Elementen des 
Typs String. Anschlie&szlig;end folgen einige Tests f&uuml;r die Selektormethoden: <pre>package name.panitz.data.list;
class TestFirstList {
  public static void main(String [] args){

    //Konstruktion einer Testliste
    List xs = new Cons&lt;String&gt;("friends",
              new Cons&lt;String&gt;("romans", 
              new Cons&lt;String&gt;("countrymen",
              new Empty&lt;String&gt;())));

    //Zugriffe auf einzelne Elemente
    System.out.println("1. Element: "+xs.head());
    System.out.println("2. Element: "+xs.tail().head());
    System.out.println("3. Element: "+xs.tail().tail().head());
    
    //Test f&uuml;r die Methode isEmpty()
    if (xs.tail().tail().tail().isEmpty()){
      System.out.println("leere Liste nach drittem Element.");
    }

    //Ausgabe eines null Wertes
    System.out.println(xs.tail().tail().tail().head());
  } 
}</pre>

Tats&auml;chlich bekommen wir f&uuml;r unsere Tests die erwartete Ausgabe:sep@linux:~/fh/prog1/examples/classes&gt; java name.panitz.data.list.TestFirstList
1. Element: friends
2. Element: romans
3. Element: countrymen
leere Liste nach drittem Element.
null
sep@linux:~/fh/prog1/examples/classes&gt;<h4>6.1.3.2. Implementierung als eine Klasse</h4>booleanempty<pre>package name.panitz.data.list;
class Li&lt;a&gt; implements Iterable&lt;a&gt;{
  boolean empty = true;
  a  hd;
  Li&lt;a&gt; tl;
 
  Li(){}

  Li(a x,Li&lt;a&gt; xs){
   hd = x;
   tl = xs;
   empty = false;
  }

  boolean isEmpty() {return empty;}  
  a  head(){return hd;}
  Li&lt;a&gt;      tail(){return tl;}

  public java.util.Iterator&lt;a&gt; iterator(){
    final Li&lt;a&gt;  itout = this;
    return new java.util.Iterator&lt;a&gt;(){
      Li&lt;a&gt;  it = itout;
      public boolean hasNext(){return !it.isEmpty();}
      public a next(){a result=it.head();it=it.tail();return result;}
      public void remove(){throw new UnsupportedOperationException();}
    };
  }  </pre>
<pre>
package name.panitz.data.list;
class TestFirstLi {
  public static void main(String [] args){

    //Konstruktion einer Testliste
    Li&lt;String&gt; xs = new Li&lt;String&gt;("friends",
                    new Li&lt;String&gt;("romans", 
                    new Li&lt;String&gt;("countrymen",
                    new Li&lt;String&gt;())));

    //Zugriffe auf einzelne Elemente
    System.out.println("1. Element: "+xs.head());
    System.out.println("2. Element: "+xs.tail().head());
    System.out.println("3. Element: "+xs.tail().tail().head());
    
    //Test f&uuml;r die Methode isEmpty()
    if (xs.tail().tail().tail().isEmpty()){
      System.out.println("leere Liste nach drittem Element.");
    }

    //Ausgabe eines null Wertes
    System.out.println(xs.tail().tail().tail().head());
  }
 
}</pre>sep@linux:~/fh/prog1/examples/classes&gt; java TestFirstLi
1. Element: friends
2. Element: romans
3. Element: countrymen
leere Liste nach drittem Element.
null
sep@linux:~/fh/prog1/examples/classes&gt;
Die Konstruktion der dreielementigen Liste oben war schon recht
umst&auml;ndlich. Jede Teilliste mu&szlig;te explizit durch einen Konstruktoraufruf
generiert werden. Die variable Argumentanzahl f&uuml;r Methoden erlaubt es, einen
Konstruktor zu definieren, der die einzelnen Elemente der zu erzeugenen Liste
als Argumente erh&auml;lt. <pre>  public Li(a... xs){
    this(0,xs);
  }

  private Li(int i,a... xs){
    if (i&lt;xs.length) {
      empty=false;
      hd=xs[i];
      tl = new Li&lt;a&gt;(i+1,xs);
    }
  }</pre>

Jetzt lassen sich bequem auch l&auml;ngere Listen durch einen einzigen
Konstruktoraufruf erzeugen:<pre>
package name.panitz.data.list;
class TestFirstLi2 {
  public static void main(String [] args){

    //Konstruktion einer Testliste
    Li&lt;String&gt; xs 
     = new Li&lt;String&gt;
          ("Friends", "Romans", "countrymen", "lend", "me","your", "ears" 
          ,"I","come","to","bury","Caesar","not","to","praise","him");

    //Zugriffe auf einzelne Elemente
    System.out.println("1. Element: "+xs.head());
    System.out.println("2. Element: "+xs.tail().head());
    System.out.println("3. Element: "+xs.tail().tail().head());
    
    //Test f&uuml;r die Methode isEmpty()
    if (!xs.tail().tail().tail().isEmpty()){
      System.out.println("keine leere Liste nach drittem Element.");
    }

    //Ausgabe 4. Wertes
    System.out.println(xs.tail().tail().tail().head());
  }
 
}</pre>
<h3>6.1.4. Methoden f&uuml;r Listen</h3>
<h4>6.1.4.1. L&auml;nge</h4>Conslength
length(Empty())  0
length(Cons(x,xs))  1 + length(xs)ifListLilength<pre>  int length(){
    if (isEmpty())return 0;
    return 1+tail().length();
  }</pre>lengthmainlength<pre>package name.panitz.data.list;
class TestLength {
  static  Li&lt;String&gt; XS 
   =  new Li&lt;String&gt;("friends"
     ,new Li&lt;String&gt;("romans"
     ,new Li&lt;String&gt;("countrymen"
     ,new Li&lt;String&gt;())));

  public static void main(String [] args){
    System.out.println(XS.length());
  }
}</pre>lengthsep@linux:~/fh/prog1/examples/classes&gt; java TestLength
3
sep@linux:~/fh/prog1/examples/classes&gt;
Im Fall der Klassenhierarchie k&ouml;nnen wir auch 
die if-Bedingung der Methode length dadurch
ausdr&uuml;cken, da&szlig; die beiden F&auml;lle sich in den unterschiedlichen Klassen
f&uuml;r die beiden unterschiedlichen Listenarten befinden. In der 
Klasse List kann folgende prototypische Implementierung
eingef&uuml;gt werden:<pre>  int length(){return 0;} 
}</pre>
In der Klasse Cons, die ja Listen mit einer L&auml;nge gr&ouml;&szlig;er 0
darstellt, ist dann die Methode entsprechend zu &uuml;berschreiben:<pre>  int length(){return 1+tail().length();}
}</pre>


Auch diese L&auml;ngenimplementierung k&ouml;nnen wir testen:<pre>package name.panitz.data.list;
class TestListLength {
  static  List&lt;String&gt; XS 
    = new Cons&lt;String&gt;("friends"
     ,new Cons&lt;String&gt;("romans"
     ,new Cons&lt;String&gt;("countrymen"
     ,new Empty&lt;String&gt;())));

  public static void main(String [] args){
    System.out.println(XS.length());
  }
}</pre>

An diesem Beispiel ist gut zu sehen, wie durch die Aufsplittung in
verschiedene Unterklassen beim Schreiben von 
Methoden if-Abfragen verhindert werden k&ouml;nnen. Die verschiedenen
F&auml;lle einer if-Abfrage  finden sich dann in den
unterschiedlichen Klassen realisiert. Der Algorithmus ist in diesem
Fall auf verschiedene Klassen aufgeteilt. 
Die beiden obigen Implementierungen der 
Methode length sind rekursiv. Im Rumpf der Methode wurde sie
selbst gerade wieder aufgerufen. Nat&uuml;rlich kann die Methode mit den
entsprechenden zusammengesetzten Schleifenbefehlen in Java auch
iterativ gel&ouml;st werden.  Wir wollen zun&auml;chst versuchen, die Methode mit Hilfe 
einer while-Schleife zu realisieren. Der Gedanke ist
naheliegend. Solange es sich noch nicht um die leere Liste handelt,
wird ein Z&auml;hler, der die Elemente z&auml;hlt, hochgez&auml;hlt:<pre>  int lengthWhile(){
    int erg=0;
    Li&lt;a&gt; xs = this;
    while (!xs.isEmpty()){
      erg= erg +1;
      xs = xs.tail();
    }
    return erg;
  }</pre>
Schaut man sich diese L&ouml;sung genauer an, so sieht man, da&szlig; sie die
  klassischen drei Bestandteile einer for-Schleife enth&auml;lt:
              die Initialisierung einer 
Laufvariablen: List xs = this;
              eine bool'sche Bedingung zur 
Schleifensteuerung: !xs.isEmpty()
              eine Weiterschaltung der 
Schleifenvariablen: xs = xs.tail();
             Damit ist die Schleife, die &uuml;ber die Elemente einer Liste iteriert, ein
guter Kandidat f&uuml;r eine for-Schleife. Wir k&ouml;nnen das Programm
entsprechend umschreiben:<pre>  int lengthFor(){
    int erg=0;
    for (Li&lt;a&gt; xs=this;!xs.isEmpty();xs=xs.tail()){
      erg = erg +1;
    }
    return erg;
  }</pre>
Eine Schleifenvariable ist also nicht unbedingt eine Zahl, die hoch
  oder herunter gez&auml;hlt wird, sondern kann auch ein Objekt sein, von
  dessen Eigenschaften abh&auml;ngt, ob die Schleife ein weiteres Mal zu
  durchlaufen ist.
In solchen F&auml;llen ist die Variante mit der for-Schleife der
Variante mit der while-Schleife vorzuziehen, weil somit die
Befehle, die die Schleife steuern, geb&uuml;ndelt zu Beginn der Schleife
stehen. <h4>6.1.4.2. toString</h4>toString<pre>  public String toString(){
    return "("+toStringAux()+")";
  }

  private String toStringAux(){
    if (isEmpty()) return "";
    else if (tail().isEmpty()) return head().toString();
    else return head().toString()+","+tail().toStringAux();
  }</pre>Nehmen Sie beide der in diesem Kapitel entwickelten
Umsetzungen von Listen und f&uuml;gen Sie ihrer Listenklassen folgende Methoden
hinzu. F&uuml;hren  Sie Tests f&uuml;r diese Methoden durch.
            a last(): gibt das letzte Element der Liste aus.
            List&lt;a&gt; concat(List&lt;a&gt; other) bzw.: Li&lt;a&gt; concat(Li&lt;a&gt; other): erzeugt eine neue Liste, die
erst die Elemente der this-Liste und dann 
der other-Liste hat, es sollen also zwei Listen aneinander
geh&auml;ngt werden. 
            a elementAt(int i): gibt das Element an einer
bestimmten Indexstelle der Liste zur&uuml;ck. Spezifikation:
elementAt(Cons(x,xs),1)x
elementAt(Cons(x,xs),n+1)elementAt(xs,n)
          <h3>6.1.5. Sortierung</h3>StringcompareToString<pre>package name.panitz.data.list;
class StringOrdering{
  static boolean lessEqual(String x,String y){
    return x.compareTo(y)&lt;=0;
  }
}</pre>
<h4>6.1.5.1. Sortieren durch Einf&uuml;gen</h4>
<pre>package name.panitz.data.list;
class SortStringLi extends Li&lt;String&gt; { 

  SortStringLi(){super();}
  SortStringLi(String x,SortStringLi xs){super(x,xs);}

  SortStringLi sortTail(){return (SortStringLi)tail();}</pre>insertSorted<pre>  SortStringLi insertSorted(String x){</pre>
<pre>    if (isEmpty()) {return new SortStringLi(x,this);}</pre>
<pre>    else if (StringOrdering.lessEqual((String)head(),x)){
      return new SortStringLi
                  ((String)head()
                  ,((SortStringLi)tail()).insertSorted(x));</pre>
<pre>    } else return new SortStringLi(x,this);
  }//method insertSorted</pre>
<pre>  SortStringLi getSorted(){
    SortStringLi result = new SortStringLi();

    for (Li&lt;String&gt; xs= this;!xs.isEmpty();xs = xs.tail()){
      result = result.insertSorted(xs.head());
    }

    return result;
  }//method sort</pre>SortStringLi<pre>  public static void main(String [] args){
    SortStringLi xs
      = new SortStringLi("zz"
       ,new SortStringLi("ab"
       ,new SortStringLi("aaa"
       ,new SortStringLi("aaa"
       ,new SortStringLi("aaz"
       ,new SortStringLi("aya"
       ,new SortStringLi()))))));


    System.out.println("Die unsortierte Liste:");
    System.out.println(xs);

    Li&lt;String&gt; ys = xs.getSorted();
    System.out.println("Die sortierte Liste:");
    System.out.println(ys);
  }
}//class SortStringLi</pre>sep@swe10:~/fh/prog1/Listen&gt; java SortStringLi
Die unsortierte Liste:
(zz,ab,aaa,aaa,aaz,aya)
Die sortierte Liste:
(aaa,aaa,aaz,ab,aya,zz)
sep@swe10:~/fh/prog1/Listen&gt;<h4>6.1.5.2. Quick Sort</h4>quick sortDer Name quick sort ist insofern nicht immer
berechtigt, weil in
bestimmten F&auml;llen  das  Verfahren nicht sehr
schnell im Vergleich zu anderen Verfahren ist.
Mathematisch
l&auml;&szlig;t sich das Verfahren wie durch folgende Gleichungen beschreiben:
quicksort(Empty()) Empty()
quicksort(Cons(x,xs))quicksort(y|y\in xs, y&lt;=x)
                ++
               Cons(x,quicksort(y|y\in xs, y&gt;x)) 

Die erste Gleichung spezifiziert, da&szlig; das Ergebnis der Sortierung
einer leeren Liste eine leere Liste zum Ergebnis hat.
Die zweite Gleichung spezifiziert den Algorithmus f&uuml;r nichtleere
Listen. Der in der Gleichung benutzte Operator ++ steht f&uuml;r
die Konkatenation zweier Listen mit der in der letzten Aufgabe
geschriebenen Methode concat. 
Die Gleichung ist zu lesen als:
Um eine nichtleere Liste zu sortieren, filtere alle Elemente aus der
Schwanzliste, die kleiner sind als der Kopf der Liste. Sortiere diese
Teilliste. Mache dasselbe mit der Teilliste aus den Elementen des
Schwanzes, die gr&ouml;&szlig;er als das Kopfelement sind. H&auml;nge schlie&szlig;lich
diese beiden sortierten Teillisten aneinander und das Kopfelement 
dazwischen.
Anders als in unserer obigen Sortierung durch Einf&uuml;gen in eine neue Liste, f&uuml;r
die wir eine Unterklasse der Klasse Li geschrieben haben,
wollen wir die Methode quicksort in der 
Klasse Li direkt implementieren, 
d.h.allgemein f&uuml;r alle Listen zur
Verf&uuml;gung stellen.
Aus der Spezifikation geht hervor, da&szlig; wir als zentrales Hilfsmittel
eine Methode brauchen, die nach einer bestimmten Bedingung Elemente
aus einer Liste filtert. Wenn wir diesen Mechanismus haben, so ist der
Rest des Algorithmus mit Hilfe der Methode concat trivial
direkt aus der Spezifikation ableitbar. Um die 
Methode filter m&ouml;glichst allgemein zu halten, k&ouml;nnen wir sie
so schreiben, da&szlig; sie ein Objekt bekommt, in dem eine Methode die
Bedingung, nach der zu filtern ist, angibt. Eine solche Klasse sieht
allgemein wie folgt aus:<pre>package name.panitz.data.list;
class FilterCondition&lt;a&gt; {
  boolean condition(a testMe){
    return true;
  }
}</pre>
              
<pre>Li&lt;a&gt; append(Li&lt;a&gt; ys){
  if (isEmpty())return ys;
  return new Li&lt;a&gt;(head(),tail().append(ys));
}</pre>
            

F&uuml;r bestimmte Bedingungen k&ouml;nnen f&uuml;r eine solche Klasse Unterklassen
definiert werden, die die Methode condition entsprechend
&uuml;berschreiben. F&uuml;r unsere Sortierung brauchen wir zwei
Bedingungen: einmal wird ein Objekt getestet, ob es gr&ouml;&szlig;er ist als
ein vorgegebenes Objekt, ein anderes Mal, ob es kleiner ist. Wir
erhalten also folgende kleine Klassenhierarchie aus 
Abbildung:
Die beiden Unterklassen brauchen jeweils ein Feld, in dem das Objekt gespeichert ist, mit dem das Element im Gr&ouml;&szlig;envergleich getestet wird.
Die f&uuml;r den Sortieralgorithmus ben&ouml;tigte Methode filter kann
entsprechend ein solches Objekt also Argument bekommen:<pre>Li&lt;a&gt; filter(Condition&lt;a&gt; cond);</pre>
Die entscheidende Methode f&uuml;r den Sortieralgorithmus ist filter. Mit
dieser Methode werden entsprechend einer Filterbedingung bestimmte Elemente
aus einer Liste selektiert. 

In der Klasse Li kann nun die 
Methode filter eingef&uuml;gt werden:<pre>  Li&lt;a&gt; filter(FilterCondition&lt;a&gt; cond){
    Li&lt;a&gt; result = new Li&lt;a&gt;(); 

    //test all elements of this list
    for (Li&lt;a&gt; xs=this;!xs.isEmpty();xs=xs.tail()){

      //in case that the condition is true for the element
      if (cond.condition(xs.head())) {
        //then add it to the result
        result = new Li&lt;a&gt;(xs.head(),result);
      }
    }
    return result;
  }</pre>
Hiermit ist die Hauptarbeit f&uuml;r den quick sort-Algorithmus
      getan. 
Bevor wir die Methode quicksort implementieren, wollen wir ein
paar Tests f&uuml;r unsere Methode filter schreiben. Hierzu schreiben wir
Klassen f&uuml;r die Bedingungen, nach denen wir Elemente aus einer Liste filtern
wollen:


Zun&auml;chst eine Bedingung, die Stringobjekte mit einer L&auml;nge gr&ouml;&szlig;er als 10
selektiert:<pre>package name.panitz.data.list;
class LongString extends FilterCondition&lt;String&gt;{
  boolean condition(String testMe){
    return testMe.length()&gt;10;
  }
}</pre>

Eine weitere Bedingung soll testen, ob ein Stringobjekt mit einem
Gro&szlig;buchstaben 'A' beginnt:<pre>package name.panitz.data.list;
class StringStartsWithA extends FilterCondition&lt;String&gt;{
  boolean condition(String testMe){
    return testMe.charAt(0)=='A';
  }
}</pre>

Und eine dritte Bedingung, die wahr wird f&uuml;r Stringobjekte, die kein gro&szlig;es
'A' enthalten:<pre>package name.panitz.data.list;
class ContainsNoA extends FilterCondition&lt;String&gt;{
  boolean condition(String testMe){
    for (int i= 0;i&lt;testMe.length();i=i+1){
      final char c = testMe.charAt(i);

      if (c=='A' || c=='a') return false;
    }
    return true;
  }
}</pre>

Probeweise filtern wir jetzt einmal eine Liste nach diesen drei Bedingungen:<pre>package name.panitz.data.list;
class TestFilter {

  static
     Li&lt;String&gt; XS = new Li&lt;String&gt;("Shakespeare",
             new Li&lt;String&gt;("Brecht",
             new Li&lt;String&gt;("Achternbusch",
             new Li&lt;String&gt;("Calderon",
             new Li&lt;String&gt;("Moliere",
             new Li&lt;String&gt;("Sorokin",
             new Li&lt;String&gt;("Schimmelpfennig",
             new Li&lt;String&gt;("Kane",
             new Li&lt;String&gt;("Wilde",
             new Li&lt;String&gt;())))))))));

  public static void main(String [] _){
     System.out.println(XS);
     System.out.println(XS.filter(new ContainsNoA()));
     System.out.println(XS.filter(new StringStartsWithA()));
     System.out.println(XS.filter(new LongString()));
  }
}</pre>

In der Ausgabe k&ouml;nnen wir uns vom korrekten Lauf der 
Methode filter &uuml;berzeugen:sep@linux:~/fh/prog1/examples/classes&gt; java TestFilter
(Shakespeare,Brecht,Achternbusch,Calderon,Moliere,Sorokin,Schimmelpfennig,Kane,Wilde)
(Wilde,Schimmelpfennig,Sorokin,Moliere,Brecht)
(Achternbusch)
(Schimmelpfennig,Achternbusch,Shakespeare)
sep@linux:~/fh/prog1/examples/classes&gt;
Interessant zu beobachten mag sein, da&szlig; unsere Methode filter die
Reihenfolge der Elemente der Liste umdreht.




Zur&uuml;ck zu unserer eigentlichen Aufgabe, dem quick sort-Verfahren.
Hier wollen wir die Eingabeliste einmal nach allen
Elementen, die kleiner als das erste Element sind, filtern; und einmal nach
allen Elementen, die gr&ouml;&szlig;er als dieses sind. Hierzu brauchen wir zwei
Filterbedingungen. Diese h&auml;ngen beide von einem bestimmten Element, n&auml;mlich
dem ersten Element der Liste, ab.
Die beiden Klassen f&uuml;r die Bedingung lassen sich relativ einfach aus
der Modellierung ableiten: <pre>package name.panitz.data.list;
class LessEqualX&lt;a&gt; extends FilterCondition&lt;a&gt;{
  Comparable&lt;a&gt; x;

  LessEqualX(Comparable&lt;a&gt; x){
    this.x=x;
  }
    
  boolean condition(a testMe){
    return x.compareTo(testMe)&gt;0;
  }
}</pre>
Entsprechend f&uuml;r die gr&ouml;&szlig;er-Relation: <pre>package name.panitz.data.list;
class GreaterX&lt;a&gt; extends FilterCondition&lt;a&gt; {
  Comparable&lt;a&gt; x;

  GreaterX(Comparable&lt;a&gt; x){
    this.x=x;
  }
    
  boolean condition(a testMe){
    return x.compareTo(testMe)&lt;=0;
  }
}</pre>


Die Methode quicksort l&auml;&szlig;t sich direkt aus der
      formalen Spezifikation ableiten:<pre>  static public &lt;a extends Comparable&lt;a&gt;&gt; Li&lt;a&gt; quicksort(Li&lt;a&gt; xs){
    Li&lt;a&gt; result = new Li&lt;a&gt;();
    if (!xs.isEmpty()){ 
      result 
       = //filter the smaller elements out of the tail
         //and sort these
         quicksort(xs.tail().filter(new LessEqualX&lt;a&gt;(xs.head())))
          //concatenate it with the sorted 
          //sublist of greater elements
          .append(new Li&lt;a&gt;(xs.head()
                 ,quicksort(xs.tail().filter(new GreaterX&lt;a&gt;(xs.head())))
            ));
    }
    return result;
  }</pre>

Obige Umsetzung des quick sort-Algorithmus ist allgemeiner
als der zuvor entwickelte Algorithmus zur Sortierung durch
Einf&uuml;gen. Die entscheidende Methode filter ist parameterisiert
&uuml;ber die Bedingung, nach der gefiltert werden soll. Damit l&auml;&szlig;t sich
schnell eine quick sort-Methode schreiben, deren Filter nicht
auf der gr&ouml;&szlig;er-Relation von String Objekten basiert. Hierzu
sind nur entsprechende Unterklassen der 
Klasse FilterCondition zu schreiben und in der Sortiermethode
zu benutzen. Wieder einmal haben wir unsere strenge Trennung aus der
anf&auml;nglichen Arbeitshypothese durchbrochen: Die Objekte der 
Klasse FilterCondition stellen nicht prim&auml;r Daten dar,
sondern eine Methode, die wir als Argument einer anderen 
Methode (der Methode filter) &uuml;bergeben.
Es ist naheliegend, die Parameterisierung &uuml;ber die eigentliche
Ordnungsrelation der Sortiermethode mitzugeben, also eine
Sortiermethode zu schreiben, die einen Parameter hat, der angibt, nach
welchem Kriterium zu sortieren ist:<pre>Li&lt;a&gt; sortBy(Relation rel)</pre>
Hierzu brauchen wir eine Klasse Relation, die eine Methode
hat, in der entschieden wird, ob zwei Objekte in einer Relation stehen:<pre>package name.panitz.data.list;
class Relation&lt;a,b&gt;{
  boolean lessEqual(a x,b y){
    return true;
  }
}</pre>

Je nachdem, was wir sortieren wollen, k&ouml;nnen wir eine Subklasse der
Klasse Relation definieren, die uns sagt, wann zwei Objekte
in der kleiner-Relation stehen. F&uuml;r Objekte des 
Typs String bietet folgende Klasse eine ad&auml;quate Umsetzung:<pre>package name.panitz.data.list;
class StringLessEqual extends Relation&lt;String,String&gt; {
  boolean lessEqual(String x,String y){
    return x.compareTo(y)&lt;=0;
  }
}</pre>


Um den quick sort-Algorithmus anzuwenden, ben&ouml;tigen wir nun
noch eine M&ouml;glichkeit, aus einer Relation die beiden Bedingungen f&uuml;r
die Methode filter generieren. Wir schreiben zwei neue
Subklassen der Klasse FilterCondition, die f&uuml;r eine Relation
jeweils kleinere bzw.gr&ouml;&szlig;ere Objekte als ein vorgegebenes Objekt
filtern.<pre>package name.panitz.data.list;
class OrderingCondition&lt;a&gt; extends FilterCondition&lt;a&gt;{
  a x;
  Relation&lt;a,a&gt; rel;

  OrderingCondition(a x,Relation&lt;a,a&gt; rel){
    this.x=x;
    this.rel = rel;
  }
    
  boolean condition(a y){
    return rel.lessEqual(y,x);
  }
}</pre>
Entsprechend f&uuml;r die negierte Relation:<pre>package name.panitz.data.list;
class NegativeOrderingCondition&lt;a&gt;  extends FilterCondition&lt;a&gt;{
  a x;
  Relation&lt;a,a&gt; rel;

  NegativeOrderingCondition(a x,Relation&lt;a,a&gt; rel){
    this.x=x;
    this.rel = rel;
  }
    
  boolean condition(a y){
    return !rel.lessEqual(y,x);
  }
}</pre>

Damit haben wir alle Bausteine zur Hand, mit denen ein &uuml;ber die
Ordungsrelation parameterisierte Sortiermethode geschrieben werden
kann:<pre>  Li&lt;a&gt; sortBy(Relation&lt;a,a&gt;  rel){
    Li&lt;a&gt; result = new Li&lt;a&gt;();
    if (!isEmpty()){ 
      FilterCondition&lt;a&gt; le
       = new OrderingCondition&lt;a&gt;(head(),rel);
      FilterCondition &lt;a&gt; gr
       = new NegativeOrderingCondition&lt;a&gt;(head(),rel);
      result = tail()
                .filter(le)
                .sortBy(rel)
                .append(new Li&lt;a&gt;(head()
                                 ,tail()
                                 .filter(gr)
                                 .sortBy(rel)));
    }
    return result;
  }
}</pre>

Beim Aufruf der Methode sortBy ist ein Objekt mitzugeben,
das die Relation angibt, nach der sortiert werden soll. 
Im folgenden
Beispiel werden Strings einmal nach ihrer lexikographischen Ordnung,
einmal nach ihrer L&auml;nge sortiert: <pre>package name.panitz.data.list;
class StringLengthLessEqual extends Relation&lt;String,String&gt; {
  boolean lessEqual(String x,String y){
    return x.length()&lt;= y.length();
  }
}</pre>

In der Testmethode k&ouml;nnen wir die Methode sortBy jeweils mit einer
der Bedingungen aufrufen:<pre>package name.panitz.data.list;
class TestSortBy{
  public static void main(String [] args){
    Li&lt;String&gt; xs = TestFilter.XS;

    System.out.println("Die unsortierte Liste:");
    System.out.println(xs);
    System.out.println("Die alphabetisch sortierte Liste:");
    System.out.println(xs.sortBy(new StringLessEqual()));
    System.out.println("Die nach der L&auml;nge sortierte Liste:");
    System.out.println(xs.sortBy(new StringLengthLessEqual()));
  }
}</pre> Und tats&auml;chlich k&ouml;nnen wir jetzt die Sortiermethode benutzen, um nach
unterschiedlichen Kriterien zu sortieren:sep@linux:~/fh/prog1/examples/classes&gt; java TestSortBy
Die unsortierte Liste:
(Shakespeare,Brecht,Achternbusch,Calderon,Moliere,Sorokin,Schimmelpfennig,Kane,Wilde)
Die alphabetisch sortierte Liste:
(Achternbusch,Brecht,Calderon,Kane,Moliere,Schimmelpfennig,Shakespeare,Sorokin,Wilde)
Die nach der L&auml;nge sortierte Liste:
(Kane,Wilde,Brecht,Moliere,Sorokin,Calderon,Shakespeare,Achternbusch,Schimmelpfennig)
sep@linux:~/fh/prog1/examples/classes&gt;
Verfolgen Sie schrittweise mit Papier und Beistift, wie 
der quicksort Algorithmus die folgenden zwei Listen sortiert:
                
                  ("a","b","c","d","e")
                
                
                  ("c","a","b","d","e")
                
              
Diese Aufgabe soll mir helfen, Listen f&uuml;r Ihre Leistungsbewertung zu
erzeugen. 
                Implementieren Sie f&uuml;r Ihre Listenklasse eine 
Methode String toHtmlTable(), die f&uuml;r Listen Html-Code f&uuml;r
eine Tabelle erzeugt, z.B:<pre>&lt;table&gt;
  &lt;tr&gt;erstes Listenelement&lt;/tr&gt;
  &lt;tr&gt;zweites Listenelement&lt;/tr&gt;
  &lt;tr&gt;drittes Listenelement&lt;/tr&gt;
&lt;/table&gt;</pre>
                Nehmen Sie die Klasse Student, die
Felder f&uuml;r Namen, Vornamen und Matrikelnummer hat. Implementieren
Sie f&uuml;r diese Klasse  eine Methode String toTableRow(), die
f&uuml;r Studenten eine Zeile einer Html-Tabelle erzeugt:<pre>Student s1 = new Student("M&uuml;ller","Hans",167857);
System.out.println(s1.toTableRow());</pre> 
soll folgende Ausgabe ergeben:<pre>&lt;td&gt;M&uuml;ller&lt;/td&gt;&lt;td&gt;Hans&lt;/td&gt;&lt;td&gt;167857&lt;/td&gt;</pre>
&Auml;ndern Sie die Methode toString so, da&szlig; sie dasselbe Ergebnis wie die
neue Methode toTableRow hat.
                Legen Sie eine Liste von Studenten an, sortieren Sie diese 
mit Hilfe der Methode sortBynach
Nachnamen und Vornamen und erzeugen Sie eine Html-Seite, die die
sortierte Liste anzeigt.
Sie k&ouml;nnen zum Testen die folgende Klasse benutzen:<pre>package name.panitz.data.list;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.plaf.basic.*; 
import javax.swing.text.*; 
import javax.swing.text.html.*; 

public class HtmlView extends JPanel {

  //example invocation
  public static void main(String s[]) {
    HtmlView view = new HtmlView();
    view.run();
    view.setText("&lt;h1&gt;hallo&lt;/h1&gt;");
  }

  JFrame frame;
  JTextPane ausgabe = new JTextPane();

  public HtmlView() {
    ausgabe.setEditorKit(new HTMLEditorKit());
    add(ausgabe);	
  }

  void setText(String htmlString){
    ausgabe.setText(htmlString);
    frame.pack();
    ausgabe.repaint();
  }

  void run(){
    frame = new JFrame("HtmlView");
    frame.getContentPane().add(this);
    frame.pack();
    frame.setVisible(true);
  }
}</pre>
              
<h3>6.1.6. Formale Beweise &uuml;ber Listenalgorithmen</h3>
<h4>6.1.6.1. Vollst&auml;ndige Induktion</h4>nn<h4>6.1.6.2. Induktion &uuml;ber Listen</h4>0Cons(x,xs)xs
Als Beispiel wollen wir eine Eigenschaft &uuml;ber Listen im Zusammenhang mit den
Funktionen concat und length beweisen. Wir wollen beweisen,
da&szlig; die L&auml;nge der Konkatenation zweier Listen gleich der Summe der L&auml;ngen der beiden Listen ist, also da&szlig; f&uuml;r alle Listen xs und ys gilt:length(concat(xs,ys))  length(xs) + length(ys)

Dabei seien die beiden Funktionen wieder spezifiziert als:
length(Empty())0
length(Cons(x,xs))1+length(xs)

und
concat(Empty(),ys)ys
concat(Cons(x,xs),ys)Cons(x,concat(xs,ys))


Wir werden die Aussage beweisen mit einer Induktion &uuml;ber das erste Argument der Funktion concat, also dem xs:
              Induktionsanfang: Wir versuchen, die Aussage zu beweisen mit xs=Empty(). Wir erhalten
die folgende Aussage:length(concat(Empty(),ys))  length(Empty()) + length(ys)
Wir k&ouml;nnen jetzt auf beiden Seiten der Gleichung durch Reduktion mit den Gleichungen aus der Spezifikation die Gleichung vereinfachen:
length(concat(Empty(),ys))  length(Empty()) + length(ys)
length(ys)  length(Empty()) + length(ys)
length(ys)  0 + length(ys)
length(ys)  length(ys)

Wir haben die Aussage auf eine Tautologie reduziert. F&uuml;r xs als leere
Liste ist damit unsere Aussage bereits bewiesen.
              Induktionsschritt: Jetzt wollen wir die Aussage  f&uuml;r xs=Cons(x',xs') beweisen, wobei wir als
Induktionsvoraussetzung annehmen, da&szlig; sie f&uuml;r xs' bereits wahr ist, da&szlig; also
gilt:length(concat(xs',ys))  length(xs') + length(ys)

Hierzu stellen wir die zu beweisende Gleichug auf und reduzieren sie auf
beiden Seiten:
length(concat(Cons(x',xs'),ys))  length(Cons(x',xs')) + length(ys)
length(Cons(x',concat(xs',ys)))  length(Cons(x',xs')) + length(ys)
1+length(concat(xs',ys))  1+length(xs') + length(ys)
length(concat(xs',ys)) length(xs') + length(ys)

Die letzte Gleichung ist gerade die Induktionsvoraussetzung, von der wir
angenommen haben, da&szlig; diese bereits wahr ist. Wir haben unsere Aussage f&uuml;r
alle endlichen Listen bewiesen.
            <h2>6.2. B&auml;ume</h2>
        Dateisystem: Ein g&auml;ngiges Dateisystem, wie es aus Unix,
MacOS und Windows bekannt ist, stellt eine Baumstruktur dar. Es gibt
einen ausgezeichneten Wurzelordner, von dem aus zu jeder Datei einen
Pfad existiert.
        Klassenhierarchie: Die Klassen in Java stellen mit ihrer
Ableitungsrelation eine Baumstruktur dar. Die 
Klasse Object ist die Wurzel dieses Baumes, von der aus alle
anderen Klassen &uuml;ber einen Pfad entlang der Ableitungsrelation
erreicht werden k&ouml;nnen. 
        XML: Die logische Struktur eines XML-Dokuments ist ein
Baum. Die Kinder eines Elements sind jeweils die Elemente, die durch
das Element eigeschlossen sind.
        Parserergebnisse: Ein Parser, der gem&auml;&szlig; einer Grammatik
pr&uuml;ft, ob ein bestimmter Satz zu einer Sprache geh&ouml;rt, erzeugt im
Erfolgsfall eine Baumstruktur. Im n&auml;chsten Kapitel werden wir dieses
im Detail kennenlernen.
        Listen: Auch Listen sind B&auml;ume, allerdings eine besondere
Art, in denen jeder Knoten nur maximal ein Kind hat.
        Berechnungsb&auml;ume: Zur statischen Analyse von Programmen,
stellt man B&auml;ume auf, in denen die Alternativen eines bedingten
Ausdrucks  Verzweigungen im
Baum darstellen.
        Tableaukalk&uuml;l: Der Tableaukalk&uuml;l ist ein Verfahren zum
Beweis logischer Formeln. Die dabei verwendeten Tableaux sind
B&auml;ume.
        Spielb&auml;ume: Alle m&ouml;glichen Spielverl&auml;ufe eines Spiels
k&ouml;nnen als Baum dargestellt werden. Die Kanten entsprechen dabei einem
Spielzug.
        Prozesse: Auch die Prozesse eines Betriebssystems stellen eine
Baumstruktur dar. Die Kinder eines Prozesses sind genau die Prozesse, die von
ihm gestartet wurden.
      <h3>6.2.1. Formale Spezifikation</h3>
<h4>6.2.1.1. Allgemeine B&auml;ume</h4>
Abstrakte Datentypen lassen sich  durch
ihre Konstruktoren spezifizieren. Die
Konstruktoren geben an, wie Daten des entsprechenden Typs konstruiert
werden k&ouml;nnen. 

In dem Fall von B&auml;umen bedarf es nach
den obigen &Uuml;berlegungen nur eines Konstruktors, den f&uuml;r Knoten. Er
konstruiert aus der Liste der Kinderb&auml;ume einen neuen Baumknoten.
Als zus&auml;tzliches Argument bekommt er ein Objekt, das eine Markierung
f&uuml;r den Baumknoten darstellt. Den Typ dieses Markierungsobjektes k&ouml;nnen wir
erst einmal offen lassen. Hier darf ein beliebiger Typ gew&auml;hlt werden. 
Wir benutzen in der Spezifikation eine mathematische Notation der
Typen von Konstruktoren.Entgegen der Notation in Java, in der
der R&uuml;ckgabetyp kurioser Weise vor den Namen der Methode geschrieben
wird. Dem Namen des Konstruktors folgt dabei mit einem
Doppelpunkt abgetrennt der Typ. Der Ergebnistyp wird von den
Parametertypen mit einem Pfeil getrennt.
Somit l&auml;&szlig;t sich der Typ des Konstruktors f&uuml;r B&auml;ume wie
folgt spezifizieren:
              Node: (
                  
                ,List&lt;Tree&lt;
                  
                &gt;&gt;) Tree&lt;
                  
                &gt;
            

Die Selektoren k&ouml;nnen wieder auf die einzelnen
Bestandteile der Konstruktion zur&uuml;ckgreifen. 
Der Konstruktor Node hat zwei Parameter. 
F&uuml;r B&auml;ume
werden zwei
Selektoren spezifiziert, die jeweils einen dieser beiden Parameter
wieder aus dem Baum selektieren. 
              theChildren: Tree&lt;
                  
                &gt;List&lt;Tree&lt;
                  
                &gt;&gt;
              mark: Tree&lt;
                  
                &gt;
                  
                
            

Der funktionale Zusammenhang von den Selektoren und Konstruktoren l&auml;&szlig;t
sich durch folgende Gleichungen spezifizieren:mark(Node(x,xs)) = xtheChildren(Node(x,xs)) = xs
Da wir nur einen Konstruktor vorgesehen haben, brauchen wir keine
Testmethode, die unterscheidet, mit welchem Konstruktor ein Baum
konstruiert wurde. 
Die Unterscheidung, ob es sich um ein Blatt oder um
einen Knoten mit Kindern handelt, l&auml;&szlig;t sich &uuml;ber die Abfrage, ob die
Liste der Kinderknoten leer ist, erfahren. Wir k&ouml;nnen eine
entsprechende Funktion spezifizieren:isLeaf(Node(x,xs)) = isEmpty(xs)<h3>6.2.2. Modellierung</h3>
<h4>6.2.2.1. mit einer Klasse</h4>
<h4>6.2.2.2. Mit einer Klassenhierarchie</h4>
            Wenn zu erwarten ist, da&szlig; im Laufe der Softwareentwicklung
  noch weitere Konstruktoren zum abstrakten Datentyp hinzudefiniert
  werden, dann ist eine Modellierung als Hierarchie vorteilhaft. Der
  neue Konstruktor f&uuml;hrt zu einer neuen Klasse, in der lokale Version
  der f&uuml;r die implementierte Schnittstelle ben&ouml;tigten Methoden
  implementiert werden.
            
    Wenn zu erwarten ist, da&szlig; spezialisierte Versionen des abstrakten
    Datentyps ben&ouml;tigt werden, so ist eine Modellierung als eine
    Klasse vorteilhaft, weil dann f&uuml;r dieser einen Klassen eine
    Unterklasse implementiert werden kann.
  
          <h3>6.2.3. Implementierung</h3>Tree
          Tree(List children): als Knotenmarkierung 
wird  null genommen.
          Tree(a mark): f&uuml;r die Kinder wird eine leere Liste
erzeugt.
        <pre>package name.panitz.data.tree;

import java.util.List;
import java.util.Iterator;
import java.util.Enumeration;
import java.util.ArrayList;
import javax.swing.tree.TreeNode; 

public class Tree&lt;a&gt; implements TreeNode{

  private a mrk;  
  private List&lt;Tree&lt;a&gt;&gt; chldrn;</pre>
<pre>  public Tree(a mark,List&lt;Tree&lt;a&gt;&gt; children){
    this.mrk=mark;
    this.chldrn=children;
  }</pre>
<pre>  public Tree(List&lt;Tree&lt;a&gt;&gt; children){
    this(null,children);
  }

  public Tree(a mark){
    this(mark,new ArrayList&lt;Tree&lt;a&gt;&gt;());
  }


  public List&lt;Tree&lt;a&gt;&gt; theChildren(){return chldrn;}
  public a mark(){return mrk;}

  public boolean isLeaf(){return theChildren().isEmpty();}
</pre>Erzeugen Sie ein Baumobjekt, das einen Stammbaum Ihrer
Familie darstellt. Die Knoten und Bl&auml;tter sind mit Namen markiert. Die
Wurzel ist mit Ihren Namen markiert. 
Kinderknoten sind mit den leiblichen Eltern der 
Person eines Knotens markiert.<h2>6.3. Algorithmen auf B&auml;umen</h2>
<h3>6.3.1. Knotenanzahl</h3>length<pre>public int count(){
  int result = 1; // Startwert 1 f&uuml;r diesen Knoten

  //f&uuml;r jedes Kind
  for (Tree&lt;a&gt; child: theChildren())
    //addiere die Knotenanzahl des Kindes zum Ergebnis 
    result=result+child.count();

  return result;
}</pre>for-Schleifeforif (theChildren().isEmpty()) return 1<h3>6.3.2. toString</h3>toStringtoString<pre>public String toString(){
  //Nimm erst die Markierung an diesem Knoten
  String result = mark().toString();
  
  //Gibt es keine Kinder, dann bist du fertig
  if (isLeaf()) return result;

  //ansonsten nimm implizit durch Operator + das 
  //toString() der Kinder
  return result+theChildren();
}</pre>result+theChildren()toString()toStringtoStringTreetoStringListToStringTreeverschr&auml;nkter<h3>6.3.3. Linearisieren</h3>flatten<pre>public List&lt;a&gt; flatten(){
  //leere Liste f&uuml;r das Ergebnis
  List&lt;a&gt; result = new ArrayList&lt;a&gt;();

  //f&uuml;ge die Markierung dieses Knotens zur 
  //Ergebnisliste hinzu
  result.add(mark());

  //f&uuml;r jedes Kind
  for (Tree&lt;a&gt; child : theChildren())
    //erzeuge dessen Knotenliste und f&uuml;ge alle deren 
    //Elemente zum Ergebnis hinzu
    result.addAll(child.flatten());

  return result;
}</pre>ArrayListaddAllListTesten Sie die in diesem Abschnitt entwickelten Methoden auf
B&auml;umen mit dem in der letzten Aufgabe erzeugten Baumobjekt. 
Schreiben Sie die folgenden weiteren Methoden f&uuml;r die 
Klasse Tree. Schreiben Sie Tests f&uuml;r diese Methoden.
          List leaves(): erzeugt eine Liste der Markierungen an den
Bl&auml;ttern des Baumes.
          String show(): erzeugt eine textuelle Darstellung des
Baumes. Jeder Knoten soll eine eigene Zeile haben. Kinderknoten sollen
gegen&uuml;ber einem Elternknoten einger&uuml;ckt sein.
Beispiel:william
  charles
    elizabeth
    phillip
  diana
    spencerTipp: Benutzen Sie eine HilfsmethodeString showAux(String prefix),
die den String prefix vor den erzeugten Zeichenketten anh&auml;ngt.
          boolean contains(a o): ist wahr, wenn eine
Knotenmarkierung gleich dem Objekt o ist.
          int maxDepth(): gibt die L&auml;nge des l&auml;ngsten Pfades von
der Wurzel zu einem Blatt an.
          List&lt;a&gt; getPath(a o): gibt die Markierungen auf dem
Pfad von der Wurzel zu dem Knoten, der mit dem Objekt o
markiert ist, zur&uuml;ck. Ergebnis ist eine leere Liste, wenn ein 
Objekt gleich o nicht existiert.
          java.util.Iterator&lt;a&gt; iterator(): erzeugt ein Iterator
&uuml;ber alle Knotenmarkierungen des Baumes.Tipp: Benutzen Sie bei der Umsetzung die Methode flatten.
          public boolean equals(Object other): soll genau dann
wahr sein, wenn other ein Baum ist, der die gleiche Struktur und
die gleichen Markierungen hat.
          &lt;b&gt;boolean sameStructure(Tree&lt;a&gt; other): soll genau dann wahr
sein, wenn der Baum other die gleiche Struktur hat. Die
Markierungen der Knoten k&ouml;nnen hingegen unterschiedlich sein.
        <h3>6.3.4. L&ouml;sung</h3>
<h4>6.3.4.1. leaves</h4>List leaves()leavesflatten<pre>public List&lt;a&gt; leaves(){
  //leere Liste f&uuml;r das Ergebnis
  List&lt;a&gt; result = new ArrayList&lt;a&gt;();

  //f&uuml;ge die Markierung dieses Knotens zur Ergebnisliste 
  //nur hinzu, wenn es ein Blatt ist
  if (isLeaf()) result.add(mark());

  //f&uuml;r jedes Kind
  for (Tree&lt;a&gt; child:theChildren())
    //erzeuge dessen Knotenliste und f&uuml;ge alle deren Bl&auml;tter 
    //zum Ergebnis hinzu
    result.addAll(child.leaves());

  return result;
}</pre>flattenleaves
Wir haben uns bisher noch keine Gedanken um die Performanz unserer
Methoden gemacht. Wenn wir die die 
Methoden flatten und leaves einmal genau betrachten, 
so stellen
wir fest, da&szlig; jeder Aufruf der Methode eine neue Ergebnisliste
erzeugt. Das bedeutet, da&szlig; die 
Methoden flatten und leaves durch die
rekursiven Aufrufe, soviel Listen erzeugt, wie Knoten im Baum sind. Mit dem
Aufruf der Methode addAll auf Listen, werden die Elemente
einer Liste in eine neue Liste eingetragen. Wir sind aber nur an einer
einzigen Liste interessiert, der endg&uuml;ltigen Ergebnisliste. 

Es w&auml;re also sch&ouml;n, wenn wir eine Methode flatten h&auml;tten, 
die nicht eine neue Liste erzeugt, sondern eine bestehende Liste
benutzt, um dort weitere Elemente einzuf&uuml;gen. Wir k&ouml;nnen hierzu der
Methode einen Listenparameter geben, in dem die Ergebnisse zu sammeln
sind. <pre>public List&lt;a&gt; flatten(List&lt;a&gt; result){
  result.add(mark());

  for (Tree&lt;a&gt; child:theChildren())
    child.flatten(result);

  return result;
}</pre>
Die eigentliche Methode flatten kann jetzt einmal das Objekt
f&uuml;r die Ergebnisliste erzeugen, und dann diese jeweils weitereichen,
um das Erzeugen neuer Listen und das umkopieren der Elemente von einer
Liste in eine andere zu verhindern.<pre>public List&lt;a&gt; flattenAkk(){
  return flatten(new ArrayList&lt;a&gt;());
}</pre>

Und entsprechend k&ouml;nnen wir die Methode leaves auch
umschreiben, so da&szlig; sie nicht f&uuml;r jeden rekursiven Aufruf ein neues
Listenobjekt erzeugt:<pre>public List&lt;a&gt; leaves(List&lt;a&gt; result){
  if (isLeaf()) result.add(mark());

  for (Tree&lt;a&gt; child:theChildren())
    child.leaves(result);

  return result;
}

public List&lt;a&gt; leavesAkk(){
  return leaves(new ArrayList&lt;a&gt;());
}</pre>

Dieses Prinzip, ein Ergebnis in einem Parameter nach und nach
zusammenzusammeln nennt man Akkumulation. Der Parameter, in
dem das Ergebnis jeweils hinzugef&uuml;gt wird, ist der Akkumulator. Mit
Hilfe des Befehls time auf der Unix-Shell, l&auml;&szlig;t sich sogar 
ungef&auml;hr messen,
da&szlig; die akkumulierende Methode schneller abgearbeitet wird.
Wir haben im letztem Abschnitt bereits beobachten k&ouml;nnen, da&szlig; die
Methoden flatten und leaves fast identischen Code
haben. Beide selektieren aus einem Baum bestimmte Baummarkierungen
heraus. Das einzige was sie unterscheidet, ist die Bedingung, die
steuert, ob eine Knotenmarkierung zu selektieren ist oder
nicht. Ansonsten haben wir Code verdoppelt. 

Unser Bestreben ist stets eine Codeverdoppelung zu vermeiden, denn
verdoppelter Code ist auch doppelt zu pflegen und zu warten. 
Das haben wir sogar schon festgestellt, als wir auf die akkumulative
L&ouml;sung der beiden Methoden gekommen sind. Da haben wir beide Methoden
ge&auml;ndert, um f&uuml;r sie die akkumulative L&ouml;sung einzuf&uuml;hren.

Wir
k&ouml;nnen eine Methode schreiben, die den gemeinsamen Code der beiden
Methoden enth&auml;lt. Das
einzige, was die beiden Methoden unterscheidet ist eine
Bedingung. Diese Bedingung ist eine Pr&uuml;fung auf die Baumknoten. Die
gemeinsame Methode mu&szlig; diese Bedingung als Parameter &uuml;bergeben
bekommen. Eine Pr&uuml;fung ist eine Methode. Wir k&ouml;nnen in Java keine
Methoden direkt als Parameter &uuml;bergeben, sondern nur Objekte. Wir
definieren daher eine Schnittstelle, die beschreibt, da&szlig; ein Objekt
eine Pr&uuml;fmethoden enth&auml;lt.<pre>package name.panitz.data.tree;

public interface TreeCondition&lt;a&gt;{
  boolean takeThis(Tree&lt;a&gt; o);
}</pre>  

Mit dieser Schnittstelle sind wir jetzt in der Lage eine Bedingung auf
Baumknoten auszudr&uuml;cken. Wir k&ouml;nnen damit eine allgemeine
Filtermethode schreiben, die Knoten mit einer bestimmten Bedingung aus
einem Baum selektiert. Die Methode filter ist die
Verallgemeinerung die Methoden leaves und flatten.
Wir verallgemeinern die akkumulative L&ouml;sung.<pre>public List&lt;a&gt; filter(List&lt;a&gt; result,TreeCondition&lt;a&gt; c){
  //wenn die Bedingung f&uuml;r den Knoten wahr ist, f&uuml;ge
  //ihm dem Ergebnis hinzu
  if (c.takeThis(this)) result.add(mark());

  //f&uuml;r alle Kinder
  for (Tree&lt;a&gt; child:theChildren())
    //rufe den Filter mit gleicher Bedingung auf
    child.filter(result,c);
  
  return result;
}</pre>

Die akkumulative Methode kann noch wie gewohnt gekapselt werden:<pre>public List&lt;a&gt; filter(TreeCondition&lt;a&gt; c){
  return filter(new ArrayList&lt;a&gt;(),c);
}</pre>


Jetzt haben wir eine Methode geschrieben, die einmal durch einen Baum
l&auml;uft und Knoten aufgrund einer Bedingung in einer Ergebnisliste
sammelt. Wir k&ouml;nnen jetzt die 
Methoden leaves und flatten &uuml;ber diese Methode ausdr&uuml;cken:leaves ist ein Filter mit der Bedingung, da&szlig; die Baumknoten
ein Blatt ist. Wir erzeugen das Bedingungsobjekt als anonyme innere Klasse:<pre>public List leavesFilter(){
  return filter(
     new TreeCondition&lt;a&gt;(){
        public boolean takeThis(Tree&lt;a&gt; t){
          return t.isLeaf();
        }
     });
}</pre>flatten ist ein Filter mit der Bedingung die immer wahr
ist. Also erzeugen wir eine Baumbedingung, die 
konstant true als Ergebnis liefert:<pre>public List&lt;a&gt; flattenFilter(){
  return filter(new TreeCondition&lt;a&gt;(){
                  public boolean takeThis(Tree&lt;a&gt; _){return true;}
                });
}</pre>


Entsprechend k&ouml;nnen wir jetzt beliebige Bedingungen benutzen, um
Knoten aus dem Baum zu selektieren; z.B. alle Knoten
mit genau zwei Kindern:<pre>public List&lt;a&gt; nodesWithTwoChildren(){
  return filter(new TreeCondition&lt;a&gt;(){
                  public boolean takeThis(Tree&lt;a&gt; t){
                    return t.theChildren().size()==2;
                  }
                });
}</pre>

Oder Knoten, die mit einem bestimmten Objekt markiert sind:<pre>public List&lt;a&gt; nodesMarkedWith(final a o){
  return filter(new TreeCondition&lt;a&gt;(){
                  public boolean takeThis(Tree&lt;a&gt; t){
                    return t.mark().equals(o);
                  }
                });
}</pre>


Letztere Methode kann sogar genutzt werden, um zu entscheiden, ob ein
Objekt in einem Baum enthalten ist.<pre>public boolean containsFilter(a o){
  return !nodesMarkedWith(o).isEmpty();
}</pre>


Das in dieser L&ouml;sung vorgestellte Prinzip, da&szlig; quasi eine Methode als
Parameter an eine andere Methode &uuml;bergeben wird, 
hei&szlig;t Programmierung h&ouml;herer Ordnung. Java unterst&uuml;tzt dieses
Konzept nur rudiment&auml;r, weil zum &Uuml;bergeben einer Methode als Parameter
erst ein Objekt erzeugt werden mu&szlig;. In Sprachen wie C kann dieses
Programmierprinzip &uuml;ber Funktionszeiger realisiert werden. In Sprachen
der Lisp-Tradition ist die &Uuml;bergabe von Methoden als
Parameter ein fundamentaler Bestandteil. Mit Hilfe der Programmierung
h&ouml;herer Ordnung hat man ein sehr m&auml;chtiges Ausdrucksmittel.<h4>6.3.4.2. show</h4>String show()<pre>  public String show(String indent){
    //zeige diesen Knoten mit Einr&uuml;ckung
    String result = indent+mark();

    //erh&ouml;he die Einr&uuml;ckung
    indent=indent+"  ";

    //f&uuml;r jedes Kind
    for (Tree&lt;a&gt; child:theChildren())
     //erzeuge neue Zeile und zeige Kind mit neuer Einr&uuml;ckung
      result=result+"\n"+child.show(indent);
    
    return result;
  }</pre>
<pre>  public String show(){
      return show("");
  }</pre>
Auch f&uuml;r die Methode show k&ouml;nnen wir eine akkumulative L&ouml;sung
schreiben. Der Grund, weshalb dieses sinnvoll ist, ist in der Technik
von der Stringumsetzung in Java versteckt. Der &Uuml;belt&auml;ter ist hierbei
der Operator + auf String. Dieser Operator h&auml;ngt
nicht einen String an einen anderen String an,
sondern kopiert beide in einen neuen String. Jede Anwendung
des Operators + kopiert also String-Objekte; und wir
wenden den Operator oft an, um unser Ergebnis zu berechnen.

Java stellt eine Klasse zur Verf&uuml;gung mit der String-Objekte
akkumuliert werden k&ouml;nnen, und Kopiervorg&auml;nge weitgehendst vermieden
werden: die Klasse StringBuffer.

Objekte der Klasse StringBuffer k&ouml;nnen mit der 
Methode append weitere String-Objekte angeh&auml;ngt
werden. Sie wird benutzt, wenn ein String erst nach und nach 
zusammengebaut wird.

&Auml;hnlich wie bei der Akkumulation eines Listenergebnisses k&ouml;nnen wir
mit StringBuffer eine Zeichenkette akkumulieren. Hierzu geben
wir in einem Parameter einen StringBuffer als Akkumulator
mit. Wie im Listenfall mit der Methode add benutzen wir die
Methode append zum Aufsammeln der Ergebnisteile:<pre>  public StringBuffer show(String indent,StringBuffer result){
    //zeige diesen Knoten mit Einr&uuml;ckung
    result.append(indent);
    result.append(mark().toString());

    //erh&ouml;he die Einr&uuml;ckung
    indent=indent+"  ";

    //f&uuml;r jedes Kind
    for (Tree&lt;a&gt; child:theChildren()){
     //erzeuge neue Zeile und zeige Kind mit neuer Einr&uuml;ckung
      result.append("\n");
      child.show(indent,result);
    }
    return result;
  }</pre>

Die kapselnde Methode, erzeugt einen 
neuen StringBuffer, l&auml;&szlig;t diesen akkumulieren und gibt
schlie&szlig;lich den in ihm enthaltenen String als Ergebnis aus. <pre>  public String showAkk(){
      return show("",new StringBuffer()).toString();
  }</pre>
<h4>6.3.4.3. contains</h4>boolean contains(a o)ofiltercontainsrepresenting
failure by a list of successescontains<pre>  public boolean contains(a o){
    //bin ich schon der gesuchte Knoten? Wenn ja ende mit erfolg
    if (mark().equals(o)) return true;

    //f&uuml;r jedes Kind
   for (Tree&lt;a&gt; child:theChildren()){
      //wenn es den Knoten enth&auml;lt, beende mit erfolg
      if (child.contains(o)) return true;
    }
    //keiner der Knoten enthielt das Objekt
    return false;
  }</pre>
<h4>6.3.4.4. maxDepth</h4>int maxDepth()<pre>  public int maxDepth(){
    //anfangstiefe
    int result = 0;

    //f&uuml;r jedes Kind
   for (Tree&lt;a&gt; child:theChildren()){
      //berechne seine maximale Tiefe
      int n = child.maxDepth();

      //ist sie h&ouml;her als die bisher gefundene, dann nimm diese
      if (n&gt;result) result=n;
    } 

    //erh&ouml;he Ergebnis um eins f&uuml;r die Wurzel
    return result+1;
  }</pre>
<h4>6.3.4.5. getPath</h4>List getPath(Object o)oo
Fast alle Studenten haben eine L&ouml;sung entwickelt, in der die Aufgabe mit
Hilfe der Mehode contains realisiert wird. Jeder Knoten, der auf
dem Pfad zu dem fraglichen Objekt liegt, enth&auml;lt diesen Knoten. Es
wird eine Ergebnisliste aufgebaut, die genau die Knoten enth&auml;lt, deren
B&auml;ume den fraglichen Knoten enthalten:<pre>  public List&lt;a&gt; getPathBad(a o){
    List&lt;a&gt; result = new ArrayList&lt;a&gt;();

  //wenn Du irgendwo das Objekt enth&auml;ltst, liegst Du auf den Pfad
    if (contains(o)) { result.add(mark());}

    //f&uuml;r jedes Kind
   for (Tree&lt;a&gt; child:theChildren()){
      //f&uuml;ge den Pfad zum fraglichen Objekt hinzu
      result.addAll(child.getPathBad(o));
    }
    return result;
  }</pre>
Die obige L&ouml;sung ist wieder von der Art: selektiere alle Knoten mit
einer bestimmten Eigenschaft aus den Baum. Die Eigenschaft ist keine
lokal den Knoten betreffende Eigenschaft, sondern die Tatsache, da&szlig;
der Teilbaum das Objekt enth&auml;lt. Wir k&ouml;nnen also auch f&uuml;r diese
Aufgabe die Methode filter anwenden.<pre>public List&lt;a&gt; getPathFilter(final a o){
   return filter(
      new TreeCondition&lt;a&gt;(){
        public boolean takeThis(Tree&lt;a&gt; e){
          return e.contains(o);
        }  
      }
   );
}</pre>


Sp&auml;testens jetzt merkt man, was f&uuml;r eine ausdrucksstarke Methode die
Methode filter durch ihren Parameter h&ouml;herer Ordnung ist. 
Beide obigen L&ouml;sungen waren schlecht, wenn wir ihr Laufzeitverhalten
betrachten. Stellen wir uns der Einfachheit halber einen zur Liste
entartetetn Baum mit n Knoten vor. Das einzige Blatt ist
der Knoten, zu dem der Pfad gesucht wird. F&uuml;r jeden Knoten des Baumes
fragen wir, ob er das fragliche Objekt in seinem Teilbaum enth&auml;lt, und
jedesmal durchlaufen wir dabei den Baum bis zu seinem Blatt, weil wir
die Methode contains aufrufen. Wir rufen 
also n-Mal die Methode contains auf, die
jedesmal den Baum bis zum Blatt durchl&auml;uft. Wir durchlaufen 
also n+(n-1)+(n-2)++(n-n)Baumknoten, was nach der 
Summenformel \frac{n * (n+1)}{2} ist.

Damit haben wir einen quadratischen Aufwand in Abh&auml;ngigkeit von der
Tiefe des gesuchten Pfades. Quadratische Aufw&auml;nde sind unbedingt zu
vermeiden, weil mit zunehmender Datengr&ouml;&szlig;e die Laufzeit eines
Algorithmus enorm schnell zunimmt.


Wir k&ouml;nnen mit einem kleinen Trick, auf die Benutzung der 
Methode contains verzichten. Hierzu erinnern wir uns an das
Prinzip, einen Fehlschlag durch eine leere Liste zu
charakterisieren. Wir fragen einfach jedes Kind nach seinem Pfad zu
dem bewu&szlig;ten Objekt. Wenn diese Pfad leer ist, so enth&auml;lt das Kind
diesen Knoten nicht. Sobald ein Kind uns einen nichtleeren Pfad gibt,
benutzen wir die &uuml;berladene Methode add der
Listenschnittstelle, die uns erlaubt, ein Element an eine beliebige
Stelle einer Liste einzuf&uuml;gen. 
 <pre>  public List&lt;a&gt; getPath(a o,List&lt;a&gt; result){
    //bist Du selbst der Knoten, 
    //dann ende mit der einelementigen Liste
    if (mark().equals(o)) { result.add(mark()); return result;}

   for (Tree&lt;a&gt; child:theChildren()){
      //berechne Pfad vom Kind zum Objekt 
      final List&lt;a&gt; path = child.getPath(o,result);

      //Kind hat einen solchen Pfad
      if (!path.isEmpty()){
        //h&auml;nge Dich vorne dran
        result.add(0,mark());
        //und fertig
        return result;
      }
    }
    return result;
  }</pre>

Da wir oben die akkumulative Methode geschrieben haben, ben&ouml;tigen wir
noch eine kapselnde Methode, in der die Ergebnisliste erzeugt wird:<pre>  public List&lt;a&gt; getPath(a o){
      return getPath(o,new ArrayList&lt;a&gt;());
  }</pre>
<h4>6.3.4.6. iterator</h4>java.util.Iterator iterator()flatten<pre>  public Iterator&lt;a&gt; iterator(){
      return flatten().iterator();  
  }</pre>
<h4>6.3.4.7. sameStructure</h4>boolean sameStructure(Tree other)other<pre>  public &lt;b&gt; boolean sameStructure(Tree&lt;b&gt; other){
    //haben beide B&auml;ume gleich viel Kinder. 
    if(this.theChildren().size()!=other.theChildren().size())
        //wenn nein, dann sind sie nicht strukturgleich
        return false;

    //Iteriere &uuml;ber die Kinder beider B&auml;ume
    Iterator&lt;Tree&lt;a&gt;&gt; it1=this.theChildren().iterator();
    Iterator&lt;Tree&lt;b&gt;&gt; it2=other.theChildren().iterator();

    //solange es noch Kinder gibt
    while (it1.hasNext()){
      //hohle das n&auml;chste Kind beider B&auml;ume
      final Tree&lt;a&gt; thisChild = it1.next();
      final Tree&lt;b&gt; otherChild =it2.next();

      //sind diese nicht strukturgleich, dann breche ab
      if (!thisChild.sameStructure(otherChild)) return false;
    }
    
    //die Strukturgleichheit wurde nie verletzt
    return true;
  }</pre>
<h4>6.3.4.8. equals</h4>public boolean equals(Object other)other<pre>if (!this.mark().equals(other.mark())) return false;</pre>
<pre>  public &lt;b&gt; boolean equals(Tree&lt;b&gt; other){
      if (!this.sameStructure(other)) return false;
      return this.flatten().equals(other.flatten());
  }</pre>Object<pre>  public boolean equals(Object other){
      if (! (other instanceof Tree)) return false;
      Tree&lt;?&gt; o = (Tree&lt;?&gt;) other;
      return this.equals(o);
  }</pre>
<h3>6.3.5. Eltern und Geschwister</h3>Tree<pre>
  public Tree&lt;a&gt; parent=null;
</pre>null<pre>  public Tree(a mark,List&lt;Tree&lt;a&gt;&gt; children){
    //setze die entsprechenden Felder des Knotens
    this.mrk=mark;
    this.chldrn=children;

    //es gibt noch keinen Elternknoten
    this.parent=null;

    //setze den neuen Knoten als Elternknoten der Kinder
    respectParents();  
  }

 public void respectParents(){
   //f&uuml;r jedes Kind
   for (Tree&lt;a&gt; child:theChildren()){
    // ist dieser Knoten jetzt der Elternknoten
    child.parent=this;
   }
 }</pre>parentSchreiben Sie eine Methode List&lt;Tree&lt;a&gt;&gt; siblings(), 
die die Geschwister eines Knotens
als Liste ausgibt. In dieser Liste der Geschwister soll der Knoten
selbst nicht auftauchen.<h3>6.3.6. Modifizierende Methoden</h3>parentTreeTreevoid<h4>6.3.6.1. addChild</h4>
<pre>public void addChild(Tree&lt;a&gt; newChild){
  List&lt;Tree&lt;a&gt;&gt; chs = theChildren();
  newChild.parent=this;
  chs.add(newChild);
}</pre>addList<h4>6.3.6.2. addLeaf</h4>
<pre>public void addLeaf(a o){addChild(new Tree&lt;a&gt;(o));}</pre>
<h4>6.3.6.3. deleteChild</h4>n<pre>public void deleteChild(int n){
   theChildren().remove(n);    
}</pre>theChildren()chldrn<h4>6.3.6.4. setMark</h4>mrkprivateSet<pre>public void setMark(a mark){mrk=mark;}</pre>
<h4>6.3.6.5. Beispiel: Baumerzeugung mit modifizierenden Methoden</h4>
<pre>package name.panitz.data.tree.example;

import  name.panitz.data.tree.Tree;
public class SkriptTree{
  public static Tree&lt;String&gt; getSkript(){
    Tree&lt;String&gt; skript = new Tree&lt;String&gt;("Programmieren 2");

    Tree&lt;String&gt; kap1=new Tree&lt;String&gt;("Fr&uuml;he und sp&auml;te Bindung");
    Tree&lt;String&gt; kap2   
     = new Tree&lt;String&gt;
        ("Graphische Benutzeroberfl&auml;chen und Graphiken");
    Tree&lt;String&gt; kap3   
     = new Tree&lt;String&gt;("Abstrakte Datentypen");

    skript.addChild(kap1);
    skript.addChild(kap2);
    skript.addChild(kap3);

    kap1.addLeaf("Wiederholung: Das Prinzip der sp&auml;ten Bindung");
    kap1.addLeaf("Keine sp&auml;te Bindung f&uuml;r Felder");
    kap1.addLeaf("Keine Sp&auml;te Bindung f&uuml;r &uuml;berladene Methoden");

    Tree&lt;String&gt; sec2_1   
     = new Tree&lt;String&gt;("Graphische Benutzeroberfl&auml;chen");
    Tree&lt;String&gt; sec2_2   
     = new Tree&lt;String&gt;("Exkurs: verschachtelte Klassen");
    Tree&lt;String&gt; sec2_3   
     =new Tree&lt;String&gt;("Selbstdefinierte graphische Komponenten");
    Tree&lt;String&gt; sec2_4   
     = new Tree&lt;String&gt;("Weitere Komponente und Ereignisse");
    Tree&lt;String&gt; sec2_5   
     = new Tree&lt;String&gt;("Swing und Steuerf&auml;den");

    kap2.addChild(sec2_1);kap2.addChild(sec2_2);
    kap2.addChild(sec2_3);kap2.addChild(sec2_4);
    kap2.addChild(sec2_5);

    Tree&lt;String&gt; sec3_1   
     = new Tree&lt;String&gt;("B&auml;ume");
    Tree&lt;String&gt; sec3_2   
     = new Tree&lt;String&gt;("Algorithmen auf B&auml;umen");
    Tree&lt;String&gt; sec3_3
     = new Tree&lt;String&gt;("Bin&auml;rb&auml;ume");
    Tree&lt;String&gt; sec3_4
     = new Tree&lt;String&gt;("Bin&auml;re Suchb&auml;ume");
    Tree&lt;String&gt; sec3_5
     = new Tree&lt;String&gt;("XML-Dokumente als B&auml;ume");
    Tree&lt;String&gt; sec3_6
     = new Tree&lt;String&gt;("Keller");

    kap3.addChild(sec3_1);kap3.addChild(sec3_2);
    kap3.addChild(sec3_3);kap3.addChild(sec3_4);
    kap3.addChild(sec3_5);kap3.addChild(sec3_6);

    sec2_1.addLeaf("Graphische Komponenten");
    sec2_1.addLeaf("Ereignisbehandlung");
    sec2_1.addLeaf("Setzen des Layouts");

    sec2_2.addLeaf("Innere Klassen");
    sec2_2.addLeaf("Anonyme Klassen");
    sec2_2.addLeaf("Statisch verschachtelte Klassen");

    sec2_3.addLeaf("Graphics Objekte");
    sec2_3.addLeaf("Dimensionen");
    sec2_3.addLeaf("Farben");
    sec2_3.addLeaf("Fonts und ihre Metrik");
    sec2_3.addLeaf("Erzeugen graphischer Dateien");
    sec2_3.addLeaf("Graphics2D");

    sec2_4.addLeaf("Mausereignisse");
    sec2_4.addLeaf("Fensterereignisse");
    sec2_4.addLeaf("Weitere Komponenten");

    sec2_5.addLeaf("Timer in Swing");
    sec2_5.addLeaf
     ("SwingWorker f&uuml;r Steuerf&auml;den in der Ereignisbehandlung");
    return skript;
  }
}</pre>
Schreiben Sie eine modifizierende 
Methodevoid deleteChildNode(int n),die den n-ten 
Kindknoten l&ouml;scht, und stattdessen die Kinder des n-ten Kindknotens
als neue Kinder mit einh&auml;ngt. Beispiel:
                      a
         / \
        /   \
       b     c
      / \   / \
     d   e  f  g
           /|\ 
          h i j
          wird durchdeleteChildNode(1)zu:
                      a
         /|\
        / | \
       /  |  \
      /   |   \
     b    f    g
    /|   /|\
   d e  h i j
          <h2>6.4. Bin&auml;rb&auml;ume</h2>Treenullchildren<pre>package name.panitz.data.tree; 

import java.util.List;
import java.util.ArrayList;

public class BinTree&lt;a&gt; extends Tree&lt;a&gt;{

  //private Felder f&uuml;r rechtes und linkes Kind
  private BinTree&lt;a&gt; rght;
  private BinTree&lt;a&gt; lft;</pre>
<pre>  public BinTree(BinTree&lt;a&gt; left,a mark,BinTree&lt;a&gt; right){
    super(mark);lft=left; rght=right;} 

  public BinTree(a mark){this(null,mark,null);}</pre>
<pre>  public BinTree&lt;a&gt; left(){return lft;}
  public BinTree&lt;a&gt; right(){return rght;}</pre>theChildren<pre>  public List&lt;Tree&lt;a&gt;&gt; theChildren(){
    List&lt;Tree&lt;a&gt;&gt; result = new ArrayList&lt;Tree&lt;a&gt;&gt;();
    if (left()!=null)  result.add(left());
    if (right()!=null) result.add(right());
    return result;
  }</pre>
<h3>6.4.1. Probleme der Klasse BinTree</h3>TreeTreecountflattenTreeBinTreetheChildren()BinTreerghtlftaddChildBinTreeaddLeaf<pre>public void addLeaf(a o){
    throw new UnsupportedOperationException();
}</pre>deleteChild<pre>public void deleteChild(int n){
  if (n==0) lft=null;
  else if (n==1) rght=null;
  else throw new IndexOutOfBoundsException ();
}</pre>
<pre>  void setLeft(BinTree&lt;a&gt; l){ lft=l;}
  void setRight(BinTree&lt;a&gt; r){ rght=r;}</pre>&Uuml;berschreiben Sie die 
Methoden addLeaf und deleteChildNode in
der Klasse BinTree, so da&szlig; sie nur eine Ausnahme werfen,
wenn die Durchf&uuml;hrung der Modifikation dazu f&uuml;hren w&uuml;rde, da&szlig; das
Objekt, auf dem die Methode angewendet wird, anschlie&szlig;end kein
Bin&auml;rbaum mehr w&auml;re.<h3>6.4.2. Linearisieren bin&auml;rer B&auml;ume</h3>Tree<h4>6.4.2.1. Preordnung</h4>flatten<h4>6.4.2.2. Postordnung</h4>
Schreiben Sie analog zur Methode flatten in der 
Klasse Tree eine MethodeList&lt;a&gt; postorder(), die die Knoten eines Baumes in 
Postordnung linearisiert.<h4>6.4.2.3. Inordnung</h4>
<pre>public List&lt;a&gt; inorder(){
  //Ergebnisliste
  List&lt;a&gt; result = new ArrayList&lt;a&gt;();
 
  //gibt es ein linkes Kind, f&uuml;ge dessen 
  //Linearisierung hinzu
  if (left()!=null) result.addAll(left().inorder());

  //dann den Knoten selbst
  result.add(mark());

  //und gegebenenfalls dann das recte Kind
  if (right()!=null) result.addAll(right().inorder());

  return result;
}</pre>
<h4>6.4.2.4. Milit&auml;rordnung</h4>
<pre>public List military(){
  //Ergebnisliste enth&auml;lt erst diesen Knoten
  List&lt;a&gt; result=new ArrayList&lt;a&gt;();
  result.add(mark());

  //Wir speichern uns die Knoten einer 
  //aktuellen Generation
  List&lt;Tree&lt;a&gt;&gt; currentGeneration = theChildren();

  //Solange es in der aktuellen Generation Knoten gibt
  while (!currentGeneration.isEmpty()){
    //erzeuge die n&auml;chste Generation
    List&lt;Tree&lt;a&gt;&gt; nextGeneration=new ArrayList&lt;Tree&lt;a&gt;&gt;();

    for (Tree&lt;a&gt; nextChild:currentGeneration){
      nextGeneration.addAll(nextChild.theChildren());

      //F&uuml;ge das Elemente der aktuellen Generation 
      //zum Ergebnis
      result.add(nextChild.mark());
    }
    //schalte eine Generation tiefer
    currentGeneration=nextGeneration;
  } 
  return result;
}}</pre>Rechnen Sie auf dem Papier ein Beispiel f&uuml;r die Arbeitsweise
der Methode military().<h2>6.5. Bin&auml;re Suchb&auml;ume</h2>Comparable
        jede Knotenmarkierung eines linken Teilbaums ist kleiner oder
gleich als die Knotenmarkierung.
        jede Knotenmarkierung eines rechten Teilbaums ist gr&ouml;&szlig;er als die
Knotenmarkierung.
      SearchTreeBinTreeinsertinsertComparable<pre>package name.panitz.data.tree;

public class SearchTree&lt;a extends Comparable&lt;a&gt;&gt; 
                                  extends BinTree&lt;a&gt;{</pre>
<pre>  SearchTree(a o){super(o);}</pre>
<pre>  public void insert(a o){
    if (o.compareTo(mark())&lt;=0){
      //neuer Knoten ist kneiner, also in den 
      //linken Teilbaum
      if (left()==null){
        setLeft(new SearchTree&lt;a&gt;(o));
      }else 
        ((SearchTree&lt;a&gt;)left()).insert(o);
    }else{
      //wenn der neue Knoten also gr&ouml;&szlig;er, dann dasselbe
      //im rechten Teilbaum
      if (right()==null){
         setRight(new SearchTree&lt;a&gt;(o));
      }else 
        ((SearchTree&lt;a&gt;)right()).insert(o);
    }
  }
</pre>
<pre>private SearchTree
           (SearchTree&lt;a&gt; l,a o,SearchTree&lt;a&gt; r){
  super(l,o,r);
  try {
   if (!(   o.compareTo(l.mark())&gt;=0
         &amp;&amp; o.compareTo(r.mark())&lt;=0))
     throw new IllegalArgumentException
     ("ordering violation in search tree construction");
  }catch(NullPointerException _){
  }
}</pre>if<pre>package name.panitz.data.tree;
import javax.swing.*;

public class TestSearchTree {
  public static void main(String [] args){
    SearchTree&lt;String&gt; t = new SearchTree&lt;String&gt;("otto");
    t.insert("sven");
    t.insert("eric");
    t.insert("lars");
    t.insert("uwe");
    t.insert("theo");
    t.insert("otto");
    t.insert("kai");
    t.insert("henrik");
    t.insert("august");
    t.insert("berthold");
    t.insert("arthur");
    t.insert("arno");
    t.insert("william");
    t.insert("tibor");
    t.insert("hassan");
    t.insert("erwin");
    t.insert("anna");
    System.out.println(t.inorder());

/*    JFrame frame = new JFrame("Baum Fenster");
    frame.getContentPane().add(new DisplayTree(t));
    frame.pack();
    frame.setVisible(true);*/
  }
}</pre>sep@swe10:~/fh/prog2/beispiele/Tree&gt; java TestSearchTree
[anna, arno, arthur, august, berthold, eric, erwin, hassan, henrik,
kai, lars, otto, otto, sven, theo, tibor, uwe, william]
sep@swe10:~/fh/prog2/beispiele/Tree&gt;Zeichnen Sie schrittweise die Baumstruktur, die im 
Programm TestSearchTree aufgebaut wird.<h4>6.5.1. Beweis der Sortiereigenschaft</h4>Die im  philosophischen Sinne keine
Induktion sondern eine Deduktion ist.
          Anfang: Der Induktionsanfang behauptet, die Inordung
eines Blattes ist sortiert. F&uuml;r ein 
Blatt k gilt: left(k) =null  und right(k) =null. Es folgt, da&szlig; die Inordung nur 
ein Element, n&auml;mlich mark(k), enth&auml;lt.
Einelementige Listen sind immer sortiert.
          Schritt: Wir wollen die Aussage beweisen f&uuml;r alle 
B&auml;ume 
              k
             mit: count(k)=n.

Annahme: die Aussage ist wahr f&uuml;r alle 
B&auml;ume k'
mit count(k')&lt;n.

Die Definition der Inordnung ist:inorder(k) =
(inorder(left(k))
,mark(k),inorder(right(k))).

F&uuml;r endliche B&auml;ume gilt:count(left(k)) &lt;n und count(right(k)) &lt;n
Nach der Induktionsvoraussetzung gilt damit, 
da&szlig;inorder(left(k)) undinorder(right(k))
 sortierte Listen
sind.

&Uuml;ber die Definition der bin&auml;ren Suchb&auml;ume gilt:
f&uuml;r alle x\ininorder(left(k)) gilt x\lemark(k)
und f&uuml;r alle x\ininorder(right(k)) gilt x&gt;mark(k)
Damit ist insbesondere die Liste inorder(k) sortiert.
        <h3>6.5.1. Suchen in Bin&auml;rb&auml;umen</h3>contains<pre>public boolean contains(a o){
  //bist du es schon selbst
  if (mark().equals(o)) return true;
 
  //links oder rechts suchen:
  final int compRes = mark().compareTo(o);

  if (compRes&gt;0){
    //keine Knoten mehr. Dann ist er nicht enthalten
    if (left()==null) return false;
    //Sonst such weiter unten im Baum
    else return ((SearchTree&lt;a&gt;)left()).contains(o);
  }    

  if (compRes&lt;0){
    if (right()==null) return false;
    else return ((SearchTree&lt;a&gt;)right()).contains(o);
  }    
  return false;
}</pre>insert<h3>6.5.2. Entartete B&auml;ume</h3>Erzeugen Sie ein Objekt des typs SearchTree und
f&uuml;gen Sie nacheinander die folgenden Elemente ein:"anna","berta","carla","dieter","erwin","florian","gustav"
Lassen Sie anschlie&szlig;end die maximale Tiefe des Baumes ausgeben.<h4>6.5.3.1. Balanzieren von B&auml;umen</h4>
Betrachten Sie den Baum aus Abbildung


Der linke Teilbaum hat eine Tiefe von 4, der rechte eine Tiefe von
2. Wir k&ouml;nnen den Baum so ver&auml;ndern, da&szlig; beide Kinder eine Tiefe von 3
haben. Wir bekommen den Baum aus 
Abbildung

Das linke Kind dieses Baumes ist auch nicht ausbalanziert, wir k&ouml;nnen
den Baum noch einmal ver&auml;ndern und erhalten den Baum 
in Abbildung:
Zum Ausbalanzieren wird ein Baum gedreht. Einer seiner Kinderknoten
wird die neue Wurzel und die alte Wurzel dessen Kind. Es gibt zwei
Richtungen, in die gedreht werden kann: mit und gegen den
Urhzeigersinn. Schematisch lassen sich diese beiden Operationen mit
folgenden Gleichungen spezifizieren:
              rotateRight(Node(Node(l2,x2,r2),x1,r1)) = Node(l2,x2,Node(r2,x1,r1))
              rotateLeft(Node(l1,x1,Node(l2,x2,r2))) = Node(Node(l1,x1,l2),x2,r2)
            
In graphischer Darstellung wird die erste Gleichung zu:
                    x1
     / \
    /   \
   x2   r1
  / \
 l2 r2
            wird mit rotateRight zu:
                   x2
    / \
   /   \
  l2   x1
       / \
      r2 r1
            

Die Operationen erhalten die Eigenschaft eines Suchbaumes: linke
Kinder sind kleiner, rechte Kinder gr&ouml;&szlig;er als die Wurzel. Die
Linearisierung in der Inordnung bleibt gleich. Die maximale Tiefe der
Kinder ver&auml;ndert sich um 1. Die Anzahl der Knoten im Baum &auml;ndert sich
nicht. 
Wir k&ouml;nnen generell zwei Umsetzungen des oben spezifizierten
Algorithmus w&auml;hlen: eine die einen neues Baumobjekt erzeugt und keinde
der bestehenden B&auml;ume modifiziert und eine, die die Felder der
bestehenden Baumknoten so um&auml;ndert, da&szlig; das Objekt, auf dem die
Methode aufgerufen wird, modifiziert wird.
F&uuml;r die funktionale Umsetzung k&ouml;nnen wir eine statische Methode
schreiben. Sie bekommt einen Baum und soll einen neuen Baum, der durch
Rotation aus den Eingabebaum entstanden ist, als Ergebnis liefern.

Die Umsetzung leitet sich direkt aus der Spezifikation &uuml;ber eine
Gleichung ab. Wir benutzen dieselben Bezeichner wie in der
Spezifikation. <pre>public static &lt;a extends Comparable&lt;a&gt;&gt; SearchTree&lt;a&gt; 
                         rotateRight(SearchTree&lt;a&gt; t){
  try{
    //speichere die einzelnen Teile in die Bezeichner,
    //die wir in der Spezifikation benutzt haben
    final SearchTree&lt;a&gt; l2 = (SearchTree&lt;a&gt;)t.left().left();
    final SearchTree&lt;a&gt; r2 = (SearchTree&lt;a&gt;)t.left().right();
    final SearchTree&lt;a&gt; r1 = (SearchTree&lt;a&gt;)t.right();
    final a x1 = t.mark();
    final a x2 = t.left().mark();

    return new SearchTree&lt;a&gt;
                 (l2,x2,new SearchTree&lt;a&gt;(r2,x1,r1));
  }catch (NullPointerException _){
      return t;
  }
}</pre>
Die Ausnahme tritt auf, wenn das linke Kind nicht existiert, also hier
der Wert null steht. Dann kann nicht nach rechts rotiert
werden (da links nichts zum Rotieren steht). In dem Fall, das nicht
  rotiert werden kann, wird der Eingabebaum unver&auml;ndert ausgegeben.
Wir k&ouml;nnen die modifizierende Methode zum Rotieren eines Baumes in der 
Klasse BinTree implementieren. 
Wir benutzen wieder die Bezeichner
aus unserer Spezifikation. Anstatt aber wie eben neue Knoten zu
erzeugen,  setzen die entsprechenden Referenzen um.<pre>void rotateRight(){
  try{
    BinTree&lt;a&gt; l1 = left();
    BinTree&lt;a&gt; l2 = l1.left();
    BinTree&lt;a&gt; r2 = l1.right();
    BinTree&lt;a&gt; r1 = right();
    a  x1 = mark();
    a  x2 = l1.mark();

    setMark(x2);
    setLeft(l2);
    setRight(l1);
    l1.setMark(x1);
    l1.setLeft(r2);
    l1.setRight(r1);
  }catch (NullPointerException _){
  }
}}</pre>
Die Ausnahme wird
schon in der zweiten Zeile geworfen, bevor Referenzen ver&auml;ndert
wurden. Das Objekt bleibt unver&auml;ndert. Ansonsten werden die Knoten
entsprechend der Spezifikation umgeh&auml;ngt. 
              
                Schreiben sie entsprechend die Methode:
static public SearchTree rotateLeft(SearchTree t)
                
Schreiben Sie in der Klasse BinTree die
entsprechende modifizierende Methode rotateLeft()
                Testen Sie die beiden Rotierungsmethoden. Testen Sie, ob die
Tiefe der Kinder sich ver&auml;ndert und ob die Inordnung gleich
bleibt. Testen Sie insbesondere auch einen Fall, in dem 
die NullPointerException abgefangen wird.
              
            <h1>7. Java Standardklassen</h1>java
      java.lang: das automatisch importierte
Standardpaket. Hier finden sich die allerwichtigsten und permanent
gebrauchten Klassen, wie z.B. String, System und vor
allem auch Object. Auch die wichtigsten Ausnahmeklassen
liegen in diesem Paket.
      java.util: hier befinden sich prim&auml;r die
Sammlungsklassen und Schnittstellen f&uuml;r die
Sammlungsklassen. Desweiteren finden sich hier Klassen zum Umgang mit
Kalenderdaten, Zeiten oder W&auml;hrungen.
      java.io: Klassen f&uuml;r dateibasierte
Ein-/Ausgabe-Operationen. 
      java.applet: Klassen zum Schreiben von Applets.
      java.awt: Klassen f&uuml;r graphische Komponenten.
      javax.swing: weitere Klassen f&uuml;r graphische
Komponenten. Neuere Implementierung zu java.awt, die versucht,
noch generischer und plattformunabh&auml;ngiger zu sein.
    <h2>7.1. Die Klasse Objekt</h2>java.lang.ObjecttoString<h3>7.1.1. Die Methoden der Klasse Object</h3>
<h4>7.1.1.1. equals</h4>public boolean equals(Object obj)==<pre>class EqualVsIdentical {

  public static void main(String [] args){
    String x = "hallo".toUpperCase();
    String y = "hallo".toUpperCase();

    System.out.println("x: "+x);
    System.out.println("y: "+y);

    System.out.println("x==x        -&gt; "+(x==x));
    System.out.println("x==y        -&gt; "+(x==y));
    System.out.println("x.equals(x) -&gt; "+(x.equals(x)));
    System.out.println("x.equals(y) -&gt; "+(x.equals(y)));
  }

}</pre>sep@swe10:~/fh/beispiele&gt; java EqualVsIdentical
x: HALLO
y: HALLO
x==x        -&gt; true
x==y        -&gt;false
x.equals(x) -&gt;true
x.equals(y) -&gt;true
sep@swe10:~/fh/beispiele&gt;xyequalsObjectequals
            Reflexivit&auml;t: es sollte immer gelten: x.equals(x)
            Symmetrie: wenn x.equals(y) dann auch y.equals(x)
            Transitivit&auml;t: wenn x.equals(y) und y.equals(z) dann gilt auch x.equals(z)
            Konsistenz: wiederholte Aufrufe von equals auf dieselben Objekte liefern dasselbe Ergebnis, sofern die Objekte nicht
ver&auml;ndert wurden.
             nichts gleicht null: x.equals(null) ist immer falsch.
          <h4>7.1.1.2. hashCode</h4>public int hashCode()hashcodeHierbei handelt es sich in keinster Weise um
irgendwelche unerlaubten Substanzen. Mit hash wird im Englischen das
Nummersymbol \# des Gatters bezeichnet.ObjectHashHashcodeHashcodehashCode
            wenn x.equals(y) dann folgt x.hashCode()==y.hashCode()
            bleibt ein Objekt unver&auml;ndert, so &auml;ndert sich auch nicht sein Hashcode
          Hashwerte<h4>7.1.1.3. clone</h4>protected Object clone() throws CloneNotSupportedExceptionthisDiese Gleichungen verdeutlichen noch einmal sehr den Unterschied, auf den auch Pedanten der deutschen Sprache gerne hinweisen: Das geclonete Objekt gleicht dem Original, ist aber nicht
dasselbe Objekt.
            
              x.clone() != x
            
            
              x.clone().equals(x)
            
          clonecloneCloneable<pre>class NoClone {
  String x = "hallo";
  public static void main(String [] args)
    throws CloneNotSupportedException{
    NoClone nc = new NoClone();
    NoClone cc = (NoClone)nc.clone();
    System.out.println(cc.x);
  }
}</pre>
sep@swe10:~/fh/beispiele&gt; java NoClone
Exception in thread "main" java.lang.CloneNotSupportedException: NoClone
        at java.lang.Object.clone(Native Method)
        at NoClone.main(NoClone.java:5)
sep@swe10:~/fh/beispiele&gt;Cloneable<pre>class Clone implements Cloneable {
  String x = "hallo";

  public static void main(String [] args) 
      throws CloneNotSupportedException{
    Clone nc = new Clone();
    Clone cc = (Clone)nc.clone();
    System.out.println(cc.x);
  }
}</pre>sep@swe10:~/fh/beispiele&gt; java Clone
hallo
sep@swe10:~/fh/beispiele&gt;Cloneable<h4>7.1.1.4. finalize</h4>protected void finalize() throws Throwablefinallyfinalizefinalizefinalize
Wir k&ouml;nnen einmal testen, wie Java die Objekte willk&uuml;rlich aus dem Speicher
l&ouml;scht. Hierzu schreiben wir eine Klasse, die in der 
Methode finalize eine Aufgabe &uuml;ber das Objekt auf der Kommandozeile ausgibt.<pre>class Finalize {
   int i;
   Finalize(int i){this.i=i;}
   protected void finalize(){
     System.out.print(i+",");
   }</pre>
In einer Hauptmethode erzeugen wir einmal nacheinander viele Objekte dieser Klasse, ohne da&szlig; wir sie irgendwie weiter benutzen wollen:<pre>   public static void main(String [] _){
     for (int i=0;i&lt;100000;i=i+1){
       new Finalize(i);
       System.out.print("*");
     }
   }
}</pre>&Uuml;bersetzen und starten Sie die Klasse Finalize und
beobachten Sie, wie und wann Java Objekte aus dem Speicher l&ouml;scht.<h4>7.1.1.5. toString</h4>public String toString()ObjectgetClass().getName() + '@' + Integer.toHexString(hashCode())<h4>7.1.1.6. weitere Methoden</h4>
<h2>7.2. String und Stringbuffer</h2>StringStringBufferString+StringStringBufferappend<pre>class StringVsStringBuffer {

  public static void main(String [] args){
    String a = "hello";
    String b = a+" world";
    System.out.println(a);

    StringBuffer ab = new StringBuffer("hello");
    StringBuffer bb = ab.append(" world");
    System.out.println(ab);
  }
}</pre>StringBufferappendtoString<pre>class ReturnString {

  static public String toRoman(int i){
    StringBuffer result = new StringBuffer();
    while (i&gt;=1000) {i=i-1000;result.append("M");}
    while (i&gt;=900)  {i=i-900 ;result.append("CM");}
    while (i&gt;=500)  {i=i-500 ;result.append("D");}
    while (i&gt;=400)  {i=i-400 ;result.append("CD");}
    while (i&gt;=100)  {i=i-100 ;result.append("C");}
    while (i&gt;=90)   {i=i-90  ;result.append("XC");}
    while (i&gt;=50)   {i=i-50  ;result.append("L");}
    while (i&gt;=40)   {i=i-40  ;result.append("XL");}
    while (i&gt;=10)   {i=i-10  ;result.append("X");}
    while (i&gt;=9)    {i=i-9   ;result.append("IX");}
    while (i&gt;=5)    {i=i-5   ;result.append("V");}
    while (i&gt;=4)    {i=i-4   ;result.append("IV");}
    while (i&gt;=1)    {i=i-1   ;result.append("I");}
    return result.toString();
  }
    
  public static void main(String [] args){
    System.out.println(toRoman(1999));
    System.out.println(toRoman(494));
  }

}</pre>
<h2>7.3. Sammlungsklassen</h2>java.utiljava.util.CollectionListSet<h3>7.3.1. Listen</h3>add
          add zum Hinzuf&uuml;gen von Elementen.
          clear zum L&ouml;schen  aller Elemente.
          remove zum L&ouml;schen  einzelner Elemente.
        StringStringBuffer<h4>7.3.1.1. Listenklassen</h4>ArrayListLinkedListVectorArrayListVector<pre>import java.util.List;
import java.util.ArrayList;

class ListUsage{

  public static void main(String [] args){
    List&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add("hallo");
    xs.add("welt");
    xs.add("wie");
    xs.add("geht");
    xs.add("es");
    xs.add("dir");
    System.out.println(xs);
  }

}</pre>sep@swe10:~/fh/beispiele&gt; java ListUsage
[hallo , welt , wie , geht , es , dir ]
sep@swe10:~/fh/beispiele&gt;add<h3>7.3.2. Mengen</h3>equalstrueequalsHashSetSethashCodeAus !x.equals(y) folgt x.hashCode != y.hashCode()<h3>7.3.3. Iteratoren</h3>Iterator
          Object next(), die den Iterator um ein Element
weiterschaltet und das aktuelle Element als Ergebnis hat.
          boolean hasNext(), die true als Ergebnis hat,
wenn die Methode next ein weiteres Element liefert.
        <h4>7.3.3.1. Iterator f&uuml;r Li</h4>
<pre>package name.panitz.data.list;

public class LiIterator&lt;a&gt; implements java.util.Iterator&lt;a&gt;{

  public LiIterator(Li&lt;a&gt; xs){this.xs=xs;}

  private Li&lt;a&gt; xs;

  public boolean hasNext() {return !xs.isEmpty();}

  public a next(){
    a result = xs.head();
    xs = xs.tail();
    return result;
  }

  public void remove(){
   throw new UnsupportedOperationException ();
  }
}</pre>Li<pre>  public java.util.Iterator&lt;a&gt; iterator(){
    return new LiIterator&lt;a&gt;(this);
  }</pre>
<h4>7.3.3.2. Benutzung von Iteratoren</h4>fornextString<pre>import java.util.Collection;
import java.util.ArrayList;
import java.util.Iterator;

class Iterate {
  static public String unwords(Collection&lt;String&gt; cs){
    String result = "";

    for (String n:cs){
      result = result+" "+cs;
    }
    return result;
  }

  static public void main(String [] _){
    Collection&lt;String&gt; cs = new ArrayList&lt;String&gt;();
    cs.add("lebt");
    cs.add("wohl");
    cs.add("gott");
    cs.add("wei&szlig;");
    cs.add("wann");
    cs.add("wir");
    cs.add("uns");
    cs.add("wiedersehen");

    System.out.println(unwords(cs));
  }
}</pre>
<h3>7.3.4. Abbildungen</h3>
<h4>7.3.4.1. Abbildungen als Liste von Paaren</h4>Das 
Programm Eliza aus einer der vorangegangenen Aufgaben hat
genau so Abbildungen umgesetzt.<pre>
package name.panitz.data.list;
public class Paar&lt;a,b&gt;{
  public a fst;
  public b snd;
  public Paar(a f,b s){fst=f;snd=s;}
}</pre>
<pre>package name.panitz.data.list;
class Abbildung&lt;a,b&gt; extends Li&lt;Paar&lt;a,b&gt;&gt;{
  public Abbildung(a schl&uuml;ssel,b wert,Abbildung&lt;a,b&gt; xs){
    super(new Paar&lt;a,b&gt;(schl&uuml;ssel,wert),xs);
  }

  public Abbildung(){}

  b lookup(a schluessel){
    b result = null;
    
    for (Paar&lt;a,b&gt; p:this) {
      if (p.fst.equals(schluessel)){
        return p.snd;
      }
    }
    return result;
  }
}</pre>lookup<pre>package name.panitz.data.list;
class Dictionary {
  static final Abbildung&lt;String,String&gt; dic = 
     new Abbildung&lt;String,String&gt;("Menge","set"
    ,new Abbildung&lt;String,String&gt;("Abbildung","map"
    ,new Abbildung&lt;String,String&gt;("Liste","list"
    ,new Abbildung&lt;String,String&gt;("Iterator","iterator"
    ,new Abbildung&lt;String,String&gt;("Schnittstelle","interface"
    ,new Abbildung&lt;String,String&gt;("Klasse","class"
    ,new Abbildung&lt;String,String&gt;()))))));

  static String english(String deutsch){
    return dic.lookup(deutsch);
  }

  public static void main(String [] _){
    System.out.println(english("Schnittstelle"));    
    System.out.println(english("Abbildung"));    
  }
}</pre>
<h4>7.3.4.2. Standardklasse f&uuml;r Abbildungen</h4>java.util.Map
            void put(a key, b value): ein neues Schl&uuml;ssel-/Wertpaar
wird der Abbildung hinzugef&uuml;gt. 
             Object get(a key): f&uuml;r einen bestimmten Schl&uuml;ssel
wird ein bestimmter Wert nachgeschlagen. Gibt es f&uuml;r diesen Schl&uuml;ssel
keinen Eintrag in der Abbildung, so ist das Ergebnis dieser 
Methode null.
          HashMapAbbildungput<pre>import java.util.*;

class Dic{
  static Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();

  static {
    map.put("Menge","set");
    map.put("Abbildung","map");
    map.put("Liste","list");
    map.put("Iterator","iterator");
    map.put("Schnittstelle","interface");
    map.put("Klasse","class");
  }

  static String english(String deutsch){
   return map.get(deutsch);
  }

  public static void main(String [] _){
    System.out.println(english("Schnittstelle"));    
    System.out.println(english("Abbildung"));    
  }

}</pre>
<h3>7.3.5. Weitere Sammlungsmethoden</h3>java.util.Collections<h3>7.3.6. Vergleiche</h3>sortByRelationjava.util.Comparatorint compare(Object o1, Object o2)<pre>import java.util.Comparator;
class ReverseComparator implements Comparator&lt;String&gt; {

  public int compare(String o1, String o2) {
    return reverse((String) o1).compareTo(reverse((String) o2));
  }

  static private String reverse(String str){
    StringBuffer result = new StringBuffer();
    for (int i=str.length()-1;i&gt;=0;i=i-1){
      result.append(str.charAt(i));
    }
    return result.toString();
  }

}</pre>
<pre>import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

class Rhyme {
  public static List&lt;String&gt; rhyme(List&lt;String&gt; xs){
    Collections.sort(xs,new ReverseComparator());
    return xs;
  }

  public static void main(String [] args){
    List&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add("maus");
    xs.add("rasieren");
    xs.add("bauhaus");
    xs.add("verlieren");
    xs.add("regen");
    xs.add("laus");
    xs.add("segen");
    xs.add("kapitulieren");
    xs.add("monieren");
    xs.add("existieren");
    xs.add("kraus");
    rhyme(xs);
    System.out.println(xs);
  }
}</pre>java.lang.Comparableint compareTo(Object o)ComparableClassCastException<h2>7.4. Ein- und Ausgabe</h2>java.io
        Zeichenenstr&ouml;me: Die Grundeinheit der Datenkommunikation
sind Buchstaben und andere Schriftzeichen. Hierbei kann es sich um 
beliebige Zeichen aus dem
Unicode handeln, also Buchstaben so gut wie jeder bekannten Schrift, von lateinischer  &uuml;ber kyrillische, griechische, arabische, chinesische bis hin zu exotischen Schriften wie der keltischen Keilschrift. Dabei ist entscheidend, in welcher Codierurung die
Buchstaben in der Datenquelle vorliegen. Die Codierung wird in der
Regel beim Konstruieren eines Datenstroms festgelegt. Geschieht dieses
nicht, so wird die Standardcodierung des Systems, auf dem das Programm l&auml;uft, benutzt.
        Bytestr&ouml;me (Oktettstr&ouml;me): Hierbei ist die Grundeinheit immer ein Byte, das als Zahl verstanden wird. 
      <h3>7.4.1. Zeichenstr&ouml;me</h3>
          Reader: f&uuml;r Str&ouml;me, aus denen gelesen werden soll.
          Writer: f&uuml;r Str&ouml;me, in die geschrieben werden soll.
        FileInputStreamFileOutputStream<h3>7.4.2. Bytestr&ouml;me</h3>
          
            InputStream
          
          
            OutputStream
          
        FileInputStreamFileOutputStream<h3>7.4.3. Ausnahmen</h3>IOException<h3>7.4.4. Schreiben und Lesen</h3>int read()int write(int c)read-1<h3>7.4.5. Datenstr&ouml;me</h3>close<h4>7.4.5.1. Textdateien lesen</h4>FileReader<pre>import java.io.*;
class ShowFile{
  public static void main(String [] args) throws Exception{
    Reader reader = new FileReader(args[0]);
    while (true){
      final int next = reader.read();
      if (next==-1) break;
      System.out.print((char)next);
      System.out.print(next);
    }
  }
}</pre>
<h4>7.4.5.2. Textdateien schreiben</h4>FileWriter<pre>import java.io.*;

public class Copy {
  public static void main(String[] args) throws IOException {
    FileReader in = new FileReader(args[0]);
    FileWriter out = new FileWriter(args[1]);
    int c;

    while ((c = in.read()) != -1){
      out.write(c);
    }
  }
}</pre>
<h3>7.4.6. Vom InputStream zum Reader, vom OutputStream zum Writer</h3>ReaderWriter<h4>7.4.6.1. InputStreamReader und OutputStreamWriter</h4>InputStreamReaderOutputStreamWriterIntputStreamOutputStreamReaderWriter
Statt die vorgefertigte Klasse FileWriter zum Schreiben einer
Textdatei zu benutzen, erzeugt die folgende Version zum Kopieren von Dateien
einen &uuml;ber einen FileOutputStream erzeugten Writer bzw. einen &uuml;ber einen FileInputStream erzeugten Reader:  <pre>import java.io.*;

class Copy2 {
  static public void main(String [] args)
     throws Exception {
    Reader reader = new FileReader(args[0]);
    Writer writer 
     = new OutputStreamWriter(new FileOutputStream(args[1]));

    int c;
    while ((c = reader.read()) != -1){
      writer.write(c);
    }
    writer.close();
  }
}</pre>
<h4>7.4.6.2. Zeichenkodierungen</h4>Codierung&szlig;CodierungCodierungenOutputStreamWriterOutputStream In dieser Version der Kopierung einer Textdatei wird f&uuml;r 
den Writer ein Objekt der 
Klasse OutputStreamWriter benutzt, in der als Zeichenkodierung utf-16
benutzt wird.<pre>import java.nio.charset.Charset;
import java.io.*;

class EncodedCopy {
  static public void main(String [] args)
     throws Exception {
    Reader reader = new FileReader(args[0]);
    Writer writer = new OutputStreamWriter
                         (new FileOutputStream(args[1])
                         ,Charset.forName("UTF-16"));

    int c;
    while ((c = reader.read()) != -1){
      writer.write(c);
    }
    writer.close();
  }
}</pre> Betrachtet man die Gr&ouml;&szlig;e der geschriebenen Datei, so wird man feststellen, da&szlig; sie mehr als doppelt so gro&szlig; ist wie die Ursprungsdatei.sep@linux:~/fh/prog1/&gt; java EncodedCopy EncodedCopy.java EncodedCopyUTF16.java
sep@linux:~/fh/prog1/&gt; ls -l EncodedCopy.java
-rw-r--r--    1 sep      users         443 2004-01-07 19:12 EncodedCopy.java
sep@linux:~/fh/prog1/&gt; ls -l EncodedCopyUTF16.java
-rw-r--r--    1 sep      users         888 2004-01-07 19:13 EncodedCopyUTF16.java
sep@linux:~/fh/prog1/&gt;
Schreiben Sie ein Programm FileConvert zum  Konvertieren von Textdateien in eine andere Kodierung. Dem Programm sollen &uuml;ber die Kommandozeilenparameter der Name der Eingabedatei, der Name der Ausgabedatei und der Name der benutzten Codierung &uuml;bergeben werden. Ein m&ouml;glicher Aufruf w&auml;re also:linux:~/&gt;java FileConvert test.txt konvertiertTest.txt utf-8

Lassen Sie eine deutsche Textdatei mit Umlauten in eine Datei mit der Codierung utf-8 konvertieren. Betrachten Sie die Ergebnisdatei. Was stellen
Sie fest?<h4>7.4.6.3. Gepufferte Str&ouml;me</h4>readwriteen blocreadreadBufferedInputStream, BufferedOutputStreamBufferedReader, BufferedWriter
Jetzt erg&auml;nzen wir zur Effizienzsteigerung noch das Kopierprogramm, so da&szlig;  der benutzte Writer gepuffert ist:<pre>import java.io.*;
import java.nio.charset.Charset;

class BufferedCopy{
  static public void main(String [] args)
     throws Exception {

    Reader reader = new FileReader(args[0]);
    Writer writer = new BufferedWriter
                      (new OutputStreamWriter
                          (new FileOutputStream(args[1])
                          ,Charset.forName("UTF-16")));

    int c;
    while ((c = reader.read()) != -1){
      writer.write(c);
    }
    writer.close();
  }
}</pre>
<h3>7.4.7. Str&ouml;me f&uuml;r Objekte</h3>ObjectOutputStreamObjectInputStreamOutputStreamInputStreamjava.io.SerializableSerializableimplements Serializable
Folgendes Testprogramm schreibt eine Zahl und ein Listenobjekt in eine Datei,
um diese anschlie&szlig;end wieder aus der Datei auszulesen.<pre>import java.io.*;
import java.util.List;
import java.util.ArrayList;

public class WriteReadObject {
  public static void main(String [] args) throws Exception{
    FileOutputStream fos = new FileOutputStream("t.tmp");
    ObjectOutputStream oos = new ObjectOutputStream(fos);

    List&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add("the");
    xs.add("world");
    xs.add("is");
    xs.add("my");
    xs.add("oyster");

    oos.writeInt(12345);
    oos.writeObject(xs);
    oos.close();
	
    FileInputStream fis = new FileInputStream("t.tmp");
    ObjectInputStream ois = new ObjectInputStream(fis);

    int i = ois.readInt();
    List ys = (List) ois.readObject();

    ois.close();
 
    System.out.println(i);
    System.out.println(ys);
  }
}</pre>Erweitern Sie die Klasse Li, so da&szlig; Sie Ihre Listenobjekte
in Dateien schreiben und wieder aus Dateien lesen k&ouml;nnen. Testen Sie ihre
Implementierung. <h3>7.4.8. Stromloses IO</h3>java.io.RandomAccessFile
Studieren Sie die Dokumentation von java.io.RandomAccessFile und
schreiben Sie einige Testbeispiele zur Benutzung dieser Klasse.<h1>8. Qualit&auml;tssicherung</h1>
<h2>8.1. Vertr&auml;ge</h2>
<pre>public class AssertFac{
  static public int fac(int x){
    assert x&gt;=0;
    if (x==0) return 1;
    return x*fac(x-1);
  }

  static public void main(String [] args){
    for (String arg:args)
      System.out.println(fac(new Integer(arg)));
  }
}</pre>sep@pc305-3:~/fh/java&gt; java -cp student/classes/ -ea AssertFac 1 2 3 4 5 -1 17
1
2
6
24
120
Exception in thread "main" java.lang.AssertionError
        at AssertFac.fac(AssertFac.java:4)
        at AssertFac.main(AssertFac.java:11)
sep@pc305-3:~/fh/java&gt;Seiteneffektfrei, apt f&uuml;r pre und postcondition?<h2>8.2. Unit Tests</h2>
<h2>8.3. Logging</h2>
<pre>package name.panitz.log.example;
import java.util.logging.Logger;
import java.util.logging.Level;
public class JustLogMe{
  private static Logger logger = Logger.getLogger("name.panitz.log.example");

  static public void main(String [] args){
    logger.info("eine log info");
    logger.log(Level.WARNING, "ein kleines problem" );
    logger.log(Level.SEVERE, "ein gro&szlig;es problem");
    logger.fine("eine super feine info");
  } 
}</pre>
<h2>8.4. Qualit&auml;tsma&szlig;e</h2>
<h1>9. Algebraische Datentypen</h1>
<h2>9.1. Das Besuchsmuster</h2>
        &Uuml;berladung: eine Methode existiert mehrfach mit gleichem Namen in
einer Klasse. Die verschiedenen Versionen dieser Methode unterscheiden sich in
ihren Parametern, indem sie unterschiedliche Parametertypen oder eine
unterschiedliche Anzahl von Parametern haben.
        &Uuml;berschreibung: eine Methode ist in verschiedenen Unterklassen
einer Klasse &uuml;berschrieben worden. Hier hat jede der &uuml;berschreibenen Methoden
dieselben Parameter. Man spricht im objektorientierten Umfeld auch 
von Polymorphie.
      
        &Uuml;berladung: Der Compiler entscheidet statisch bei der
Codegenerierung. Hierzu schaut er sich bei einem Methodenaufruf an, von welchem
statischen Typ die Parameter des Aufrufs sind und w&auml;hlt anhand dessen die
Methode aus. Hierbei wird f&uuml;r alle Argumente der deklarierte Typ genommen, es
werden also nicht die Argumentojekte gefragt, ob sie eventuell von einer
Unterklasse ihres deklarierten Typs sind:
Im folgenden kleinen Programm ist eine Funktion f &uuml;berladen.
In der Hauptmethode wird die Version f&uuml;r den 
Parametertyp Object ausgef&uuml;hrt, da das lokale 
Feld s als von Typ Object deklariert wurde. Es ist dabei
unerheblich, da&szlig; das Objekt s aber eigentlich ein Stringobjekt ist. <pre>class Overloaded{
  void f(String s){System.out.println("Stringversion");}
  void f(Object s){System.out.println("Objectversion");}
  public static void main(String [] _){
    Object s = "das ist ein String";
    new Overloaded().f(s);
  }
}</pre>
        &Uuml;berschreibung: Hier wird erst w&auml;hrend der Ausf&uuml;hrung des
  Programms entschieden, welche Version der Methode aufgerufen wird. Dieses
  ist das Prinzip dert sp&auml;ten Bindung. W&auml;hrend der Ausf&uuml;hrungszeit wird das
  Objekt gebeten seine Version der &uuml;berschriebenen Methode 
auszuf&uuml;hren.  
        
In diesem Beispiel benutzen wir die Eigenschaft, da&szlig; die 
Methode toString aus der Klasse Object in der 
Klasse String &uuml;berschrieben wurde. Obwohl das lokale 
Feld s als von Typ Object deklariert ist, wird doch die
  Methode toString der Klasse String ausgef&uuml;hrt. <pre>class Overridden{
  public static void main(String [] _){
    Object s = "das ist ein String";
    System.out.println(s.toString());
  }
}</pre>
      
<h3>9.1.1. Klassen zur Baumdarstellung eines Programms</h3>
<pre>result=1;
x=5;
loop (x){
  result=result*x;
  x=x-1
}</pre>
<pre>interface Node{
    void welcome(Visitor x);
}</pre>
<pre>class Num implements Node {
  int value;
  Num(int n){value=n;}
  public void welcome(Visitor x){x.visit(this);}
}</pre>
<pre>class Var implements Node {
  String name;
  Var(String n){name=n;}
  public void welcome(Visitor x){x.visit(this);}
}</pre>
<pre>class Seq implements Node {
  Node leftChild;
  Node rightChild;
  Seq(Node lC,Node rC){leftChild=lC;rightChild=rC;}
  public void welcome(Visitor x){x.visit(this);}
}</pre>
<pre>class Assign implements Node {
  Var leftChild;
  Node rightChild;
  Assign(Var lC,Node rC){leftChild=lC;rightChild=rC;}
  public void welcome(Visitor x){x.visit(this);}
}</pre>
<pre>class Sub implements Node {
  Node leftChild;
  Node rightChild;
  Sub(Node lC,Node rC){leftChild=lC;rightChild=rC;}
  public void welcome(Visitor x){x.visit(this);}
}</pre>
<pre>class Mult implements Node {
  Node leftChild;
  Node rightChild;
  Mult(Node lC,Node rC){leftChild=lC;rightChild=rC;}
  public void welcome(Visitor x){x.visit(this);}
}</pre>
<pre>class Loop implements Node {
  Node leftChild;
  Node rightChild;
  Loop(Node lC,Node rC){leftChild=lC;rightChild=rC;}
  public void welcome(Visitor x){x.visit(this);}
}</pre>
<pre>class GetSimpleProg{
  public static Node getSimpleProg(){
    Var result=new Var("result");
    Var x=new Var("x");
    Node n1=new Num(1);
    Node n5=new Num(5);
    Node as1 = new Assign(result,n1);
    Node as2 = new Assign(x,n5);
    Node mult = new Mult(result,x);
    Node sub = new Sub(x,n1);
    Node as3 = new Assign(result,mult);
    Node as4 = new Assign(x,sub);
    Node seq3 = new Seq(as3,as4);
    Node loop = new Loop(x,seq3);
    Node seq2 = new Seq(as2,loop);
    Node seq1 = new Seq(as1,seq2);
    return seq1;
  }
}</pre>
<pre>interface Visitor {
  void visit(Var x);
  void visit(Num x);
  void visit(Assign x);
  void visit(Loop x);
  void visit(Mult x);
  void visit(Sub x);
  void visit(Seq x);
}</pre>
<h4>9.1.1.1. Besucher zum Ausgeben</h4>
<pre>class PrettyPrinter implements Visitor{
  StringBuffer result= new StringBuffer();
  int indent=0;
  void newline(){
    result.append("\n");
    for (int i=indent;i&gt;0;i--)result.append(' ');
  }
  void addIndent(){i=i+2;}
  void removeIndent(){i=i-2;}

  public void visit(Var x){result.append(x.name);}
  public void visit(Num x){result.append(""+x.value);}
  public void visit(Assign x){
    x.leftChild.welcome(this);
    result.append(" = ");
    x.rightChild.welcome(this);
  }
  public void visit(Loop x){
    result.append("loop (");
    x.leftChild.welcome(this);
    resultappend("){");
    addIndent();
    newline();
    x.rightChild.welcome(this);
    removeIndent();
    newline();
    result.append("}");
  }
  public void visit(Mult x){
    x.leftChild.welcome(this);
    result.append(" * ");
    x.rightChild.welcome(this);
  }
  public void visit(Sub x){
    x.leftChild.welcome(this);
    result.append(" - ");
    x.rightChild.welcome(this);
  }
  public void visit(Seq x){
    x.leftChild.welcome(this);
    result.append(";")
    newline();
    x.rightChild.welcome(this);
  }
}</pre>
<h4>9.1.1.2. Besucher zum Ausf&uuml;hren eines Programms</h4>
<pre>import java.util.*;
class Calculate implements Visitor{
  Map&lt;String,Integer&gt; env=new HashMap&lt;String,Integer&gt;();
  private int result;
  public void visit(Var x){result=env.get(x.name);}
  public void visit(Num x){result=x.value;}
  public void visit(Assign x){
    x.rightChild.welcome(this);
    env.put(x.leftChild.name,result);
  }
  public void visit(Loop x){
    x.leftChild.welcome(this);
    while (result!=0){
      x.rightChild.welcome(this);
      x.leftChild.welcome(this);
    }
  }
  public void visit(Mult x){
    x.leftChild.welcome(this);
    int op1 = result;
    x.rightChild.welcome(this);
    int op2 = result;
    result= op1*op2;
  }
  public void visit(Sub x){
    x.leftChild.welcome(this);
    int op1 = result;
    x.rightChild.welcome(this);
    int op2 = result;
    result= op1-op2;
  }
  public void visit(Seq x){
    x.leftChild.welcome(this);
    x.rightChild.welcome(this);
  }
}</pre>
<h2>9.2. Putzen der Kochplatte</h2>
        &Uuml;ber die komplette Datenstruktur zu gehen um etwas zu berechnen.
        Bestimmte Knoten der Datenstruktur zu ver&auml;ndern.
        Bestimmte Anfrage an die Datenstruktur zu stellen, um Information aus
Ihr zu bekommen.
      <h3>9.2.1. Itroduction</h3>
          certain tree nodes may be modified,
          or certain information
may be collected from the tree.
        
          in a pure object oriented manner: classes representing tree nodes
contain specialized methods for different tasks.
          in a functional way by means of the visitor 
pattern: tree classes
implement an interface Visitable. 
Algorithms can be expressed by terms of
visitor classes. A visitor class overloads a function for every kind of tree
node.
        visitsscrap your boilerplate 
code downloaded from the
web<h3>9.2.2. The Problem</h3>
<pre>&lt;!DOCTYPE Company SYSTEM "company.dtd" [
  &lt;!ELEMENT Company (Dept)*&gt;  
  &lt;!ELEMENT Dept (Name,Employee,(PU|DU)*)&gt;  
  &lt;!ELEMENT PU (Employee)&gt;  
  &lt;!ELEMENT DU (Dept)&gt;  
  &lt;!ELEMENT Employee (Person,Salary)&gt;  
  &lt;!ELEMENT Person (Name,Address)&gt;  
  &lt;!ELEMENT Salary (#PCDATA)&gt;  
  &lt;!ELEMENT Name (#PCDATA)&gt;  
  &lt;!ELEMENT Address (#PCDATA)&gt;
]&gt;</pre>|(PU|DU)PUDU(Dept)*ListCompanyNot quite it is extended with a
subdepartment, otherwise one of the algorithms in this (as well as in the
original paper) does not have any effect.<pre>package name.panitz.boilerplate;
import java.util.*;
class MyComp{
  static Company getCompany(){
   Company company= new Company();
   Employee blair= new Employee(new Person("Blair","London"),new Salary(100000.0));
   Employee nn=new Employee(new Person("NN","Mars"),new Salary(90000.0));
   Employee marlow=new Employee(new Person("Marlow","Cambridge"),new Salary(2000.0));
   Employee joost = new Employee(new Person("Joost","Amsterdam"),new Salary(1000.0));
   Employee ralf = new Employee(new Person("Ralf","Amsterdam"),new Salary(8000.0));
   List&lt;SubUnit&gt; ralfSu = new ArrayList&lt;SubUnit&gt;();
   ralfSu.add(new PU(joost));ralfSu.add(new PU(marlow));
   company.add(new Dept("Research",ralf,ralfSu));
   company.add(new Dept("Strategy",blair,new ArrayList&lt;SubUnit&gt;()));
   ralfSu.add(new DU(new Dept("Research2",nn,new ArrayList&lt;SubUnit&gt;())));
   return company;
  }
}</pre>
          increase the salary of each employee.
          liquidate a certain sub department.
          sum up all salary numbers for an overall salary bill of the company.
          represent the company by a String.
          compare two companies for equality.
          represent the company in an XML document.
        <pre>&lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:template match="Salary"&gt;
  &lt;xsl:variable name="arg1"&gt;&lt;xsl:apply-templates select="text()"/&gt;&lt;/xsl:variable&gt;
  &lt;Salary&gt;&lt;xsl:value-of select="$arg1 * 1.17" /&gt;&lt;/Salary&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="*"&gt;
  &lt;xsl:copy select="*" &gt;&lt;xsl:apply-templates/&gt;&lt;/xsl:copy &gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>Salary&lt;xsl:apply-templates/&gt;<h3>9.2.3. Na\"ive hand coded instances</h3>IterableIterableCompanyIterable&lt;Object&gt;<h4>9.2.3.1. Show</h4>showfor-each<pre>package name.panitz.boilerplate;
class Show{
  static String show(Object o){
    StringBuffer result = new StringBuffer(); 
    if (o instanceof Iterable) {
      result.append("new "+o.getClass().getSimpleName()+"(");
      boolean first = true;
      for (Object x:((Iterable)o)){//the tree traversal code
        if (first) first=false;else result.append(",");
        result.append(show(x));
      }
      result.append(")");
    }else result.append(o);
    return result.toString();
  }
}</pre>String<pre>package name.panitz.boilerplate;
class TestShow{
  public static void main(String [] args){
    System.out.println(Show.show(MyComp.getCompany()));}}</pre>
<h4>9.2.3.2. Eq</h4>
<pre>package name.panitz.boilerplate;
import java.util.Iterator;
class Eq{
  static boolean eq(Object x,Object y){
    if (x instanceof Iterable &amp;&amp; y instanceof Iterable){
      Iterator ity = ((Iterable)y).iterator();
      for (Object z:(Iterable)x){if (!ity.hasNext())    return false;
                                 if (!eq(z,ity.next())) return false;}
    }else return x.equals(y);
    return true;
  }
}</pre>
<pre>package name.panitz.boilerplate;
class TestEq{
  public static void main(String [] args){
    System.out.println(Eq.eq(MyComp.getCompany(),MyComp.getCompany()));}}</pre>
<h3>9.2.4. Generic Transformers</h3>transform<pre>package name.panitz.boilerplate;
interface Transformer{void transform(Object o);}</pre>map<pre>package name.panitz.boilerplate;
public abstract class Transform  implements Transformer{
  public  void gmap(Object x){
    if (x instanceof Iterable) for (Object a:((Iterable)x)) transform(a);
  }</pre>everywhereTransform<pre>  Transform everywhereT = null;
  public void everywhere(Object x){</pre>everywhereeverywhere<pre>    final Transform dies = this;
    if (everywhereT==null)
      everywhereT
       = new Transform(){public void transform(Object o){dies.everywhere(o);}};</pre>map<pre>    everywhereT.gmap(x);
    transform(x);
  }
}</pre>mapmap<h4>9.2.4.1. Example: increase of all salary</h4>Transformtransform<pre>package name.panitz.boilerplate;
import java.util.*;
public class Increase extends Transform{
 Double k; Increase(Double k){this.k=k;}
 public void transform(Object o){
  if (o instanceof Salary){Salary s = (Salary)o;s.amount=s.amount*(1+k);}
 }
}</pre>We apply this transformer 100000
times. This is done for some rough performance measure later in the paper.<pre>package name.panitz.boilerplate;
class TestIncrease{
  public static void main(String [] args){
    Company company = MyComp.getCompany();
    for (int i=0;i&lt;100000;i++)
      new Increase(.000017).everywhere(company);
    System.out.println(Show.show(company));}}</pre>
<h4>9.2.4.2. Example: flatten company structure</h4>
<pre>package name.panitz.boilerplate;
import java.util.*;
class Flatten extends Transform{
  String deptName;
  Flatten(String deptName){this.deptName=deptName;}
  public void transform(Object o){
   if (o instanceof Dept){
     List&lt;SubUnit&gt; newSus=new ArrayList&lt;SubUnit&gt;();
     Dept d = (Dept)o;
     for (SubUnit su:d.subUnits){
       if (su instanceof DU){
         Dept du= ((DU)su).dept;
         if (du.name.equals(deptName)){
           newSus.add(new PU(du.manager));newSus.addAll(du.subUnits);
         }else newSus.add(su);
       }else newSus.add(su);
     }
     d.subUnits=newSus;
   }
  }
}</pre>Increase<pre>package name.panitz.boilerplate;
class TestFlatten{
  public static void main(String [] args){
    Company company = MyComp.getCompany();
    new Flatten("Research2").everywhere(company);
    System.out.println(Show.show(company));}}</pre>
<h4>9.2.4.3. Using Reflection</h4>instanceoftransform<pre>package name.panitz.boilerplate;
class TransformReflect  extends Transform{
  public void transform(Object o){
    try{getClass().getMethod("transform",o.getClass()).invoke(this,o);
    }catch(IllegalAccessException  _){}
     catch(IllegalArgumentException _){}
     catch(java.lang.reflect.InvocationTargetException _){}
     catch(NoSuchMethodException _){}
  }
}</pre>transform<pre>package name.panitz.boilerplate;
import java.util.*;
class IncreaseReflect extends TransformReflect{
 Double k; IncreaseReflect(Double k){this.k=k;}
 public void transform(Salary s){s.amount=s.amount*(1+k);}
}</pre>
<pre>package name.panitz.boilerplate;
class TestIncreaseReflect{
  public static void main(String [] args){
    Company company = MyComp.getCompany();
    for (int i=0;i&lt;100000;i++)
      new IncreaseReflect(.000017).everywhere(company);
    System.out.println(Show.show(company));}}</pre>sep@pc216-5:~/boilerplate&gt; time java -cp classes/ name.panitz.boilerplate.TestIncrease
new Company(new Dept(Research,new Employee(new Person(Ralf,Amsterdam),new Salary
(43790.9463569525)),new ArrayList(new PU(new Employee(new Person(Joost,Amsterdam)
,new Salary(5473.868294619063))),new PU(new Employee(new Person(Marlow,Cambridge)
,new Salary(10947.736589238126))),new DU(new Dept(Research2,new Employee(new Pers
on(NN,Mars),new Salary(492648.1465157075)),new ArrayList())))),new Dept(Strategy,
new Employee(new Person(Blair,London),new Salary(547386.8294619016)),new ArrayLis
t()))

real    0m0.912s
user    0m0.849s
sys     0m0.013s
sep@pc216-5:~/boilerplate&gt; time java -cp classes/ name.panitz.boilerplate.TestIncreaseReflect
new Company(new Dept(Research,new Employee(new Person(Ralf,Amsterdam),new Salary
(43790.9463569525)),new ArrayList(new PU(new Employee(new Person(Joost,Amsterdam)
,new Salary(5473.868294619063))),new PU(new Employee(new Person(Marlow,Cambridge)
,new Salary(10947.736589238126))),new DU(new Dept(Research2,new Employee(new Pers
on(NN,Mars),new Salary(492648.1465157075)),new ArrayList())))),new Dept(Strategy,
new Employee(new Person(Blair,London),new Salary(547386.8294619016)),new ArrayLis
t()))

real    0m53.016s
user    0m52.010s
sys     0m0.238s
<h3>9.2.5. Generic Queries</h3>
<pre>package name.panitz.boilerplate;
interface Function1&lt;argType,resultType&gt;{resultType eval(argType x);}</pre>We resisted the
temptation of expressing these via currying 
as Function1&lt;a,Function1&lt;b,c&gt;&gt;.<pre>package name.panitz.boilerplate;
interface Function2&lt;a,b,c&gt;{c eval(a x,b y);}</pre>Query<pre>package name.panitz.boilerplate;
import java.util.*;
public abstract class Query&lt;b&gt; implements Function1&lt;Object,b&gt;,Function2&lt;b,b,b&gt;{</pre>map<pre>  public List&lt;b&gt; gmap(Object x){
    List&lt;b&gt; result= new ArrayList&lt;b&gt;();
    if (x instanceof Iterable) for (Object a:((Iterable)x)) result.add(eval(a));
    return result;
  }</pre>everywhereeverythingQueryFunction2&lt;b,b,b&gt;<pre>  public b everything(Object x){
    b result = eval(x);
    final Query&lt;b&gt; dies = this;
    Query&lt;b&gt; everythingQ = null;
    if (everythingQ==null)
      everythingQ = new Query&lt;b&gt;(){
          public b eval(Object o){return dies.everything(o);}
          public b eval(b x,b y) {return dies.eval(x,y);}
      };
    for (b y:everythingQ.gmap(x)) result=eval(result,y);
    return result;
  }
}</pre>Queryevaleval<pre>package name.panitz.boilerplate;
class SalaryBill extends Query&lt;Double&gt;{
  public Double eval(Object x){
    if (x instanceof Salary) return ((Salary)x).amount;
    return 0.0;
  }</pre>
<pre>   public Double eval(Double x,Double y){return x+y;}
}</pre>
<pre>package name.panitz.boilerplate;
class TestSalaryBill{
  public static void main(String [] args){
    System.out.println(new SalaryBill().everything(MyComp.getCompany()));
  } 
}</pre>
<h4>9.2.5.1. Show revisited</h4>
<pre>package name.panitz.boilerplate;
class Show2 extends Query&lt;String&gt;{
  public String eval(Object x){
    return x instanceof Iterable?("new "+x.getClass().getSimpleName()):x.toString();
  }
  public String eval(String x,String y){return x+"("+y+")";}
  public static void main(String [] args){
    System.out.println(new Show2().everything(MyComp.getCompany()));}}</pre>
<h4>9.2.5.2. Back to XML</h4>Query<pre>package name.panitz.boilerplate;
import javax.xml.parsers.*;
import org.w3c.dom.*;
class ToXML extends Query&lt;Node&gt;{
  static Document doc;
  static {
   try{doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
   }catch (Exception e) {throw new RuntimeException(e);}
  }</pre>String<pre>  public Node eval(Object o){
    if (o instanceof Iterable)
      return doc.createElement(o.getClass().getSimpleName());
    return doc.createTextNode(o.toString());
  }</pre>eval<pre>  public Node eval(Node x,Node y){x.appendChild(y);return x;}
}</pre>
<pre>package name.panitz.boilerplate;
import org.w3c.dom.Node;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.StringWriter; 

class TestToXML{
  public static void main(String [] args){
    System.out.println(serialize(new ToXML().everything(MyComp.getCompany())));} </pre>String<pre>  static public String serialize(Node doc){
    try{
      StringWriter writer = new StringWriter();
      javax.xml.transform.Transformer t
        = TransformerFactory.newInstance().newTransformer();
      t.setOutputProperty(OutputKeys.INDENT,"yes");
      t.transform(new DOMSource(doc),new StreamResult(writer));
      return writer.getBuffer().toString();
    }catch (TransformerException _){return "";}
  }
}</pre>
<h3>9.2.6. Controling the traversal</h3>ToXMLStringcutQuerycondition<pre>package name.panitz.boilerplate;
import java.util.*;
abstract class QuerySome&lt;a&gt; 
        implements Function1&lt;Object,a&gt;,Function2&lt;a,a,a&gt;{
  public abstract boolean condition(Object o);</pre>gmap<pre>  public List&lt;a&gt; gmap(Object x){
    List&lt;a&gt; result= new ArrayList&lt;a&gt;();
    if (condition(x) &amp;&amp; x instanceof Iterable) 
      for (Object a:((Iterable)x)) result.add(eval(a));
    return result;
  }</pre>Query<pre>  public a everything(Object x){
    a result = eval(x);
    final QuerySome&lt;a&gt; dies = this;
    QuerySome&lt;a&gt; everythingQ = null;
    if (everythingQ==null)
      everythingQ = new QuerySome&lt;a&gt;(){
       public a eval(Object o){return dies.everything(o);}
       public a eval(a x,a y) {return dies.eval(x,y);}
       public boolean condition(Object o){return dies.condition(o);}
      };
    for (a y:everythingQ.gmap(x)) result=eval(result,y);
    return result;
  }
}</pre>QueryQuerySometrue<pre>package name.panitz.boilerplate;
import java.util.*;
abstract class Query2&lt;a&gt; extends QuerySome&lt;a&gt;{
  public boolean condition(Object o){return true;}
}</pre>
<pre>package name.panitz.boilerplate;
import org.w3c.dom.*;
import java.util.*;
import static name.panitz.boilerplate.ToXML.*;
class ToXML2 extends QuerySome&lt;Node&gt;{
  public Node eval(Object o){
    if (o instanceof Person){
      Element p = doc.createElement("Person");
      Element n = doc.createElement("Name");
      Element a = doc.createElement("Address");
      n.appendChild(doc.createTextNode(((Person)o).name));
      a.appendChild(doc.createTextNode(((Person)o).address));
      p.appendChild(n);    
      p.appendChild(a);
      return p;    
    }    
    if (o instanceof Dept){
      Dept d =(Dept)o;
      Element result = doc.createElement("Dept");
      Element n = doc.createElement("Name");
      n.appendChild(doc.createTextNode(d.name));
      result.appendChild(n);
      result.appendChild(everything(d.manager));
      for (SubUnit su:d.subUnits) result.appendChild(everything(su));
      return result;
    }
    if (o instanceof Iterable)
      return doc.createElement(o.getClass().getSimpleName());
    return doc.createTextNode(o.toString());
  }
  public boolean condition(Object o){
    return ! (o instanceof Person||o instanceof Dept);}
  public Node eval(Node x,Node y){x.appendChild(y);return x;}
}</pre>company.dtd<pre>package name.panitz.boilerplate;
import static  name.panitz.boilerplate.TestToXML.*;
class TestToXML2 extends ToXML2{
  public static void main(String [] args){
    System.out.println(serialize(new ToXML2().everything(MyComp.getCompany())));}}</pre>
<h3>9.2.7. Conclusion</h3>gmapeverywhereeverhting<h4>9.2.7.1. Future Work</h4>ToXMLShow<h3>9.2.8. Company classes</h3>
<pre>package name.panitz.boilerplate;
import java.util.*;
class Company extends ArrayList&lt;Dept&gt;{}</pre>
<pre>package name.panitz.boilerplate;
import java.util.*;
class Dept implements Iterable&lt;Object&gt;{
  String name;
  Employee manager;
  List&lt;SubUnit&gt; subUnits;
  Dept(String name,Employee manager,List&lt;SubUnit&gt; subUnits){
    this.name=name;this.manager=manager;this.subUnits=subUnits;}
  public Iterator&lt;Object&gt; iterator(){
    List&lt;Object&gt; result = new ArrayList&lt;Object&gt;();
    result.add(name);result.add(manager);result.add(subUnits);
    return result.iterator();
  }
}</pre>
<pre>package name.panitz.boilerplate;
import java.util.*;
class SubUnit implements Iterable&lt;Object&gt;{
  public Iterator&lt;Object&gt; iterator(){return new ArrayList&lt;Object&gt;().iterator();}
}</pre>
<pre>package name.panitz.boilerplate;
import java.util.*;
class PU extends SubUnit{
  Employee employee;
  PU(Employee employee){this.employee=employee;}
  public Iterator&lt;Object&gt; iterator(){
    List&lt;Object&gt; result = new ArrayList&lt;Object&gt;();result.add(employee);
    return result.iterator();
  }
}</pre>
<pre>package name.panitz.boilerplate;
import java.util.*;
class DU extends SubUnit{
  Dept dept;
  DU(Dept dept){this.dept=dept;}
  public Iterator&lt;Object&gt; iterator(){
    List&lt;Object&gt; result = new ArrayList&lt;Object&gt;();result.add(dept);
    return result.iterator();
  }
}</pre>
<pre>package name.panitz.boilerplate;
import java.util.*;
class Employee implements Iterable&lt;Object&gt;{
  Person person;Salary salary;
  Employee(Person person,Salary salary){this.person=person;this.salary=salary;}
  public Iterator&lt;Object&gt; iterator(){
    List&lt;Object&gt; result = new ArrayList&lt;Object&gt;();
    result.add(person);result.add(salary);
    return result.iterator();
  }
}</pre>
<pre>package name.panitz.boilerplate;
import java.util.*;
class Person implements Iterable&lt;Object&gt;{
  String name;String address;
  Person(String name,String address){this.name=name;this.address=address;}
  public Iterator&lt;Object&gt; iterator(){
    List&lt;Object&gt; result = new ArrayList&lt;Object&gt;();
    result.add(name);result.add(address);
    return result.iterator();
  }
}</pre>
<pre>package name.panitz.boilerplate;
import java.util.*;
class Salary implements Iterable&lt;Object&gt;{
  Double amount;
  Salary(Double amount){this.amount=amount;}
  public Iterator&lt;Object&gt; iterator(){
    List&lt;Object&gt; result = new ArrayList&lt;Object&gt;();result.add(amount);
    return result.iterator();
  }
}</pre>
<h2>9.3. Generierung von Code mit APT</h2>
<h3>9.3.1. ADT</h3>
<pre>data Tree a = 
   Branch (Tree a) a (Tree a)
  |Empty</pre>
<pre>size Empty          = 0
size (Branch l a r) = size l + 1 + size r </pre>visitPizzaScala<h3>9.3.2. Annotations for Algebraic Types</h3>@Data@Constr<pre>package example.tree;
import name.panitz.adt.*;
@Data class T&lt;a&gt; {
  @Constr void Branch(T&lt;a&gt; left,a element,T&lt;a&gt; right){};
  @Constr void Empty(){};
}</pre>ScalaTjavacapt<h4>9.3.2.1. Algorithms on algebraic types</h4>TVisitorTAdtBranchEmptyvisit<pre>package example.tree;
public class TSize&lt;a&gt; extends TVisitor&lt;a,Integer&gt;{
  public Integer visit(Branch&lt;a&gt; x){
    return size(x.left) + 1 + size(x.right);}
  public Integer visit(Empty&lt;a&gt; _){return 0;}</pre>sizewelcomeTAdt<pre>  public int size(T&lt;a&gt; t){return ((TAdt&lt;a&gt;)t).welcome(this);}
}</pre>@Data@Constr<h3>9.3.3. Implementation</h3>
<pre>package name.panitz.adt;
public @interface Data{}</pre>
<pre>package name.panitz.adt;
public @interface Constr{}</pre>aptAnnotationProcessorFactory<pre>package name.panitz.adt;
import com.sun.mirror.apt.*;
import com.sun.mirror.declaration.*;
import java.util.*;

public class AdtGenFact implements AnnotationProcessorFactory{
  static final String DATA_ANNOT   = "name.panitz.adt.Data";
  static final String CONSTR_ANNOT = "name.panitz.adt.Constr";

  public AnnotationProcessor getProcessorFor
    (Set&lt;AnnotationTypeDeclaration&gt; types
    ,AnnotationProcessorEnvironment env){
      return new AdtGen(types,env);
  }
  public Collection&lt;String&gt; supportedAnnotationTypes(){
    ArrayList&lt;String&gt; result= new ArrayList&lt;String&gt;();
    result.add(CONSTR_ANNOT);result.add(DATA_ANNOT);
    return result;
  }
  public Collection&lt;String&gt; supportedOptions(){
    return new ArrayList&lt;String&gt;();
  }
}</pre>
<pre>package name.panitz.adt;
import com.sun.mirror.apt.*;
import com.sun.mirror.util.*;
import com.sun.mirror.declaration.*;
import java.util.*;
public class AdtGen extends SimpleDeclarationVisitor
                    implements AnnotationProcessor{
  Set&lt;AnnotationTypeDeclaration&gt; types;
  AnnotationProcessorEnvironment env;
  public AdtGen(Set&lt;AnnotationTypeDeclaration&gt; types
                 ,AnnotationProcessorEnvironment env){
    this.types=types;
    this.env=env;
    constrDeclaration = env.getTypeDeclaration(AdtGenFact.CONSTR_ANNOT);
    dataDeclaration = env.getTypeDeclaration(AdtGenFact.DATA_ANNOT);
  } 
  public void process(){
   for (TypeDeclaration td :env.getSpecifiedTypeDeclarations()){
      td.accept(this);
   }
  }</pre>com.sun.mirror.declaration<pre>  final private TypeDeclaration constrDeclaration;
  final private TypeDeclaration dataDeclaration;

  boolean hasAnnot(TypeDeclaration a,Declaration m){
    for (AnnotationMirror am : m.getAnnotationMirrors()) 
      if(am.getAnnotationType().getDeclaration().equals(a))
        return true;
    return false;
  }

  public void visitClassDeclaration(ClassDeclaration d){
   if (hasAnnot(dataDeclaration,d)){
    ADT adt = new ADT(env,d); 
    for (MethodDeclaration m:d.getMethods()){
      if (hasAnnot(constrDeclaration,m)){ 
        adt.addConstr(m.getSimpleName(),m.getParameters());
      }
    }
    adt.generateClasses();   
  }}}</pre>
<h4>9.3.3.1. representation of algebraic types</h4>ADT<pre>package name.panitz.adt;

import java.util.*;
import java.io.*;
import com.sun.mirror.declaration.*;
import com.sun.mirror.apt.*;

public class ADT {</pre>
            a name for the algebraic type.
            the package for the type.
            a list of constructors.
            furthermore we need 
the AnnotationProcessorEnvironment, which will give us a filer, for
generating new source files.
          <pre>  String name;
  String thePackage;
  public List&lt;Constructor&gt; constructors;
  TypeDeclaration cd;
  final Filer filer;</pre>
<pre>  public ADT
    (AnnotationProcessorEnvironment env,TypeDeclaration cd){
      thePackage = cd.getPackage().getQualifiedName();
      name=cd.getSimpleName();
      constructors=new ArrayList&lt;Constructor&gt;();
      this.cd=cd;
      filer=env.getFiler();
  }</pre>
<pre>  public String getFullName(){return cd.toString();}
  public String getName(){return name;}
  String commaSepPs(){
    final String qN=getFullName();
    final int index=qN.indexOf('&lt;');
    return index&gt;=0?qN.substring(index+1,qN.length()-1):"";
  }
  public String getParamList(){
    return commaSepPs().length()==0?"":("&lt;"+commaSepPs()+"&gt;");
  }
  String getPackageDef(){
    return  thePackage.length()==0?""
           :"package "+thePackage+";\n\n";
  }</pre>ConstructorADT<pre>  void addConstr(String n,Collection&lt;ParameterDeclaration&gt; ps){
   constructors.add(new Constructor(n,ps));
}</pre>
            a common base class for the type,
            a visitor interface,
            and for each constuctor a subclass of the base class.
          <pre>  public void generateClasses(){
    try{generateClass();
        generateVisitorClass();
        for (Constructor c:constructors)c.generateClass(this);
    }catch (IOException _){}}</pre>
The base class extends the class, which has been annotated 
as @Data class. It has the same name with suffix Adt.
We use the filer to create the source for the base class:<pre>  public void generateClass() throws IOException{
    final String fullName = getFullName();
    Writer out 
     = filer.createSourceFile(thePackage+"."+name+"Adt");</pre>
The generated class is abstract.<pre>    out.write( getPackageDef());
    out.write("public abstract class ");
    out.write(getName()+"Adt"+getParamList());
    out.write(" extends "+fullName+"\n");
    out.write(" implements Iterable&lt;Object&gt;{\n");</pre>
It has the abstract   
method welcome. This is the method that welcomes a 
visitor.This usually is called accept. 
It is an generic method. Its type variable, which we hard coded 
as b_, represents the result type of the visitor.<pre>    out.write("  abstract public &lt;b_&gt; b_ welcome("
            +name+"Visitor&lt;" + commaSepPs()
                            +(commaSepPs().length()==0?"":",")
                            +"b_&gt; visitor);\n");  
    out.write("}");
    out.close();
  }</pre>
The next class that gets generated is the general visitor class. We decided
for an abstract class, which has an abstract 
method visit for each constructor, and additionally a concrete general
method visit overloaded for the base class. This ensures that cases,
which were forgotten to be implemented in a concrete visitor class
will cause a runtime exception.

The visitor class is generic. It has the type variables of the base class and
additionally a type variable for the result type of the 
methods visit.<pre>  public void generateVisitorClass(){
    try{
      final String csName = name+"Visitor";	
      final String fullName
       = csName+"&lt;"+commaSepPs()
                   +(commaSepPs().length()==0?"":",")+"result&gt;";
      Writer out=filer.createSourceFile(thePackage+"."+csName);
      out.write( getPackageDef()+ "\n");
      out.write("public abstract class ");
      out.write(fullName+"{\n");
      for (Constructor c:constructors) 
        out.write("  "+c.mkVisitMethod(this)+"\n");

      out.write("  public result visit("+getFullName()+" xs){");
      out.write("\n    throw new RuntimeException(");
      out.write("\"unmatched pattern: \"+xs.getClass());\n");
      out.write("  }\n}");
      out.close();
    }catch (Exception _){}
  }</pre>
<h4>9.3.3.2. Generating constructor classes</h4>ADT<pre>private class Constructor {</pre>
<pre>  String name;
  Collection&lt;ParameterDeclaration&gt; params;</pre>
<pre>  public Constructor
             (String n,Collection&lt;ParameterDeclaration&gt; ps){
    name=n;params=ps;}</pre>
<pre>  public void generateClass(ADT theType){
    try{
      Writer out
        = filer.createSourceFile(theType.thePackage+"."+name);
      out.write( theType.getPackageDef());
      out.write("public class "+name);
      out.write(theType.getParamList()+" extends ");
      out.write(theType.getName()+"Adt"+theType.getParamList());
      out.write("{\n");</pre>
            fields for the arguments of the constructor.
            the method welcome
            the method equals
            the method toString
            the method iterator
          <pre>      mkFields(out);
      mkConstructor(out);
      mkWelcomeMethod(theType, out);
      mkToStringMethod(out);
      mkEqualsMethod(out);
      mkIteratorMethod(out);
      out.write("}\n");out.close();
    }catch (Exception _){}
  }</pre>
For every argument of the constructor we generate a  field in the
      class. <pre>  private void mkFields(Writer out)throws IOException{
    for (ParameterDeclaration p:params){
     out.write("  public "+p.getType().toString()+" ");
     out.write(p.getSimpleName());
     out.write(";\n");
    }
  }</pre>
A single constructor is generated, which initializes the  fields.<pre>  private void mkConstructor(Writer out)throws IOException{
    out.write("\n  public "+name+"(");
    boolean first= true;
    for (ParameterDeclaration p:params){
      if (!first){out.write(",");}
      out.write(p.getType().toString()+" ");
      out.write(p.getSimpleName());
      first=false;
    }
    out.write("){\n");
    for (ParameterDeclaration p:params){
      out.write("    this."+p.getSimpleName()+" = ");
      out.write(p.getSimpleName()+";\n");
    }
    out.write("  }\n\n");
  }</pre>
For each private field a public get-method is generated.<pre>  private void mkGetterMethods(Writer out)throws IOException{
    for (ParameterDeclaration p:params){
      out.write("  public ");
      out.write(p.getType().toString());
      out.write(" get");
      out.write(
       Character.toUpperCase(p.getSimpleName().charAt(0)));
      out.write(p.getSimpleName().substring(1));
      out.write("(){return "+p.getSimpleName() +";}\n");
    }
  }</pre>
For each private field a public set-method is generated.<pre>  private void mkSetterMethods(Writer out)throws IOException{
    for (ParameterDeclaration p:params){
      out.write("  public void set");
      out.write(
       Character.toUpperCase(p.getSimpleName().charAt(0)));
      out.write(p.getSimpleName().substring(1));
      out.write("(");
      out.write(p.getType().toString());
      out.write(" ");
      out.write(p.getSimpleName());
      out.write("){this."+p.getSimpleName());
      out.write("= "+p.getSimpleName()+";}\n");
    }
  }</pre>
We generate the standard method welcome, which calls the 
method visit of the passed visitor with this object:<pre>  private void mkWelcomeMethod(ADT theType,Writer out)
         throws IOException{
      out.write("  public &lt;_b&gt; _b welcome("
		+theType.name+"Visitor&lt;"+theType.commaSepPs()
                      +(theType.commaSepPs().length()==0?"":",")
                                +"_b&gt; visitor){"
                +"\n    return visitor.visit(this);\n  }\n"); 
  }</pre>
For the sake of comfort, we also generate the method toString in a
natural way.<pre>  private void mkToStringMethod(Writer out) throws IOException{
    out.write("  public String toString(){\n");
    out.write("    return \""+name+"(\"");
    boolean first=true;
    for (ParameterDeclaration p:params){
     if (first){first=false;}
     else out.write("+\",\"");
     out.write("+"+p.getSimpleName());
    }
    out.write("+\")\";\n  }\n"); 
  }</pre>
In the same way a standard method equals is generated:<pre>  private void mkEqualsMethod(Writer out) throws IOException{
    out.write("  public boolean equals(Object other){\n");
    out.write("    if (!(other instanceof "+name+")) ");
    out.write("return false;\n");
    out.write("    final "+name+" o= ("+name+") other;\n");
    out.write("    return true  ");
    for (ParameterDeclaration p:params){
      out.write("&amp;&amp; "+p.getSimpleName()
                     +".equals(o."+p.getSimpleName()+")");
    }
    out.write(";\n  }\n"); 
  }</pre>
In the same way a  method iterator is generated. This enables us to
apply the scrap your boilerplate 
code pattern to the generated
algebraic type. <pre>  private void mkIteratorMethod(Writer out) throws IOException{
    out.write("  public java.util.Iterator&lt;Object&gt;iterator(){");
    out.write("\n    java.util.List&lt;Object&gt; res\n");
    out.write("         =new java.util.ArrayList&lt;Object&gt;();\n");
    for (ParameterDeclaration p:params)
      out.write("    res.add("+p.getSimpleName()+");\n");
    out.write("    return res.iterator();\n  }\n"); 
  }</pre>
For each constructor an abstract method visit had been generated in
the general abstract visitor class. This was done by calls to the following
method. <pre>  public String mkVisitMethod(ADT theType){
    return "public abstract result visit("
            +name+theType.getParamList()+" _);";
  }
}}</pre>
<h3>9.3.4. Example: a tiny imperativ programming language</h3>@Data<pre>package name.panitz.adt.examples;
import name.panitz.adt.*;
import java.util.List;

abstract @Data class Klip implements Iterable&lt;Object&gt; {
  @Constr void Num(Integer i){};
  @Constr void Add(Klip e1,Klip e2){};
  @Constr void Mul(Klip e1,Klip e2){};
  @Constr void Sub(Klip e1,Klip e2){};
  @Constr void Div(Klip e1,Klip e2){};
  @Constr void Var(String name){};
  @Constr void Assign(String var,Klip e){};
  @Constr void While(Klip cond,Klip body){};
  @Constr void Block(List&lt;Klip&gt; stats){};
}</pre>
<h4>9.3.4.1. Show</h4>String<pre>package name.panitz.adt.examples;
import name.panitz.*;
import java.util.*;

public class ShowKlip extends KlipVisitor&lt;String&gt; {
  public String s(Klip a){return ((KlipAdt)a).welcome(this);}

  public String visit(Num x){return x.i.toString();}
  public String visit(Add x){return"("+s(x.e1)+"+"+s(x.e2)+")";}
  public String visit(Sub x){return"("+s(x.e1)+"-"+s(x.e2)+")";}
  public String visit(Div x){return"("+s(x.e1)+"/"+s(x.e2)+")";}
  public String visit(Mul x){return"("+s(x.e1)+"*"+s(x.e2)+")";}
  public String visit(Var v){return v.name;}
  public String visit(Assign x){return x.var+" := "+s(x.e);}
  public String visit(Block b){
    StringBuffer result=new StringBuffer();
    for (Klip x:b.stats)  result.append(s(x)+";\n");
    return result.toString();}
  public String visit(While w){
    StringBuffer result=new StringBuffer("while (");
    result.append(s(w.cond)+"){\n");
    result.append(s(w.body)+"\n}");
    return result.toString();}
}</pre>
<pre>x := 5;
y := 1;
while (x){
y := (y*x);
x := (x-1);

};
y;</pre>
<h4>9.3.4.2. Evaluation visitor</h4>
<pre>package name.panitz.adt.examples;
import name.panitz.*;
import java.util.*;

public class EvalKlip extends KlipVisitor&lt;Integer&gt; {
 Map&lt;String,Integer&gt; env = new HashMap&lt;String,Integer&gt;();
 public Integer v(Klip x){return ((KlipAdt)x).welcome(this);}

 public Integer visit(Num x){return x.i;}
 public Integer visit(Add x){return v(x.e1)+v(x.e2);}
 public Integer visit(Sub x){return v(x.e1)-v(x.e2);}
 public Integer visit(Div x){return v(x.e1)/v(x.e2);}
 public Integer visit(Mul x){return v(x.e1)*v(x.e2);}
 public Integer visit(Var v){return env.get(v.name);}
 public Integer visit(Assign ass){
   final Integer i = v(ass.e);env.put(ass.var,i);
   return i;}
 public Integer visit(Block b){
    Integer result = 0;
    for (Klip x:b.stats) result=v(x);
    return result;}
 public Integer visit(While w){
    Integer result = 0;
    while (v(w.cond)!=0) result = v(w.body);
    return result;}
}</pre>
<h4>9.3.4.3. Generic queries</h4>Iterable&lt;Object&gt;scrap your 
boilerplateQueryTransform
The following simple example
collects all variable names within an abstract syntax tree.<pre>package name.panitz.adt.examples;
import name.panitz.boilerplate.Query;
import java.util.*;
class GetVars extends Query&lt;Set&lt;String&gt;&gt;{
  public Set&lt;String&gt; eval(Object x){
    Set&lt;String&gt; result = new HashSet&lt;String&gt;(); 
    if (x instanceof Var) result.add(((Var)x).name);
    if (x instanceof Assign) result.add(((Assign)x).var);
    return result;
  }
  public Set&lt;String&gt; eval(Set&lt;String&gt; x,Set&lt;String&gt; y){
    x.addAll(y);
    return x;
  }
}</pre>
The following transformer adds a prefix to every variable name occuring in the
abstract syntax tree.<pre>package name.panitz.adt.examples;
import name.panitz.boilerplate.Transform;
import java.util.*;
public class AddPrefix extends Transform{
  final String prefix;
  public AddPrefix(String prefix){this.prefix=prefix;}
  public void transform(Object x){
    if (x instanceof Var) ((Var)x).name=prefix+((Var)x).name;
    else if (x instanceof Assign) 
       ((Assign)x).var=prefix+((Assign)x).var;;
  }
}</pre>javaccat 
the corresponding website to this paper<pre>package name.panitz.adt.examples;
import java.io.FileReader;
public class TestKlip{
  public static void main(String [] args)throws Exception{
   final Klip klip = new KlipParser(new FileReader(args[0]))
                    .statementList();

   System.out.println(new ShowKlip().s(klip));
   System.out.println(new EvalKlip().v(klip));
   System.out.println(new GetVars().everything(klip));
   new AddPrefix("$").everywhere(klip);
   System.out.println(new ShowKlip().s(klip));
  }
}</pre>
<h3>9.3.4.1. javacc Parser f&uuml;r Klip</h3>
<pre>package name.panitz.adt;
public class Pair&lt;a,b&gt;{
  a e1;
  b e2;
  Pair(a e1,b e2){this.e1=e1;this.e2=e2;}
}</pre>javacc<pre>options {
   STATIC=false;
}

PARSER_BEGIN(KlipParser)
package name.panitz.adt.examples;

import  name.panitz.adt.Pair;
import java.util.*;
import java.io.FileReader;

public class KlipParser  {
  public static void main(String [] args)throws Exception{
    final Klip klip = new KlipParser(new FileReader(args[0]))
                     .statementList();

    System.out.println(new ShowKlip().s(klip));
    System.out.println(new EvalKlip().v(klip));
    System.out.println(new GetVars().everything(klip));
    new AddPrefix("$").everywhere(klip);
    System.out.println(new ShowKlip().s(klip));
  }
}
PARSER_END(KlipParser)</pre>
<h4>9.3.4.4.1. Scanner</h4>javacc<pre>TOKEN :
{&lt;WHILE: "while"&gt;
|&lt;#ALPHA:	["a"-"z","A"-"Z","_","."]	&gt;
|&lt;NUM:		["0"-"9"]		&gt;
|&lt;#ALPHANUM:	&lt;ALPHA&gt; | &lt;NUM&gt;		&gt;
|&lt;NAME: &lt;ALPHA&gt; ( &lt;ALPHANUM&gt; )*&gt;
|&lt;ASS: ":="&gt;
|&lt;LPAR: "("&gt;
|&lt;RPAR: ")"&gt;
|&lt;LBRACKET: "{"&gt;
|&lt;RBRACKET: "}"&gt;
|&lt;SEMICOLON: ";"&gt;
|&lt;STAR: "*"&gt;
|&lt;PLUS: "+"&gt;
|&lt;SUB: "-"&gt;
|&lt;DIV: "/"&gt;
}</pre>
<pre>SKIP :
{ "\u0020"
| "\t"
| "\n"
| "\r"
}</pre>
<h4>9.3.4.4.2. Parser</h4>
<pre>Klip statementList() : 
{  List&lt;Klip&gt; stats = new ArrayList&lt;Klip&gt;();
   Klip stat;}
{ 
  (stat=statement() {stats.add(stat);} &lt;SEMICOLON&gt;)*
  {return new Block(stats);}
}</pre>
<pre>Klip statement():
{Klip e2;Klip result;boolean sub=false;}
{  
  result=multExpr() 
  [ (&lt;PLUS&gt;|&lt;SUB&gt;{sub=true;}) e2=statement() 
   {result = sub?new Sub(result,e2):new Add(result,e2);}]
  {return result;}
}</pre>
<pre>Klip multExpr():
{Klip e2;Klip result;boolean div= false;}
{  
  result=atomicExpr() 
  [ (&lt;STAR&gt;|&lt;DIV&gt;{div=true;}) 
    e2=multExpr() 
    {result = div?new Div(result,e2):new Mul(result,e2);}]
  {return result;}
}</pre>
<pre>Klip atomicExpr():
{Klip result;}
{  
   (result=integerLiteral()
   |result=varOrAssign()
   |result=whileStat()
   |result=parenthesesExpr()
   )
  {return result;}
}</pre>
<pre>Klip integerLiteral():
{ int result = 0;
  Token n;
  boolean m=false;}
{  [&lt;SUB&gt; {m = true;}]
   (n=&lt;NUM&gt;  
    {result=result*10+n.toString().charAt(0)-48;})+
   {return new Num(new Integer(m?-result:result));}
}</pre>
<pre>Klip parenthesesExpr():
{Klip result;}
{ &lt;LPAR&gt; result = statement() &lt;RPAR&gt;
{return result;}}</pre>
<pre>Klip varOrAssign():
{ Token n;Klip result;Klip stat;}
{ n=&lt;NAME&gt;{result=new Var(n.toString());} 
  [&lt;ASS&gt; stat=statement() 
    {result = new Assign(n.toString(),stat);}
  ]
  {return result;}
}</pre>while<pre>Klip whileStat():{
  Klip cond; Klip body;}
{ &lt;WHILE&gt; &lt;LPAR&gt;cond=statement()&lt;RPAR&gt; 
  &lt;LBRACKET&gt; body=statementList()&lt;RBRACKET&gt;
  {return new While(cond,body);}
}</pre>
<h4>9.3.4.4.3. Klip-Beispiele</h4>
<pre>2*7+14*2;</pre>
<pre>2*(7+9)*2;</pre>sep@linux:~&gt; java name.panitz.adt.examples.KlipParser arith1.klip
((2 * 7) + (14 * 2));

42
sep@linux:~&gt; java name.panitz.adt.examples.KlipParser arith2.klip
(2 * ((7 + 9) * 2));

64
sep@linux:~&gt;sep@linux:~&gt; java name.panitz.adt.examples.KlipParser fak.klip
x := 5;
y := 1;
while (x){
y := (y * x);
x := (x - 1);

};
y;

{y=1, x=5}
{y=5, x=4}
{y=20, x=3}
{y=60, x=2}
{y=120, x=1}
120
sep@linux:~&gt;<h3>9.3.5. Conclusion</h3>KlipAdtKlipapt<h1>10. XML</h1>
Der eigentliche Text des Dokuments sei:<pre>The Beatles White Album</pre>
Die einzelnen Bestandteile dieses Textes k&ouml;nnen markiert werden:<pre>&lt;cd&gt;
  &lt;artist&gt;The Beatles&lt;/artist&gt;
  &lt;title&gt;White Album&lt;/title&gt;
&lt;/cd&gt;</pre>W3C(recommendation)Man sagt, ein Pilot
brauche den Copiloten, damit dieser die Handb&uuml;cher f&uuml;r das 
Flugzeug tr&auml;gt.<h2>10.1. XML-Format</h2>
<pre>&lt;?xml version="1.0"?&gt;</pre>
<h3>10.1.1. Elemente</h3>Tagnamenname&lt;name&gt;&lt;/name&gt;Somit ist ein einfaches XML-Dokument ein solches
Dokument, in dem der gesammte Text mit einem einzigen Element markiert
ist:<pre>&lt;?xml version="1.0"?&gt;
&lt;myText&gt;Dieses ist der Text des Dokuments. Er ist
mit genau einem Element markiert.
&lt;/myText&gt;</pre>&lt;cd&gt;&lt;artist&gt;&lt;title&gt;Folgendes Dokument enth&auml;lt ein Element ohne Inhalt:<pre>&lt;?xml version="1.0"?&gt;
&lt;skript&gt;
  &lt;page&gt;erste Seite&lt;/page&gt;
  &lt;page&gt;&lt;/page&gt;
  &lt;page&gt;dritte Seite&lt;/page&gt;
&lt;/skript&gt;</pre>
<h4>10.1.1.1. Leere Elemente</h4>name&lt;name/&gt;Das vorherige Dokument l&auml;&szlig;t sich somit auch wie folgt schreiben:<pre>&lt;?xml version="1.0"?&gt;
&lt;skript&gt;
  &lt;page&gt;erste Seite&lt;/page&gt;
  &lt;page/&gt;
  &lt;page&gt;dritte Seite&lt;/page&gt;
&lt;/skript&gt;</pre>
<h4>10.1.1.2. Gemischter Inhalt</h4>(mixed content)Ein Dokument, in dem das oberste Element einen gemischten
Inhalt hat:<pre>&lt;?xml version="1.0"?&gt;
&lt;myText&gt;Der &lt;landsmann&gt;Italiener&lt;/landsmann&gt;
&lt;eigename&gt;Ferdinand Carulli&lt;/eigename&gt; war  als Gitarrist 
ebenso wie der &lt;landsmann&gt;Spanier&lt;/landsmann&gt; 
&lt;eigename&gt;Fernando Sor&lt;/eigename&gt; in &lt;ort&gt;Paris&lt;/ort&gt;
ans&auml;&szlig;ig.&lt;/myText&gt;</pre>
<h4>10.1.1.3. XML-Dokumente als B&auml;ume</h4>Das folgende ist kein g&uuml;ltiges XML-Dokument. Das 
Element &lt;bf&gt; wird geschlossen bevor das sp&auml;ter ge&ouml;ffnete
Element &lt;em&gt; geschlossen worde.<pre>&lt;?xml version="1.0"?&gt;
&lt;illegalDocument&gt;
  &lt;bf&gt;fette Schrift &lt;em&gt;kursiv und fett&lt;/bf&gt; 
  nur noch kursiv&lt;/em&gt;.
&lt;/illegalDocument&gt;</pre>
Das Dokument w&auml;re wie folgt als g&uuml;ltiges XML zu schreiben:<pre>&lt;?xml version="1.0"?&gt;
&lt;validDocument&gt;
  &lt;bf&gt;fette Schrift &lt;em&gt;kursiv und fett&lt;/em&gt;&lt;/bf&gt; 
  &lt;em&gt;nur noch kursiv&lt;/em&gt;.
&lt;/validDocument&gt;</pre>
Dieses Dokument hat eine hierarchische Struktur.<h3>10.1.2. Attribute</h3>Dokument mit einem Attribut f&uuml;r ein Element. <pre>&lt;?xml version="1.0"?&gt;
&lt;text&gt;Mehr Information zu XML findet man auf den Seiten
des &lt;link address="www.w3c.org"&gt;W3C&lt;/link&gt;.&lt;/text&gt;</pre>
<h3>10.1.3. Kommentare</h3>&lt;!----&gt;Im folgenden Dokument ist ein Kommentar eingef&uuml;gt:<pre>&lt;?xml version="1.0"?&gt;
&lt;drehbuch filmtitel="Ben Hur"&gt;
&lt;akt&gt;
  &lt;szene&gt;Ben Hur am Vorabend des Wagenrennens.
    &lt;!--Diese Szene mu&szlig; noch ausgearbeitet werden.--&gt;
  &lt;/szene&gt;
&lt;/akt&gt;
&lt;/drehbuch&gt;</pre>
<h3>10.1.4. Character Entities</h3>&lt;&gt;character entities&amp;;
          
            
              Entity
              Zeichen
              Beschreibung
            
            
            
              
                &amp;lt;
              
              
                &lt;
              
               (less than)
            
            
              
                &amp;gt;
              
              
                &gt;
              
               (greater than)
            
            
              
                &amp;amp;
              
              
                &amp;
              
               (ampersant)
            
            
              
                &amp;quot;
              
              
                "
              
               (quotation mark)
            
            
              
                &amp;apos;
              
              
                '
              
              (apostroph)
            
          
        Folgendes Dokument benutzt Character Entities um
mathematische Formeln zu schreiben:<pre>&lt;?xml version="1.0"?&gt;
&lt;gleichungen&gt;
  &lt;gleichung&gt;x+1&amp;gt;x&lt;/gleichung&gt;
  &lt;gleichung&gt;x*x&amp;lt;x*x*x f&uuml;r x&amp;gt;1&lt;/gleichung&gt;
&lt;/gleichungen&gt;</pre>
<h3>10.1.5. CDATA-Sections</h3>CData
SectionCData section&lt;![CDATA[]]&gt;Die im vorherigen Beispiel mit Character Entities
beschriebenen Formeln lassen sich innerhalb einer CDATA-Section wie
folgt schreiben.<pre>&lt;?xml version="1.0"?&gt;
&lt;formeln&gt;&lt;![CDATA[
  x+1&gt;x 
  x*x&lt;x*x*x f&uuml;r x &gt; 1
]]&gt;&lt;/formeln&gt;</pre>
<h3>10.1.6. Processing Instructions</h3>processing 
instruction&lt;??&gt;Ausschnitt aus dem XML-Dokument diesen Skripts, in dem auf
ein Stylesheet verwiesen wird, da&szlig; das Skript in eine HTML-Darstellung
umwandelt:<pre>&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet 
   type="text/xsl" 
   href="../transformskript.xsl"?&gt;

&lt;skript&gt;
&lt;titelseite&gt;
&lt;titel&gt;Grundlagen der Datenverarbeitung&lt;white/&gt;II&lt;/titel&gt;
&lt;semester&gt;WS 02/03&lt;/semester&gt;
&lt;/titelseite&gt;
&lt;/skript&gt;</pre>
<h3>10.1.7. Namensr&auml;ume</h3>TagnamenTagnamenTagnamen istTagnamenTagnamenTagnamen
          dem Pr&auml;fix, der vor dem Doppelpunkt steht.
          dem lokalen Namen, der nach dem Doppelpunkt folgt.
        Tagnamenxmlns:myPrefix="http://www.myAdress.org/myNamespace"
Ein Beispiel f&uuml;r ein XML-Dokument, da&szlig; den Pr&auml;fix sep an
einem bestimmten Namensraum gebunden hat:<pre>&lt;?xml version="1.0"?&gt;
&lt;sep:skript 
   xmlns:sep="http://www.tfh-berlin.de/~panitz/dv2"&gt;
  &lt;sep:titel&gt;Grundlagen der DV 2&lt;/sep:titel&gt;
  &lt;sep:autor&gt;Sven Eric Panitz&lt;/sep:autor&gt;
&lt;/sep:skript&gt;
</pre>
<h2>10.2. Codierungen</h2>Codierung&szlig;CodierungCodierungenDieses Skript ist in einer Codierung gespeichert, die f&uuml;r
westeurop&auml;ische Dokumente gut geeignet ist, da es f&uuml;r die
verschiedenen Sonderzeichen der westeurop&auml;ischen Schriften einen
Zahlenwert im 8-Bit-Bereich zugeordnet hat. Die Codierung mit dem 
Namen: iso-8859-1. Diese wird im Kopf des Dokuments
angegeben:<pre>&lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
&lt;skript&gt;&lt;kapitel&gt;blablabla&lt;/kapitel&gt;&lt;/skript&gt;</pre>utf-8utf-16Unicode<h2>10.3. Dokumente als B&auml;ume in Java</h2>
<h3>10.3.1. APIs f&uuml;r XML</h3>
<h4>10.3.1.1. DOM</h4>distributed object  
modelldomdomdom
Die zentrale Schnittstelle in dom ist Node. Sie hat als
Unterschnittstellen alle Knotentypen, die es in XML gibt. Folgende Graphik 
gibt &uuml;ber diese Knotentypen einen &Uuml;berblick.<pre>interface org.w3c.dom.Node
 | 
 |--interface org.w3c.dom.Attr
 |--interface org.w3c.dom.CharacterData
 |   | 
 |   |--interface org.w3c.dom.Comment
 |   |--interface org.w3c.dom.Text
 |       |
 |       |--interface org.w3c.dom.CDATASection
 | 
 |--interface org.w3c.dom.Document
 |--interface org.w3c.dom.DocumentFragment
 |--interface org.w3c.dom.DocumentType
 |--interface org.w3c.dom.Element
 |--interface org.w3c.dom.Entity
 |--interface org.w3c.dom.EntityReference
 |--interface org.w3c.dom.Notation
 |--interface org.w3c.dom.ProcessingInstruction</pre>

Eine der entscheidenen Methoden der 
Schnittstelle Node selektiert die Liste der Kinder eines Knotens:public NodeList getChildNodes()

Knoten, die keine Kinder haben k&ouml;nnen (Textknoten, Attribute etc.) geben bei
dieser Methode die leere Liste zur&uuml;ck. Attribute z&auml;hlen auch wie in unserer
Modellierung nicht zu den Kindern eines Knotens. Um an die Attribute zu
gelangen, gibt es eine eigene Methode:NamedNodeMap getAttributes()


Wie man sieht, benutzt Javas dom Umsetzung keine von Javas
Listenklassen zur Umsetzung einer Knotenliste, sondern nur genau die 
in dom spezifizierte Schnittstelle NodeList. 
Eine NodeList hat genau zwei Methoden:<pre>int getLength()
Node item(int index)</pre>

Dieses ist insofern schade, da somit nicht die 
neue for-Schleife aus Java 1.5 f&uuml;r die Knotenliste 
des dom benutzt werden kann. 
Wir ben&ouml;tigen einen Parser, der uns die Baumstruktur eines XML-Dokuments
erzeugt. In der Javabibliothek ist ein solcher Parser integriert, allerdings
nur &uuml;ber seine Schnittstellenbeschreibung. 
Im Paket javax.xml.parsers gibt es nur Schnittstellen. Um einen
konkreten Parser zu erlangen, bedient man sich einer Fabrikmethode: In der
Schnittstelle DocumentBuilderFactory gibt es eine statische 
Methode newInstance und &uuml;ber 
das  DocumentBuilderFactory-Objekt, l&auml;&szlig;t sich mit der 
Methode newDocumentBuilder ein Parser erzeugen.
Wir k&ouml;nnen so eine statischen Methode zum Parsen eines XML-Dokuments
schreiben: <pre>package name.panitz.domtest;

import org.w3c.dom.Document;
import javax.xml.parsers.*;
import java.io.File;

public class ParseXML {
  public static Document parseXml(String xmlFileName){
    try{
     return
      DocumentBuilderFactory
       .newInstance()
       .newDocumentBuilder()
       .parse(new File(xmlFileName));
    }catch(Exception _){return null;}
  }

  public static void main(String [] args){
   System.out.println(parseXml(args[0]));
  }
}</pre>
Wir k&ouml;nnen jetzt z.B. den Quelltext dieses Skripts parsen.sep@linux:~/fh/prog4/examples&gt; java -classpath classes/ name.panitz.domtest.ParseXML ../skript.xml
[#document: null]

Wie man sieht ist die Methode toString in der implementierenden
   Klasse der Schnittstelle Document, die unser Parser benutzt nicht
   sehr aufschlu&szlig;reich.

Wir k&ouml;nnen  versuchen f&uuml;r das dom-Objekten &auml;hnliche Methoden zu
schreiben, wie f&uuml;r die B&auml;ume im vorangegangenen Kapitel. 

Zun&auml;chst z&auml;hlen wir wieder alle Knoten im Dokument:<pre>package name.panitz.domtest;

import org.w3c.dom.Node;

public class CountNodes{
  static int count(Node node){
    int result = 1;
    for (Node n:new NoteListIterator(node.getChildNodes()))
      result=result+count(n);
    return result; 
  }
  public static void main(String [] args){
    System.out.println(count(ParseXML.parseXml(args[0])));
  }
}</pre>

Hierbei haben wir in der for-Schleife f&uuml;r Objekte die die 
Schnittstelle NodeList implementieren einen Wrapper benutzt, der
diese Objekte zu einem Iteratorobjekt verpackt. <pre>package name.panitz.domtest;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import java.util.Iterator;

public class NoteListIterator implements Iterator&lt;Node&gt;
                                       , Iterable&lt;Node&gt;{
  NodeList nodes;
  int current=-1;
  public NoteListIterator(NodeList n){nodes=n;}

  public Node next(){
    current=current+1; return nodes.item(current);}

  public boolean hasNext(){return current+1&lt;nodes.getLength();}

  public void remove(){
    throw new UnsupportedOperationException();
  }

  public Iterator&lt;Node&gt; iterator(){return this;}
}</pre>
Wir k&ouml;nnen uns zum Beispiel die Anzahl der Knoten in diesem Skript ausgeben
lassen:sep@linux:~/fh/prog4&gt; java -classpath classes/ name.panitz.domtest.CountNodes skript.xml
1316

Als einen weiteren Algorithmus k&ouml;nnen wir wieder die maximale Pfadl&auml;nge
berechnen lassen:<pre>package name.panitz.domtest;

import org.w3c.dom.Node;

public class DomDepth{
  static int depth(Node node){
    int result = 0;
    for (Node n:new NoteListIterator(node.getChildNodes())){
      final int currentDepth = depth(n);
      if (result&lt;currentDepth) result=currentDepth;
    }
    return result+1; 
  }
  public static void main(String [] args){
    System.out.println(depth(ParseXML.parseXml(args[0])));
  }
}</pre>
Auch dieses l&auml;&szlig;t sich wunderbar mit dem Quelltext dieses Skriptes testen.sep@linux:~/fh/prog4&gt; java -classpath classes/ name.panitz.domtest.DomDepth skript.xml
13
Das DOM Api erm&ouml;glicht nicht nur in einem XML-Baum beliebig zu navigieren,
sondern auch diesen Baum zu manipulieren. Es lassen sich neue Knoten einh&auml;ngen
und bestehende Knoten l&ouml;schen. Hierzu stehen in der 
Schnittstelle Node entsprechende Methoden zur Verf&uuml;gung:<pre>Node appendChild(Node newChild)      throws DOMException;
Node insertBefore(Node newChild,Node refChild)
                                      throws DOMException;
Node replaceChild(Node newChild,Node oldChild)
                                      throws DOMException;
Node removeChild (Node oldChild)      throws DOMException;</pre>

Speziellere Methoden zum Manipulieren der verschieden Baumknoten finden sich
in den Unterschnittstellen von Node.

Zum Erzeugen eines neuen Knotens ist es notwendig den Dokumentknoten des zu
manipulierenden Knotens zu kennen. Der Dokumentknoten eines Knotens 
l&auml;&szlig;t sich &uuml;ber die
Methode Document getOwnerDocument() erfragen. Hier gibt es dann
Methoden zur Erzeugung neuer Knoten:<pre>Attr createAttribute(String name); 
Attr createAttributeNS(String namespaceURI, String qualifiedName); 
CDATASection createCDATASection(String data);
Comment createComment(String data);
DocumentFragment createDocumentFragment(); 
Element createElement(String tagName);
Element createElementNS
                 (String namespaceURI, String qualifiedName); 
EntityReference createEntityReference(String name); 
ProcessingInstruction createProcessingInstruction
                                  (String target, String data); 
Text createTextNode(String data); </pre>
<h4>10.3.1.2. SAX</h4>SAXsimple api for xml processingSAXSAXDefaultHandlerhandler
Auch ein SAX-Parser liegt in Java nur als Schnittstelle vor und kann nur &uuml;ber
eine statische Fabrikmethode instanziiert werden.<pre>package name.panitz.saxtest;
import org.xml.sax.helpers.DefaultHandler;
import javax.xml.parsers.*;
import org.xml.sax.*;
import java.io.File;

public class SaxParse{
  public static void parse(File file,DefaultHandler handler)
                               throws Exception{
    SAXParserFactory.newInstance()
                    .newSAXParser()
                    .parse(file,handler); 
  }  
}</pre>
Als erstes Beispiel wollen wir unser altbekanntes Z&auml;hlen der Knoten
  programmieren.  Hierzu ist ein eigener DefaultHandler zu schreiben,
der, sobald beim Vorlesen ihm der Beginn eines Elements gemeldet wird, darauf
  reagiert, indem er seinen Z&auml;hler um eins weiterz&auml;hlt. 
Wir &uuml;berschreiben demnach
  genau eine Methode aus dem DefaultHandler, n&auml;mlich die 
Methode startElement: <pre>package name.panitz.saxtest;
import org.xml.sax.helpers.DefaultHandler;
import java.util.*;
import org.xml.sax.*;

public class SaxCountNodes extends DefaultHandler{
  public int result = 0;
  public void startElement
   (String uri, String localName
   , String qName, Attributes attributes)
                          throws SAXException {
    result=result+1;
  }

  public static void main(String [] args) throws Exception{
    SaxCountNodes counter = new SaxCountNodes();
    SaxParse.parse(new java.io.File(args[0]),counter);
    System.out.println(counter.result); 
  }
}</pre>
In einem n&auml;chsten Beispiel f&uuml;r einen Handler, schreiben wir einen Handler, der
    bestimmte Knoten selektiert und in einer Ergebnisliste sammelt.

Wir wollen die code Knoten aus diesem Skript selektieren.
Hierzu k&ouml;nnen wir als
algebraischen Datentypen einfach eine Klasse vorsehen, die ein Codefragment
aus dem Skript darstellt. Dieses hat einen Programmnamen, ein Paketnamen und
schlie&szlig;lich den darin enthaltenen Code.<pre>package name.panitz.saxtest;
data class CodeFragment {
  CodeFragment(String progName,String packageName,String code);
}</pre>

Der entsprechende Handler sammelt die ben&ouml;tigte Information auf.<pre>package name.panitz.saxtest;
import org.xml.sax.helpers.DefaultHandler;
import java.util.*;
import org.xml.sax.*;

public class SelectNodes extends DefaultHandler{
  final List&lt;String&gt; names;
  final List&lt;CodeFragment&gt; result = new ArrayList&lt;CodeFragment&gt;();

  public SelectNodes(List&lt;String&gt; ls){names=ls;}
  public SelectNodes(String ls){
    names=new ArrayList&lt;String&gt;(); names.add(ls);}

  private StringBuffer currentCode = new StringBuffer();
  private String currentProgName = "";
  private String currentPackageName = "";

  public void startElement
   (String uri, String localName, String qName, Attributes attributes)
                throws SAXException {
     if (names.contains(qName)){
       currentCode = new StringBuffer();
       currentProgName = attributes.getValue("class");
       currentPackageName = attributes.getValue("package");
     }    
  }

  public void endElement
    (String uri, String localName, String qName)
                throws SAXException {
     if (names.contains(qName)){
       result.add(
         new CodeFragment
            (currentProgName
            ,currentPackageName
            ,currentCode.toString()));
     }    
  }

  public void characters(char[] ch,int start,int length)
                throws SAXException {
    currentCode.append(ch,start,length);
  }
}</pre>

Den obigen Handler k&ouml;nnen wir jetzt z.B. benutzen, um aus dem Quelltext dieses
Skriptes bestimmte Beispielklassen zu extrahieren und in eine Javadatei zu
speichern. <pre>package name.panitz.saxtest;

import javax.xml.parsers.*;
import java.io.*;

public class GetCode {
  public static void main(String [] args) throws Exception{
    final  SelectNodes selectCodeHandler = new SelectNodes("code"); 

    SaxParse.parse(new File(args[0]),selectCodeHandler); 
    final Writer out = new FileWriter(args[1]+".java"); 

    for (CodeFragment cf:selectCodeHandler.result){
      if (args[1].equals(cf.getProgName()))
        out.write(cf.getCode());
    }
    out.flush();
    out.close();
  }
}</pre>handlers<h2>10.4. Transformationen und Queries</h2>
<h3>10.4.1. XPath: Pfade in Dokumenten</h3>/home/sep/fh/prog4/skript.xml/skript/kapitel/section/subsection/codecodesubsectionsectionkapitelskript
          Zum Selektieren bestimmter Knoten in einem Dokument. Ausgehend von einem
Wurzelknoten werden anhand des Ausdrucks aus dem Baum bestimmte Knoten 
selektiert.
          Zum Pr&uuml;fen, ob ein Knoten die in dem Pfad beschriebene Eigenschaft
hat. Ausgehend von einem Knoten wird anhand des Ausdrucks getestet, ob er
diese beschriebene Pfadeigenschaft hat.
        <h4>10.4.1.1. Achsen</h4>
<pre>package name.panitz.xml.xpath;
public enum AxisType 
  {self
  ,child
  ,descendant
  ,descendant_or_self
  ,parent
  ,ancestor
  ,ancestor_or_self
  ,following_sibling
  ,following
  ,preceding_sibling
  ,preceding
  ,namespace
  ,attribute
}</pre>
Wir schreiben eine Klasse mit statischen Methoden zur Berechnung der
Achsen. Da in DOM nicht die Listen aus java.util benutzt werden
sondern die Schnittstelle org.w3c.dom.Nodelist, schreiben wir zun&auml;chst
eine kleine Methode, die eine NodeList in 
eine java.util.List&lt;Node&gt; umwandelt.<pre>package name.panitz.xml.xpath;
import name.panitz.crempel.util.FromTo;
import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.*;
import name.panitz.domtest.*;

public class Axes{
  public static List&lt;Node&gt; nodelistToList (NodeList nl){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (int i:new FromTo(0,nl.getLength()-1)){
      result.add(nl.item(i));
    }
    return result;
  }</pre>
Die einfachste Achse liefert genau den Knoten selbst. Die entsprechende
  Methode liefert die einelementige Liste des Eingabeknotens: <pre>  public static List&lt;Node&gt; self(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    result.add(n);
    return result;
  }</pre>
Die gebr&auml;uchlichste Achse beschreibt die Menge aller Kinderknoten. Wir lassen
uns die Kinder des DOM Knotens geben und konvertieren 
die NodeList zu einer Javaliste:<pre>  public static List&lt;Node&gt; child(Node n){
    return nodelistToList(n.getChildNodes());
  }</pre>
Die Nachkommen sind Kinder und deren Nachkommen. F&uuml;r f&uuml;gen jedes Kind zur
Ergebnisliste hinzu, sowie alle deren Nachkommen: <pre>  public static List&lt;Node&gt; descendant(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (Node child:child(n)){
      result.add(child);
      result.addAll(descendant(child));
    }
    return result;
  }</pre>
In der Nachkommenachse taucht der Knoten selbst nicht auf. Diese Achse f&uuml;gt
den Knoten selbst zus&auml;tzlich ans Ergebnis an:<pre>  public static List&lt;Node&gt; descendant_or_self(Node n){
    List&lt;Node&gt; result = self(n);
    result.addAll(descendant(n));
    return result;
  }</pre>
Die Kinderachse lief in den Baum Richtung Bl&auml;tter eine Ebene nach unten, die
Elternachse l&auml;uft diese eine Ebene Richtung Wurzel nach oben:<pre>  public static List&lt;Node&gt; parent(Node n){
     List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
     result.add(n.getParentNode());
     return result;
  }</pre>
Die Vorfahrenachse ist der transitive Abschlu&szlig; &uuml;ber die Elternachse, sie
bezeichnet also die Eltern und deren Vorfahren:<pre>  public static List&lt;Node&gt; ancestor(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (Node parent:parent(n)){
      if (parent!=null){
        result.addAll(ancestor(parent));
        result.add(parent);
      }
    }
    return result;
  }</pre>
Die Vorfahrenachse enth&auml;lt nicht den Knoten selbst. Entsprechend wie auf der
Nachkommenachse gibt es auch hier eine Version, die den Knoten selbst enth&auml;lt: <pre>  public static List&lt;Node&gt; ancestor_or_self(Node n){
    List&lt;Node&gt; result = ancestor(n);
    result.addAll(self(n));
    return result;
  }</pre>
Diese Achse beschreibt die n&auml;chsten Geschwister. Wir erhalten diese, indem wir
den Elternknoten holen, durch dessen Kinder iterieren und nachdem wir an
unseren aktuellen Knoten gelangt sind, anfangen diese Kinderknoten ins
Ergebnis aufzunehmen.<pre>  public static List&lt;Node&gt; following_sibling(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    int nodeType = n.getNodeType();
    boolean take = false;
    if (nodeType != Node.ATTRIBUTE_NODE){
      for (Node sibling:child(n.getParentNode())){
        if (take) result.add(sibling);
        if (sibling==n) take=true;
      }
    }
    return result;
  }</pre>
Entsprechend gibt es die Achse, die die vor dem aktuellen Knoten stehenden
Geschwister extrahieren. Wir gehen &auml;hnlich vor wie oben, sammeln jetzt jedoch
die Kinder nur bis zum aktuellen Knoten auf.<pre>  public static List&lt;Node&gt; preceding_sibling(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    int nodeType = n.getNodeType();
    if (nodeType != Node.ATTRIBUTE_NODE){
      for (Node sibling:child(n.getParentNode())){
        if (sibling==n) break;
        result.add(sibling);
      }
    }
    return result;
  }</pre>
Die Nachfolgerachse bezieht sich auf die Dokumentordnung in serialisierter
Form. Sie bezeichnet alle Knoten, deren Tag im gedruckten XML Dokument nach
dem Ende des aktuellen Knotens beginnen. Dieses sind die nachfolgenden
Geschwister und deren Nachkommen:<pre>  public static List&lt;Node&gt; following(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (Node follow_sib:following_sibling(n)){
      result.add(follow_sib);
      result.addAll(descendant(follow_sib));
    }
    return result;
  }</pre>
Analog hierzu funktioniert die Vorg&auml;ngerachse. Auch sie bezieht sich auf die
Dokumentordnung: <pre>  public static List&lt;Node&gt; preceding(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (Node preced_sib:preceding_sibling(n)){
      result.add(preced_sib);
      result.addAll(descendant(preced_sib));
    }
    return result;
  }</pre>
Attribute werden in einer gesonderten Achse beschrieben. Sie tauchen in keiner
der vorherigen Achsen auf. Ausgenommen sind in dieser Achse die Attribute die
eine Namensraumdefinition beschreiben:<pre>  public static List&lt;Node&gt; attribute(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    if (n.getNodeType()==Node.ELEMENT_NODE){
      NamedNodeMap nnm = n.getAttributes();
      for (int i:new FromTo(0,nnm.getLength()-1)){
        Node current = nnm.item(i);
        if (!current.getNodeName().startsWith("xmlns"))
          result.add(current);
      }
    }
    return result;
  }</pre>
Ebenso gesondert werden in der letzten Achse die Namensraumdefinitionen
behandelt. XML-technisch sind diese Attribute, deren Attributname 
mit xmlns beginnt: <pre>  public static List&lt;Node&gt; namespace(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    if (n.getNodeType()==Node.ELEMENT_NODE){
      NamedNodeMap nnm = n.getAttributes();
      for (int i:new FromTo(0,nnm.getLength()-1)){  
        Node current = nnm.item(i);
        if (current.getNodeName().startsWith("xmlns"))
          result.add(current);
      }
    }
    return result;
  }</pre>
F&uuml;r Aufz&auml;hlungstypen ab Java 1.5 l&auml;&szlig;t sich eine 
sch&ouml;ne switch-Anweisung schreiben. So k&ouml;nnen wir eine allgemeine
Methode zur Achsenberechnung schreiben, die f&uuml;r jede Achse die entsprechende
Methode aufruft.Die Version Beta1 von Java 1.5 hat einen Bug, so da&szlig;
der javac Commpiler bei der folgenden Klasse w&auml;hrend der Codegenerierung
abst&uuml;rzt. Daher ist der Code vorerst auskommentiert.<pre>  public static List&lt;Node&gt; getAxis(Node n,AxisType axis){
     switch (axis){
      case ancestor          : return ancestor(n); 
      case ancestor_or_self  : return ancestor_or_self(n); 
      case attribute         : return attribute(n);
      case child             : return child(n); 
      case descendant        : return descendant(n); 
      case descendant_or_self: return descendant_or_self(n); 
      case following         : return following(n);
      case following_sibling : return following_sibling(n); 
      case namespace         : return namespace(n);
      case parent            : return parent(n);
      case preceding         : return preceding(n); 
      case preceding_sibling : return preceding_sibling(n);
      case self              : return self(n);
      default                :throw new UnsupportedOperationException();
    }
  }
}</pre>
<h4>10.4.1.2. Knotentest</h4>
            axisType
            ::
            nodeTest
          axisTypenodeTest
            *: beschreibt Elementknoten mit beliebigen Namen.
            pref:*: beschreibt Elementknoten mit dem 
Prefix pref und beliebigen weiteren Namen.
            pref:name: beschreibt Elementknoten mit dem 
Prefix pref und den weiteren Namen name. Der Teil vor den
Namen kann dabei auch fehlen.
            comment(): beschreibt Kommentarknoten.
            text(): beschreibt Textknoten.
            processing-instruction(): beschreibt
Processing-Instruction-Knoten.
            processing-instruction(target): beschreibt
Processing-Instruction-Knoten mit einem bestimmten Ziel.
            node(): beschreibt beliebige Knoten.
          
Wir k&ouml;nnen die acht verschiedene Knotentests durch einen algebraischen Typ
ausdr&uuml;cken: <pre>package name.panitz.xml.xpath;
import java.util.List;
import name.panitz.adt.*;

@Data abstract class NodeTest{
  @Constr void StarTest(){};
  @Constr void PrefixStar(String prefix){};
  @Constr void QName(String prefix,String name){};
  @Constr void IsComment(){};
  @Constr void IsText(){};
  @Constr void IsProcessingInstruction(){};
  @Constr void IsNamedProcessingInstruction(String name){};
  @Constr void IsNode(){};

  abstract public &lt;b_&gt; b_ welcome(NodeTestVisitor&lt;b_&gt; visitor);
}</pre>
F&uuml;r diesen algebraischen Typ l&auml;&szlig;t sich ein einfacher Besucher zur textuellen
Darstellung des Typs schreiben. Er erzeugt f&uuml;r die einzelnen Knotentests die
Syntax wie sie in XPath-Ausdr&uuml;cken vorkommt. <pre>package name.panitz.xml.xpath;

public class ShowNodeTest extends NodeTestVisitor&lt;String&gt; {
  public String visit(StarTest _){return "*";}
  public String visit(PrefixStar e){return e.prefix+":*";}
  public String visit(QName e){String result="";
    if (e.prefix.length()&gt;0) result=e.prefix+":";
    result=result+e.name;
    return result;
  }
  public String visit(IsComment _){return "comment()";}
  public String visit(IsText _){return "text()";}
  public String visit(IsProcessingInstruction _){
    return "processing-instruction()";}
  public String visit(IsNamedProcessingInstruction e){
    return "processing-instruction("+e.name+")";
  }
  public String visit(IsNode _){return "node()";}
}</pre>
Ein Knotentest ergibt f&uuml;r einen konkreten Knoten 
entweder true oder false. Hierf&uuml;r k&ouml;nnen wir einen Besucher
schreiben, der f&uuml;r einen Knotentest und einen konkreten Knoten diesen
bool'schen Wert berechnet.<pre>package name.panitz.xml.xpath;

import java.util.List;
import java.util.ArrayList;
import static org.w3c.dom.Node.*;
import org.w3c.dom.*;

public class DoNodeTest extends NodeTestVisitor&lt;Boolean&gt; {
  Node current;
  public DoNodeTest(Node n){current=n;}</pre>

Der Test auf einen Stern ist wahr f&uuml;r jedes Element oder Attribut:<pre>  public Boolean visit(StarTest _){
    return    current.getNodeType()==ELEMENT_NODE
           || current.getNodeType()==ATTRIBUTE_NODE;
  }</pre>

Der Test auf ein bestimmtes Prefix ist wahr f&uuml;r jeden Knoten, der diesen
Prefix hat:<pre>  public Boolean visit(PrefixStar e){
    String currentPrefix = current.getPrefix();
    if (currentPrefix==null) currentPrefix="";
    return   new StarTest().welcome(this) 
         &amp;&amp; currentPrefix.equals(e.prefix);
  }</pre>

Jeder Test nach einen qualifizierten Namen ist wahr, wenn der Knoten diesen
Namen hat:<pre>  public Boolean visit(QName e){
    return   new PrefixStar(e.prefix).welcome(this) 
         &amp;&amp;  current.getNodeName().equals(e.name);
  }</pre>

Der Test nach Kommentaren ist f&uuml;r Kommantarknoten wahr:<pre>  public Boolean visit(IsComment _){
    return current.getNodeType()==COMMENT_NODE;}</pre>

Der Test nach Text ist f&uuml;r Textknoten wahr:<pre>  public Boolean visit(IsText _){
    return current.getNodeType()==TEXT_NODE;}</pre>

Der Test nach Processing-Instruction ist f&uuml;r PI-Knoten wahr:<pre>  public Boolean visit(IsProcessingInstruction _){
    return current.getNodeType()==PROCESSING_INSTRUCTION_NODE;}</pre>

Der Test nach Processing-Instruction mit bestimmten Namen 
ist f&uuml;r PI-Knoten mit diesen Namen wahr:<pre>  public Boolean visit(IsNamedProcessingInstruction e){
    return current.getNodeType()==PROCESSING_INSTRUCTION_NODE
        &amp;&amp; e.name.equals(current.getNodeName());
  }</pre>

Der Test nach Knoten ist immer wahr:<pre>  public Boolean visit(IsNode _){return true;}</pre>

Einen gro&szlig;en Teil eines XPath-Prozessors haben wir damit schon
implmentiert. Wir k&ouml;nnen uns die Knoten einer Achse geben lassen und wir
k&ouml;nnen diese Knoten auf einen Knotentest hin pr&uuml;fen. Zusammen l&auml;&szlig;t sich damit
bereits eine Methode zu Auswertung eines Kernausdrucks mit Achse und
Knotentest schreiben. Hierzu iterieren wir &uuml;ber die Liste der durch die Achse
spezifizierten Knoten und f&uuml;gen diese bei positiven Knotentest dem Ergebnis 
zu:<pre>  static public List&lt;Node&gt; evalAxisExpr
        (AxisType axis,NodeTest test1,Node context){
    NodeTestAdt test = (NodeTestAdt)test1;	
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (Node node:Axes.getAxis(context,axis)){
      if (test.welcome(new DoNodeTest(node)))
        result.add(node);
    }
    return result;
  }
}</pre>
<h4>10.4.1.3. Pfadangaben</h4>
Der Ausdruckchild::skript/child::*/descendant::node()/self::code/attribute::class

beschreibt die Attribute mit Attributnamen class, die an einem
Elementknoten mit Tagnamen code h&auml;ngen, die Nachkommen eines
beliebigen Elementknotens sind, die Kind eines Elementknotens mit 
Tagnamen skript sind, die Kind des aktuellen Knotens, auf dem der
Ausdruck angewendet werden soll sind.

Vorw&auml;rts gelesen ist dieser Ausdruck eine Selektionsanweisung:
Nehme alle skript-Kinder des aktuellen Knotens. Nehme von diesen
beliebige Kinder. Nehme von diesen alle code-Nachkommen. Und nehme
von diesen jeweils alle class-Attribute.<h4>10.4.1.4. Abk&uuml;rzende Pfadangaben</h4>//
            
              
                
                  //
                  expr
                
                
                  Betrachte beliebige Knoten
unterhalt des Dokumentknotens, die durch expr charakterisiert 
werden.\\[0.5em]
                
              
              
                
                  e_1//
                  e_2
                
                
                  Betrachte beliebiege Knoten  unterhalb
der durch e_1 charkterisierten Knoten.und pr&uuml;fe diese 
auf e_2.
                
              
            
          
Der Doppelschr&auml;gstrich ist eine abk&uuml;rzende Schreibweise 
f&uuml;r: /descendant-or-self::node()/<h4>10.4.1.5. Weitere abk&uuml;rzende Schreibweisen</h4>
F&uuml;r die Selbstachse kann als abk&uuml;rzende Schreibweise ein einfacher Punkt. gew&auml;hlt werden, wie er aus den Pfadangaben im Dateisystem bekannt
ist.  

Der Punkt . ist die abk&uuml;rzende Schreibweise 
f&uuml;r: self::node().
F&uuml;r die Elternachse kann als abk&uuml;rzende Schreibweise ein doppelter Punkt.. gew&auml;hlt werden, wie er aus den Pfadangaben im Dateisystem bekannt
ist.  

Der Punkt .. ist die abk&uuml;rzende Schreibweise 
f&uuml;r: parent::node().
Ein Kernausdruck, der Form child::nodeTest kann abgek&uuml;rzt
werden durch nodeTest. Die Kinderachse ist also der Standardfall.
Auch f&uuml;r die Attributachse gibt es eine abk&uuml;rzende Schreibweise:
ein Kernausdruck, der 
Form attribute::pre:name kann abgek&uuml;rzt
werden durch @pre:name. Insgesamt l&auml;&szlig;t sich der obige Ausdruck abk&uuml;rzen 
zu: skript/*//code/@class<h4>10.4.1.6. Vereinigung</h4>|Der 
Audruck /skript/kapitel | /skript/anhang/kapitel beschreibt 
die kapitel-Elemente die unter  top-level 
Knoten skript h&auml;ngen oder die unter einen 
Knoten anhang, der unter dem skript-Element h&auml;ngt.<h4>10.4.1.7. Funktionen und Operatoren</h4>countDer Ausdruck count(//code) gibt die Anzahl der in einem
Dokument enthaltenen code-Elemente zur&uuml;ck.<h4>10.4.1.8. Literale</h4>Der Ausdruck count(//kapitel)=5 wertet 
zu true aus, wenn des Dokument genau f&uuml;nf kapitel-Elemente
hat. <h4>10.4.1.9. Qualifizierung</h4>Berechne die Ergebnisliste des Ausdrucks. F&uuml;r jedes Element dieser
Liste als aktuellen Kontextknoten berechne  das Ergebnis des
Pr&auml;dikats. Interpretiere dieses Ergebnis als bool'schen Wert und verwerfe
entweder den Kontextknoten oder nimm ihn in das Ergebnis aus.
Pr&auml;dikate die direkt durch ein Funktionsergebnis oder eine Operatoranwendung
einen bool'schen Wert als Ergebnis haben, k&ouml;nnen direkt als Pr&auml;dikat
interpretiert werden.Der  XPath-Ausdruck //code[@lang="hs"] selektiert alle
Code-Knoten des Dokuments, die ein Attribut lang mit dem 
Wert hs  haben.
Wenn der XPath-Ausdruck eines Pr&auml;dikats zu einer Liste auswertet, dann wird
eine leere Liste als der bool'sche Wert false ansonsten 
als true interpretiert.Der XPath-Ausdruck //example[.//code] selektiert 
alle example-Knoten des Dokuments, die mindestens 
einen code-Nachkommen haben. Also alle Beispiele, in denen ein
Programm vorkommt.    
&Uuml;ber Funktionen kann ein XPath-Ausdruck auch eine Zahl als Ergebnis haben. In
dem Fall, da&szlig; ein XPath-Ausdruck zu einer Zahl auswertet, wird ein Knoten
selektiert, wenn er an der Stelle dieser Zahl in der Liste des qualifizierten
Ausdrucks ist.Der Ausdruck /skript/kapitel[3] selektiert jeweils das 
dritte kapitel-Element innerhalb 
eines skript-Elements.<h4>10.4.1.10. Klammerung</h4>Der Ausdruck ./skript/(./kapitel | ./anhang) bezeichnet 
alle kapitel- oder anhang-Elemente ausgehend 
vom skript-Kind des Kontextknotens. 
Hingegen ./skript/kapitel | ./anhang bezeichnet 
die kapitel-Elemente unter dem skript-Kinder des
Kontextknotens oder anhang-Kinder des Kontextknotens. <h4>10.4.1.11. Algebraischer Typ f&uuml;r XPath-Ausdr&uuml;cke</h4>
<pre>package name.panitz.xml.xpath;
import java.util.List;
import name.panitz.adt.*;

@Data abstract class XPath {
  @Constr void Axis(AxisType type,NodeTest nodeTest){};
  @Constr void RootSlash(XPath expr){};
  @Constr void RootSlashSlash(XPath expr){};
  @Constr void Slash(XPath e1,XPath e2){};
  @Constr void SlashSlash(XPath e1,XPath e2){};
  @Constr void TagName(String name){};
  @Constr void AttributeName(String name){};
  @Constr void Dot(){};
  @Constr void DotDot(){};
  @Constr void NodeSelect(){};
  @Constr void TextSelect(){};
  @Constr void PISelect(){};
  @Constr void CommentSelect(){};
  @Constr void Star(){};
  @Constr void AtStar(){};
  @Constr void Union(XPath e1,XPath e2){};
  @Constr void Function(String name,List&lt;XPath&gt; arguments){};
  @Constr void BinOperator(String name, XPath e1,XPath e2){};
  @Constr void UnaryOperator(String name, XPath expr){};
  @Constr void QualifiedExpr(XPath expr,XPath qualifier){}; 
  @Constr void NumLiteral(Integer value){};
  @Constr void StringLiteral(String value){};

  abstract public &lt;b_&gt; b_ welcome(XPathVisitor&lt;b_&gt; visitor);
}</pre>
Zun&auml;chst folgt ein Besucher, der uns ein XPath-Objekt wieder in der
XPath-Syntax darstellt:<pre>package name.panitz.xml.xpath;

public class ShowXPath extends XPathVisitor&lt;StringBuffer&gt; {
  StringBuffer result = new StringBuffer();
  public StringBuffer visit(Axis e){
    result.append(e.type);
    result.append("::");
    result.append(e.nodeTest.welcome(new ShowNodeTest()));
    return result;
  }
  public StringBuffer visit(RootSlash e){
    result.append("/"); e.expr.welcome(this);
    return result;}
  public StringBuffer visit(RootSlashSlash e){
    result.append("//"); e.expr.welcome(this);
    return result;}
  public StringBuffer visit(Slash e){
    e.e1.welcome(this);result.append("/");e.e2.welcome(this);
    return result;}
  public StringBuffer visit(SlashSlash e){
    e.e1.welcome(this);result.append("//");e.e2.welcome(this);
    return result;}
  public StringBuffer visit(TagName e){result.append(e.name);
    return result;}
  public StringBuffer visit(AttributeName e){
    result.append("@");result.append(e.name);
    return result;}
  public StringBuffer visit(Dot e){result.append(".");
    return result;}
  public StringBuffer visit(DotDot e){result.append("..");
    return result;}
  public StringBuffer visit(NodeSelect e){result.append("node()");
    return result;}
  public StringBuffer visit(TextSelect e){result.append("text()");
    return result;}
  public StringBuffer visit(CommentSelect e){result.append("comment()");
    return result;}
  public StringBuffer visit(PISelect e){
    result.append("processing-instruction()");
    return result;}
  public StringBuffer visit(Star e){result.append("*");
    return result;}
  public StringBuffer visit(AtStar e){result.append("@*");
    return result;}
  public StringBuffer visit(Union e){
    e.e1.welcome(this);result.append("|");e.e2.welcome(this);
    return result;}
  public StringBuffer visit(Function e){
    result.append(e.name);result.append("(");
    boolean first = true;
    for (XPath arg:e.arguments){
      if (!first) result.append(",");else first=false;
      arg.welcome(this);
    }
    result.append(")");
    return result;}
  public StringBuffer visit(UnaryOperator e){
    result.append(e.name+"\u0020");e.expr.welcome(this);
    return result;}
  public StringBuffer visit(BinOperator e){
    e.e1.welcome(this);result.append("\u0020"+e.name+"\u0020");
    e.e2.welcome(this);return result;}
  public StringBuffer visit(QualifiedExpr e){
    e.expr.welcome(this);result.append("[");
    e.qualifier.welcome(this);result.append("]");
    return result;}
  public StringBuffer visit(NumLiteral e){result.append(""+e.value);
    return result;}
  public StringBuffer visit(StringLiteral e){
   result.append("\"");result.append(e.value) ;result.append("\"");
   return result;}
}</pre>
<h4>10.4.1.12. Entfernen von abk&uuml;rzenden Schreibweisen</h4>
<pre>package name.panitz.xml.xpath;

import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.*;
import name.panitz.domtest.*;

public class RemoveAbbreviation extends XPathVisitor&lt;XPath&gt; {</pre>
Die komplexeste abk&uuml;rzende Schreibweise ist der Doppelschr&auml;gstrich. Er wird
ersetzt durch den Ausdruck: /descendant-or-self::node()/. F&uuml;r den
einstelligen //-Operator ergibt das den Javaausdruck:new RootSlash(new Slash(new Axis(AxisType.descendant_or_self,new IsNode()),expr))

Wir erhalten folgende Implementierung:<pre>public XPath visit(RootSlashSlash e){
  /* //expr -&gt; /descendant-or-self::node()/expr  */
  return 
    new RootSlash(
     new Slash(new Axis(AxisType.descendant_or_self,new IsNode())
              ,e.expr.welcome(this)));}</pre>
In gleicher Weise ist der doppelte Schr&auml;gstrich als zweistelliger Operator
durch den Kernausdruck /descendant-or-self::node()/ zu ersetzen.<pre>public XPath visit(SlashSlash e){
  final XPath e1 = e.e1;
  final XPath e2 = e.e2;
  /* e1//e2 -&gt; e1/descendant-or-self::node()/e2 */
  return 
   new Slash
     (e1.welcome(this)
     ,new Slash(new Axis(AxisType.descendant_or_self,new IsNode())
               ,e2.welcome(this)));}</pre>
Der einfache Punkt wird durch einen Kernausdruck auf der Selbstachse ersetzt.<pre>public XPath visit(Dot e){
  return new Axis(AxisType.self,new IsNode());}</pre>
Der doppelte Punkt wird durch einen Kernausdruck auf der Elternachse ersetzt.<pre>public XPath visit(DotDot e){
  return new Axis(AxisType.parent,new IsNode());}</pre>
F&uuml;r einen einfachen Tagnamen wird die implizit vorhandene  Kinderachse eingef&uuml;gt.<pre>public XPath visit(TagName e){
  return new Axis(AxisType.child,new QName("",e.name));}</pre>
F&uuml;r einen einfachen Attributnamen wird die implizit vorhandene  
Attributachse eingef&uuml;gt.<pre>public XPath visit(AttributeName e){
  return new Axis(AxisType.attribute,new QName("",e.name));}</pre>
F&uuml;r einen einfache Knotentest wird die implizit vorhandene  
Kinderachse eingef&uuml;gt.<pre>public XPath visit(NodeSelect e){
  return new Axis(AxisType.child,new IsNode());}</pre>
F&uuml;r einen einfache Texttest wird die implizit vorhandene  
Kinderachse eingef&uuml;gt.<pre>public XPath visit(TextSelect e){
  return new Axis(AxisType.child,new IsText());}</pre>
F&uuml;r einen einfache Processing-Instruction-Test wird die implizit vorhandene  
Kinderachse eingef&uuml;gt.<pre>public XPath visit(PISelect e){
  return new Axis(AxisType.child,new IsProcessingInstruction());}</pre>
F&uuml;r einen einfache Kommentartest wird die implizit vorhandene  
Kinderachse eingef&uuml;gt.<pre>public XPath visit(CommentSelect e){
  return new Axis(AxisType.child,new IsComment());}</pre>
F&uuml;r einen einfache Sterntest wird die implizit vorhandene  
Kinderachse eingef&uuml;gt.<pre>public XPath visit(Star e){
  return new Axis(AxisType.child,new StarTest());}</pre>
F&uuml;r einen einfache Sterntest auf Attributen  wird die implizit vorhandene  
Attributachse eingef&uuml;gt.<pre>public XPath visit(AtStar e){
  return new Axis(AxisType.attribute,new StarTest());}</pre>
F&uuml;r die Ausdr&uuml;cke, die keine abk&uuml;rzende Schreibweise darstellen, wird der
Besucher in die Unterausdr&uuml;cke geschickt, um in diesen abk&uuml;rzende
Schreibweisen zu ersetzen.<pre>public XPath visit(Slash e){
  return new Slash(e.e1.welcome(this),e.e2.welcome(this));}
public XPath visit(Axis e){return e;}
public XPath visit(RootSlash e){
  return new RootSlash(e.expr.welcome(this));}
public XPath visit(Union e){
  return new Union(e.e1.welcome(this),e.e2.welcome(this));}
public XPath visit(Function e){
  final List&lt;XPath&gt; args = e.arguments;
  List&lt;XPath&gt; newArgs = new ArrayList&lt;XPath&gt;();
  for (XPath arg:args) newArgs.add(arg.welcome(this));
  return new Function(e.name,newArgs);}
public XPath visit(BinOperator e){
  return new BinOperator(e.name
                        ,e.e1.welcome(this)
                        ,e.e2.welcome(this));}
public XPath visit(UnaryOperator e){
  return new UnaryOperator(e.name,e.expr.welcome(this));}
public XPath visit(QualifiedExpr e){
  return new QualifiedExpr(e.expr.welcome(this)
                          ,e.qualifier.welcome(this));}
public XPath visit(NumLiteral e){return e;}
public XPath visit(StringLiteral e){return e;}
}</pre>
<h4>10.4.1.13. Auswerten von XPath Ausdr&uuml;cken</h4>
 Die
Auswertung eines XPath-Ausdrucks kann eine Liste von Knoten, eine Zahl, ein
String oder ein bool'sches Ergebnis haben. Hierf&uuml;r sehen wir einen
algebraischen Typ vor.<pre>package name.panitz.xml.xpath;
import org.w3c.dom.Node;
import java.util.List;
import name.panitz.adt.*;

@Data abstract class XPathResult {
  @Constr void BooleanResult(Boolean value){};
  @Constr void NumResult(Integer value){};
  @Constr void StringResult(String value){};
  @Constr void Nodes(List&lt;Node&gt; value){};

  abstract public &lt;b_&gt; b_ welcome(XPathResultVisitor&lt;b_&gt; visitor);
}</pre>
Der eigentliche Prozessor wird als Besucher &uuml;ber einen XPath-Ausdruck
geschrieben.  Dieser Besucher braucht drei Informationen:
              den Kontextknoten, auf den der Ausdruck angewendet werden soll.
              die Gr&ouml;&szlig;e der Liste, in der der Knotextknoten ist.
              die Position des Kontextknotens in der Liste, in der er sich 
befindet.
            <pre>package name.panitz.xml.xpath;

import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.*;
import static org.w3c.dom.Node.*;
import name.panitz.domtest.*;

import static name.panitz.xml.xpath.Axes.*;

public class EvalXPath extends XPathVisitor&lt;XPathResult&gt; {
  Node current;
  int contextPosition=1;
  int contextSize=1;

  public EvalXPath(Node n){current=n;}
  public EvalXPath(Node n,int pos,int size){
    this(n);contextPosition=pos;contextSize=size;}</pre>

Einen Kernausdruck mit einer Achse k&ouml;nnen wir bereits auswerten. Die
entsprechende Methode haben wir bereits in der 
Klasse DoNodeTest implementiert.<pre>  public XPathResult visit(Axis e){
    return new Nodes(
      DoNodeTest.evalAxisExpr(e.type,e.nodeTest,current));
  }</pre>

F&uuml;r den einstelligen Schr&auml;gstrich ist der Dokumentknoten des Knotextsknotens
zu beschaffen, um f&uuml;r diesen als neuen Kontextknoten den XPath-Ausdruck rechts
von  dem Schr&auml;gstrich anzuwenden.<pre>  public XPathResult visit(RootSlash e){
    Node doc ;
    if (current.getNodeType()==DOCUMENT_NODE) doc=current;
    else{
      doc = current.getOwnerDocument();
    }
    if (doc!=null) return e.expr.welcome(new EvalXPath(doc));

    return new Nodes(new ArrayList&lt;Node&gt;());
  }</pre>

F&uuml;r den zweistelligen Schr&auml;gstrich ist zun&auml;chst der linke Kinderausdruck zu
besuchen. Falls dieses eine Knotenliste darstellt, ist f&uuml;r jedes Element
dieser Liste als Kontextknoten der zweite Operand zu besuchen. <pre>  public XPathResult visit(Slash e){
    XPathResult res1 = e.e1.welcome(this);

    if (res1 instanceof Nodes){
      final List&lt;Node&gt; resultNodes = new ArrayList&lt;Node&gt;();
      final List&lt;Node&gt; e1s = ((Nodes)res1).value;
      final int size = e1s.size();
      int pos = 1;
      for (Node e1:e1s){
        XPathResult e2s = e.e2.welcome(new EvalXPath(e1,pos,size));
        if (e2s instanceof Nodes)
           resultNodes.addAll(((Nodes)e2s).value);
        else return e2s;
        pos=pos+1;
      }
      return new Nodes(resultNodes);
    }
    return res1;
  }</pre>

F&uuml;r die Vereinigung zweier XPath-Ausdr&uuml;cke, sind diese beide Auszuwerten und
in Falle einer Knotenliste als Ergebnis beide Liste zu vereinigen.<pre>  public XPathResult visit(Union e){
    XPathResult r1 = e.e1.welcome(this);
    XPathResult r2 = e.e1.welcome(this);
    if (r1 instanceof Nodes &amp;&amp; r2 instanceof Nodes){
      List&lt;Node&gt; resultNodes = ((Nodes)r1).value;
      resultNodes.addAll(((Nodes)r2).value);
      return new Nodes(resultNodes);
    }
    return r1;
  }</pre>

Ein numerisches Literal ist gerade nur der Wert dieses Literals das Ergebnis.<pre>  public XPathResult  visit(NumLiteral e){
    return new NumResult(e.value);}</pre>

Ein Stringliteral ist gerade nur der Wert dieses Literals das Ergebnis.<pre>  public XPathResult visit(StringLiteral e){
    return new StringResult(e.value);}</pre>

F&uuml;r einen qualifizierten Ausdruck ist erst der XPath-Ausdruck auszuwerten, und
dann f&uuml;r jedes Element der Knotenliste das Pr&auml;dikat. Es ist zu testen, ob
dieses Pr&auml;dikat als wahr oder falsch zu interpretieren ist. Hierzu wird ein
Besucher auf XPathResult geschrieben.<pre>  public XPathResult visit(QualifiedExpr e){
    XPathResult result1 = e.expr.welcome(this);
    if (result1 instanceof Nodes){
      final List&lt;Node&gt; resultNodes = new ArrayList&lt;Node&gt;();
      final List&lt;Node&gt; rs = ((Nodes)result1).value;
      final int size = rs.size();
      int pos = 1;
      for (Node r : rs){
        XPathResult qs 
           = e.qualifier.welcome(new EvalXPath(r,pos,size));
        if (qs.welcome(new TestQualifier(r,pos,size)))
          resultNodes.add(r);
        pos=pos+1;
      }
      return new Nodes(resultNodes);
    }
    return result1;
  }</pre>


Die folgenden F&auml;lle brauchen wir in der Auswertung nicht betrachten, weil wir
sie der Elemination von abk&uuml;rzenden Schreibweisen aus dem XPath-Baum 
entfernt haben<pre>  public XPathResult visit(RootSlashSlash e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(SlashSlash e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(TagName e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(AttributeName e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(Dot e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(DotDot e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(NodeSelect e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(TextSelect e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(PISelect e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(CommentSelect e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(Star e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(AtStar e){
   throw new UnsupportedOperationException();}</pre>

Operatoren und Funktionen sind in unserem Prozessor noch nicht implementiert.<pre>  public XPathResult visit(Function e){
   throw new UnsupportedOperationException();
  }
  public XPathResult visit(BinOperator e){
   throw new UnsupportedOperationException();
  }
  public XPathResult visit(UnaryOperator e){
   throw new UnsupportedOperationException();
  }</pre>


Es folgen ein paar erste Beispielaufrufe:<pre>  public static XPathResult eval(XPathAdt xpath,Node n){
    System.out.println(xpath.welcome(new NormalizeXPath())
                            .welcome(new ShowXPath()));

    System.out.println(xpath.welcome(new NormalizeXPath())
                            .welcome(new RemoveAbbreviation())
                            .welcome(new ShowXPath()));

    return xpath.welcome(new NormalizeXPath())
                .welcome(new RemoveAbbreviation())
                .welcome(new EvalXPath(n));
  }

  public static void main(String [] args){
    Node doc = ParseXML.parseXml(args[0]);

    XPathResult result 
     =  eval(new QualifiedExpr
           (new RootSlashSlash
               (new Slash(new TagName("code"),new AttributeName("class")))
           ,new StringLiteral("XPath"))
            ,doc);
    System.out.println(result);

    result 
     =  eval
         (new QualifiedExpr(new RootSlash
            (new Slash(new TagName("skript")
            ,new Slash(new TagName("kapitel")
            ,new Slash(new TagName("section"),new DotDot()))))
          ,new NumLiteral(1))
         ,doc);

    System.out.println(result);

    result 
     =  eval
         (new RootSlash
            (new Slash(new TagName("skript")
            ,new Slash(new TagName("kapitel")
            ,new QualifiedExpr(new TagName("section"),new NumLiteral(2)))))
         ,doc);

    System.out.println(result);
  }
}</pre>
Es bleibt das Ergebnis eines Pr&auml;dikats als bool'schen Wert zu
  interpretieren. Hierzu schreiben wir einen Besucher 
auf XPathResult. <pre>package name.panitz.xml.xpath;

import org.w3c.dom.Node;

public class TestQualifier extends XPathResultVisitor&lt;Boolean&gt; {
  final int pos;
  final int size;
  final Node context;

  public TestQualifier(Node c,int p,int s){context=c;pos=p;size=s;}

  public Boolean visit(BooleanResult e){return e.value;}
  public Boolean visit(NumResult e){return e.value==pos;}
  public Boolean visit(StringResult e) {
   return e.value.equals(context.getNodeValue());}
  public Boolean visit(Nodes e) {return !e.value.isEmpty();}
}</pre>
<pre>package name.panitz.xml.xpath;

import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.*;
import name.panitz.domtest.*;

public class NormalizeXPath extends XPathVisitor&lt;XPath&gt; {

public XPath visit(Axis e){return e;}

public XPath visit(RootSlash e){
//  final XPath n1 = e.expr;
  return new RootSlash(e.expr.welcome(this));}


public XPath visit(RootSlashSlash e){
  return new RootSlashSlash(e.expr.welcome(this));}

/**  mache Slash(Slash(e1,e2),e3)
   zu Slash(e1,Slash(e2,e3))
und
  mache Slash(SlashSlash(e1,e2),e3)
   zu SlashSlash(e1,Slash(e2,e3))
*/

public XPath visit(Slash e){
  final XPath n1 = e.e1;
  final XPath e3 = e.e2;
  if (n1 instanceof Slash){
    final XPath e1 = ((Slash)n1).e1;
    final XPath e2 = ((Slash)n1).e2;
    return new Slash(e1,new Slash(e2,e3)).welcome(this);    
  }
  if (n1 instanceof SlashSlash){
    final XPath e1 = ((SlashSlash)n1).e1;
    final XPath e2 = ((SlashSlash)n1).e2;
    return new SlashSlash(e1,new Slash(e2,e3)).welcome(this);    
  }
  return new Slash(n1.welcome(this),e3.welcome(this));
}

public XPath visit(SlashSlash e){
  final XPath n1 = e.e1;
  final XPath e3 = e.e2;
  if (n1 instanceof Slash){
    final XPath e1 = ((Slash)n1).e1;
    final XPath e2 = ((Slash)n1).e2;
    return new Slash(e1,new SlashSlash(e2,e3)).welcome(this);    
  }
  if (n1 instanceof SlashSlash){
    final XPath e1 = ((SlashSlash)n1).e1;
    final XPath e2 = ((SlashSlash)n1).e2;
    return new SlashSlash(e1,new SlashSlash(e2,e3)).welcome(this);    
  }
  return new Slash(n1.welcome(this),e3.welcome(this));
}

public XPath visit(Union e){
  return new Union(e.e1.welcome(this),e.e2.welcome(this));}
public XPath visit(TagName e){return e;}
public XPath visit(AttributeName e){return e;}
public XPath visit(Dot e){return e;}
public XPath visit(DotDot e){return e;}
public XPath visit(NodeSelect e){return e;}
public XPath visit(TextSelect e){return e;}
public XPath visit(PISelect e){return e;}
public XPath visit(CommentSelect e){return e;}
public XPath visit(Star e){return e;}
public XPath visit(AtStar e){return e;}

public XPath visit(Function e){return e;}
public XPath visit(BinOperator e){return e;}
public XPath visit(UnaryOperator e){return e;}
public XPath visit(QualifiedExpr e){
  return new QualifiedExpr(e.expr.welcome(this)
                          ,e.qualifier.welcome(this));}
public XPath visit(NumLiteral e){return e;}
public XPath visit(StringLiteral e){return e;}
}</pre>
<h3>10.4.2. XSLT: Transformationen in Dokumenten</h3>StylesheetWir werden die wichtigsten XSLT-Konstrukte mit folgendem
kleinem XML Dokument ausprobieren:<pre>&lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
&lt;?xml-stylesheet type="text/xsl" href="cdTable.xsl"?&gt;
&lt;cds&gt;
 &lt;cd&gt;
  &lt;artist&gt;The Beatles&lt;/artist&gt;
  &lt;title&gt;White Album&lt;/title&gt;
  &lt;label&gt;Apple&lt;/label&gt;
 &lt;/cd&gt;
 &lt;cd&gt;
  &lt;artist&gt;The Beatles&lt;/artist&gt;
  &lt;title&gt;Rubber Soul&lt;/title&gt;
  &lt;label&gt;Parlophone&lt;/label&gt;
 &lt;/cd&gt;
 &lt;cd&gt;
  &lt;artist&gt;Duran Duran&lt;/artist&gt;
  &lt;title&gt;Rio&lt;/title&gt;
  &lt;label&gt;Tritec&lt;/label&gt;
 &lt;/cd&gt;
 &lt;cd&gt;
  &lt;artist&gt;Depeche Mode&lt;/artist&gt;
  &lt;title&gt;Construction Time Again&lt;/title&gt;
  &lt;label&gt;Mute&lt;/label&gt;
 &lt;/cd&gt;
 &lt;cd&gt;
  &lt;artist&gt;Yazoo&lt;/artist&gt;
  &lt;title&gt;Upstairs at Eric's&lt;/title&gt;
  &lt;label&gt;Mute&lt;/label&gt;
 &lt;/cd&gt;
 &lt;cd&gt;
  &lt;artist&gt;Marc Almond&lt;/artist&gt;
  &lt;title&gt;Absinthe&lt;/title&gt;
  &lt;label&gt;Some Bizarre&lt;/label&gt;
 &lt;/cd&gt;
 &lt;cd&gt;
  &lt;artist&gt;ABC&lt;/artist&gt;
  &lt;title&gt;Beauty Stab&lt;/title&gt;
  &lt;label&gt;Mercury&lt;/label&gt;
 &lt;/cd&gt;
&lt;/cds&gt;
</pre>
<h4>10.4.2.1. Gesamtstruktur</h4>stylesheet<pre>&lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
&lt;xsl:stylesheet 
  version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;/xsl:stylesheet&gt;
</pre>
Wir k&ouml;nnen mit einer Processing-Instruction am Anfang eines
XML-Dokumentes definieren, mit welchem XSLT Stylesheet es zu
bearbeiten ist. Hierzu wird als Referenz im 
Attribut href die XSLT-Datei angegeben.<pre>&lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
&lt;?xml-stylesheet type="text/xsl" href="cdTable.xsl"?&gt;
&lt;cds&gt;
 &lt;cd&gt;........</pre>
<h4>10.4.2.2. Templates (Formulare)</h4>xsl:template&lt;xsl:template match="Elementname"&gt; zu erzeugender Code&lt;/xsl:template &gt;
Folgendes XSLT-Skript transformiert die XML-Datei mit den CDs in eine
HTML-Tabelle, in der die CDs tabellarisch aufgelistet sind. <pre>&lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
&lt;xsl:stylesheet 
  version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;!-- Startregel f&uuml;r das ganze Dokument. --&gt;
&lt;xsl:template match="/"&gt;
  &lt;html&gt;&lt;head&gt;&lt;title&gt;CD Tabelle&lt;/title&gt;&lt;/head&gt;
    &lt;body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/body&gt;
  &lt;/html&gt;   
&lt;/xsl:template&gt;


&lt;!-- Regel f&uuml;r die CD-Liste. --&gt;
&lt;xsl:template match="cds"&gt;
  &lt;table border="1"&gt;
    &lt;tr&gt;&lt;td&gt;&lt;b&gt;Interpret&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;Titel&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="cd"&gt;
  &lt;tr&gt;&lt;xsl:apply-templates/&gt;&lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="artist"&gt;
  &lt;td&gt;&lt;xsl:apply-templates/&gt;&lt;/td&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="title"&gt;
  &lt;td&gt;&lt;xsl:apply-templates/&gt;&lt;/td&gt;
&lt;/xsl:template&gt;

&lt;!-- Regel f&uuml;r alle &uuml;brigen Elemente. 
     Mit diesen soll nichts gemacht werden --&gt;
&lt;xsl:template match="*"&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
&Ouml;ffnen wir nun die XML Datei, die unsere CD-Liste enth&auml;lt im
Webbrowser, so wendet er die Regeln des referenzierten XSLT-Skriptes
an und zeigt die so generierte Webseite wie in 
Abbildung  zu sehen an.

L&auml;&szlig;t man sich vom Browser hingegen den Quelltest der Seite anzeigen,
so wird kein HTML-Code angezeigt sondern der XML-Code.<h4>10.4.2.3. Auswahl von Teildokumenten</h4>xsl:apply-templatesselect
Im folgenden XSL Element selektieren wir f&uuml;r cd-Elemente nur
die title und artist Kinder und ignorieren 
die label Kinder.<pre>
&lt;!-- f&uuml;r das Element "cd" --&gt;
&lt;xsl:template match="cd"&gt;
 &lt;!--erzeuge ein Element "tr" --&gt;
 &lt;tr&gt;
   &lt;!-- wende das stylesheet weiter an auf die Kinderelemente
   "title" --&gt;
   &lt;xsl:apply-templates select="title"/&gt;
   &lt;!-- wende das stylesheet weiter an auf die Kinderelemente
   "artist" --&gt;
   &lt;xsl:apply-templates select="artist"/&gt;
 &lt;/tr&gt;
&lt;/xsl:template&gt;</pre>
<h4>10.4.2.4. Sortieren von Dokumentteilen</h4>xsl:sortselectZum Sortieren der CD-Liste kann mit xsl:sort das
Unterelement artist als Sortierschl&uuml;ssel bestimmt werden.<pre>&lt;xsl:template match="cds"&gt;
  &lt;table border="1"&gt;
    &lt;tr&gt;&lt;td&gt;&lt;b&gt;Interpret&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;Titel&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
    &lt;xsl:apply-templates select="cd"&gt;
      &lt;xsl:sort select="artist"/&gt; 
    &lt;/xsl:apply-templates&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</pre>
<h4>10.4.2.5. Weitere Konstrukte</h4>if<h4>10.4.2.6. XSLT in Java</h4>
<pre>package name.panitz.xml.xslt;

import org.w3c.dom.Node;

import javax.xml.transform.TransformerFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.TransformerException; 

import java.io.StringWriter; 
import java.io.File ;

public class XSLT {
  static public String transform(File xslt,File doc){
    return transform(new StreamSource(doc),new StreamSource(doc));
  }

  static public String transform(Source xslt,Source doc){
    try{
      StringWriter writer = new StringWriter();
      Transformer t =
         TransformerFactory
          .newInstance()
          .newTransformer(xslt);
      t.transform(doc,new StreamResult(writer));
      return writer.getBuffer().toString();
    }catch (TransformerException _){
      return "";
    }
  }

  public static void main(String [] args)throws Exception {
    System.out.println(transform(new File(args[0]),new File(args[1])));
  }

}</pre>
<h3>10.4.3. XQuery: Anfragen</h3>
<pre>declare function fac($n) {if ($n=0) then 1 else $n*fac($n - 1)};
fac(5)</pre>
<pre>declare function fac($n) {if ($n=0) then 1 else $n*fac($n - 1)};

&lt;html&gt;&lt;body&gt;fac(5)={fac(5)}&lt;/body&gt;&lt;/html&gt;</pre>
<pre>count(doc("/home/sep/fh/prog4/skript.xml")//kapitel)</pre>
<pre>let $name := distinct-values
                (doc("/home/sep/fh/prog4/skript.xml")//code/@class)
return count($name)</pre>
<pre>&lt;ul&gt;{
for $name in distinct-values(doc("/home/sep/fh/prog4/skript.xml")//code/@class)
return &lt;li&gt;
         {string($name)}
       &lt;/li&gt;
}&lt;/ul&gt;</pre>
<pre>&lt;ul&gt;{
for $name in distinct-values(doc("/home/sep/fh/prog4/skript.xml")//code/@class)
order by $name
return &lt;li&gt;
         {string($name)}
       &lt;/li&gt;
}&lt;/ul&gt;</pre>
<pre>&lt;html&gt;
&lt;title&gt;Klassen aus dem Skript&lt;/title&gt;
&lt;body&gt;
&lt;ul&gt;{
let $codeFrags := doc("/home/sep/fh/prog4/skript.xml")//code[@class]
let 
 $codes := 
   for $name in distinct-values($codeFrags/@class)
   let $codeFrag := $codeFrags[@class=$name][1]
   return 
     &lt;code&gt;
        &lt;className&gt;{string($codeFrag/@class)}&lt;/classname&gt;
        &lt;lang&gt;{if ($codeFrag/@lang) 
               then string($codeFrag/@lang) 
               else "java"}&lt;/lang&gt;
        &lt;package&gt;{if ($codeFrag/@package) 
                  then string($codeFrag/@package) 
                  else "."}&lt;/package&gt;
     &lt;/code&gt;
for $code in $codes
order by $code/className
return 
  let $name:= ($code/className/text(),".",$code/lang/text())
  let $fullname:= ($code/package/text(),"/",$name)
  return
    &lt;li&gt;&lt;a&gt;{attribute href {$fullname}}{$name}&lt;/a&gt;&lt;/li&gt;
}&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</pre>
<h2>10.5. Dokumenttypen</h2>
<h3>10.5.1. DTD</h3>(document type description)
          &lt;!DOCTYPE root-element [ doctype-declaration... ]&gt;
  Legt den Namen des top-level Elements fest und enth&auml;lt die gesammte
  Definition des erlaubten Inhalts.
          &lt;!ELEMENT element-namecontent-model&gt;
  assoziiert einen content model mit allen Elementen, die
  diesen Namen haben.
  content models k&ouml;nnen wie folgt gebildet werden.: 
  
              EMPTY: Das Element hat keinen Inhalt.
              ANY: Das Element hat einen beliebigen Inhalt
              #PCDATA: Zeichenkette, also der eigentliche Text.
  durch einen regul&auml;ren Ausdruck, der aus den folgenden
  Komponenten gebildet werden kann.
                   Auswahl von Alternativen (oder): (...|...|...)
                   Sequenz von Ausdr&uuml;cken: (...,...,...)
                   Option: ...?
                   Ein bis mehrfach Wiederholung: ...*
                   Null bis mehrfache Wiederholung: ...+
                
            
          &lt;!ATTLISTelement-nameattr-nameattr-typeattr-default ...&gt;
Liste, die definiert, was f&uuml;r Attribute ein Element hat:
  
  Attribute werden definiert durch:
  
              CDATA: beliebiger Text ist erlaubt
              (value|...): Aufz&auml;hlung erlaubter Werte
            
  Attribut default sind:
  
              #REQUIRED: Das Attribut mu&szlig; immer vorhanden sein.
              #IMPLIED: Das Attribut ist optional
              "value": Standardwert, wenn das Attribut fehlt.
              #FIXED "value": Attribut kennt nur diesen Wert.
            
        Ein Beispiel f&uuml;r eine DTD, die ein Format f&uuml;r eine
Rezeptsammlung definiert.<pre>&lt;!DOCTYPE collection SYSTEM "collection.dtd" [
&lt;!ELEMENT collection (description,recipe*)&gt;

&lt;!ELEMENT description ANY&gt;

&lt;!ELEMENT recipe (title,ingredient*,preparation
                 ,comment?,nutrition)&gt;

&lt;!ELEMENT title (#PCDATA)&gt;

&lt;!ELEMENT ingredient (ingredient*,preparation)?&gt;
&lt;!ATTLIST ingredient name CDATA #REQUIRED
                     amount CDATA #IMPLIED
                     unit CDATA #IMPLIED&gt;

&lt;!ELEMENT preparation (step)*&gt;

&lt;!ELEMENT step (#PCDATA)&gt;

&lt;!ELEMENT comment (#PCDATA)&gt;

&lt;!ELEMENT nutrition EMPTY&gt;
&lt;!ATTLIST nutrition fat CDATA #REQUIRED
                    calories CDATA #REQUIRED
                    alcohol CDATA #IMPLIED&gt;]&gt;</pre>Schreiben Sie ein XML Dokument, da&szlig; nach den Regeln der
obigen DTD gebildet wird.<h3>10.5.2. Schema</h3>
<h3>10.5.3. Gel&auml;ufige Dokumenttypen</h3>
<h4>10.5.3.1. XHTML</h4>
<h4>10.5.3.2. SVG</h4>(scalable vector graphics)Folgendes kleine SVG-Dokument definiert eine Graphik, die
einen Kreis, ein Viereck und einen Text enth&auml;lt. <pre>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;svg xmlns="http://www.w3.org/2000/svg" width="300" height="200"&gt;
 &lt;ellipse cx="100" cy="100" rx="48" ry="90" fill="limegreen" /&gt;
 &lt;text x="20" y="115"&gt;SVG Textobjekt&lt;/text&gt;
 &lt;rect x="50" y="50" width="50" height="60" fill="red"/&gt;
&lt;/svg&gt;</pre>
<h2>10.6. Aufgaben</h2>
Die folgenden Dokumente sind kein wohlgeformetes XML. Begr&uuml;nden Sie, wo
der Fehler liegt, und wie dieser Fehler behoben werden kann.
          
            <pre>&lt;a&gt;to be &lt;/a&gt;&lt;b&gt; or not to be&lt;/b&gt;</pre>
          
          Kein top-level Element, das das ganze Dokument umschlie&szlig;t.
          
            <pre>&lt;person geburtsjahr=1767&gt;Ferdinand Carulli&lt;/person&gt;</pre>
            Attributwerte m&uuml;ssen in Anf&uuml;hrungszeichen stehen.
          
          
            <pre>&lt;line&gt;lebt wohl&lt;br/&gt;
&lt;b&gt;Gott wei&szlig;, wann wir uns wiedersehen&lt;/line&gt;</pre>
            &lt;b&gt; wird nicht geschlossen.
          
          
            <pre>&lt;kockrezept&gt;&lt;!--habe ich aus dem Netz
  &lt;name&gt;Saltimbocca&lt;/name&gt;
  &lt;zubereitung&gt;Zutaten aufeinanderlegen 
               und braten.&lt;/zubereitung&gt;
&lt;/kockrezept&gt;</pre>
            Kommentar wird nicht geschlossen.
          
          
            <pre>&lt;cd&gt;
  &lt;artist&gt;dead&amp;alive&lt;/artist&gt;
  &lt;title&gt;you spin me round&lt;/title&gt;&lt;/cd&gt;</pre>
            Das Zeichen \ mu&szlig; als character 
entity &amp;amp; geschrieben werden.
          
        
Gegeben sind das folgende XML-Dokument:<pre>&lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
&lt;autoren&gt;
&lt;autor&gt;
  &lt;person&gt;
    &lt;nachname&gt;Shakespeare&lt;/nachname&gt;
    &lt;vorname&gt;William&lt;/vorname&gt;
  &lt;/person&gt;
  &lt;werke&gt;
    &lt;opus&gt;Hamlet&lt;/opus&gt;
    &lt;opus&gt;Macbeth&lt;/opus&gt;
    &lt;opus&gt;King Lear&lt;/opus&gt;
  &lt;/werke&gt;
&lt;/autor&gt;
&lt;autor&gt;
  &lt;person&gt;
    &lt;nachname&gt;Kane&lt;/nachname&gt;
    &lt;vorname&gt;Sarah&lt;/vorname&gt;
  &lt;/person&gt;
  &lt;werke&gt;
    &lt;opus&gt;Ges&auml;ubert&lt;/opus&gt;
    &lt;opus&gt;Psychose 4.48&lt;/opus&gt;
    &lt;opus&gt;Gier&lt;/opus&gt;
  &lt;/werke&gt;
&lt;/autor&gt;
&lt;/autoren&gt;</pre>
          Schreiben Sie eine DTD, das die Struktur dieses 
Dokuments beschreibt.
              <pre>&lt;!DOCTYPE autoren SYSTEM "AutorenType.dtd" [
&lt;!ELEMENT autoren (autor+)&gt;
&lt;!ELEMENT autor (person,werke)&gt;
&lt;!ELEMENT werke (opus*)&gt;
&lt;!ELEMENT opus (#PCDATA)&gt;
&lt;!ELEMENT person (nachname,vorname)&gt;
&lt;!ELEMENT nachname (#PCDATA)&gt;
&lt;!ELEMENT vorname (#PCDATA)&gt;]&gt;</pre>
            
          Entwerfen Sie Java Schnittstellen, die Objekte ihrer DTD beschreiben.
              <pre>package name.panitz.xml.exercise;
import java.util.List;
public interface Autoren {
  List&lt;Autor&gt; getAutorList();
}</pre>
              
<pre>package name.panitz.xml.exercise;
public interface Autor {
  Person getPerson();
  Werke  getWerke();
}</pre>
              
<pre>package name.panitz.xml.exercise;
public interface Person {
  Nachname getNachname();
  Vorname  getVorname();
}</pre>
              
<pre>package name.panitz.xml.exercise;
import java.util.List;
public interface Werke {
  List&lt;Opus&gt; getOpusList();
}</pre>
              
<pre>package name.panitz.xml.exercise;
public interface HasJustTextChild {
  String getText();
}</pre>
              
<pre>package name.panitz.xml.exercise;
public interface Opus extends HasJustTextChild {}</pre>
              
<pre>package name.panitz.xml.exercise;
public interface Nachname extends HasJustTextChild {}</pre>
              
<pre>package name.panitz.xml.exercise;
public interface Vorname extends HasJustTextChild {}</pre>
            
          Schreiben Sie ein XSLT-Skript, das obige Dokument in eine Html Liste 
der Werke ohne Autorangabe  transformiert.
              <pre>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:template match="/"&gt;
     &lt;html&gt;&lt;head&gt;&lt;title&gt;Werke&lt;/title&gt;&lt;/head&gt;
       &lt;body&gt;&lt;xsl:apply-templates /&gt;&lt;/body&gt;
     &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="autoren"&gt;
     &lt;ul&gt;&lt;xsl:apply-templates select="autor/werke/opus"/&gt;&lt;/ul&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="opus"&gt;
     &lt;li&gt;&lt;xsl:apply-templates/&gt;&lt;/li&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
            
          Schreiben Sie eine JavamethodeList&lt;String&gt; getWerkListe(Autoren autoren);, die auf den Objekten Ihrer Schnittstelle
  f&uuml;r Autoren eine Liste von Werknamen erzeugt.
              <pre>package name.panitz.xml.exercise;
import java.util.List;
import java.util.ArrayList;

public class GetWerke{
  public List&lt;String&gt; getWerkListe(Autoren autoren){
    List&lt;String&gt; result = new ArrayList&lt;String&gt;();
    for (Autor a:autoren.getAutorList()){
      for (Opus opus: a.getWerke().getOpusList())
        result.add(opus.getText());
    }
    return result;
  }
}</pre>
            
        Gegeben sei folgendes XML-Dokument:<pre>&lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
&lt;x1&gt;&lt;x2&gt;&lt;x5&gt;5&lt;/x5&gt;&lt;x6&gt;6&lt;/x6&gt;&lt;/x2&gt;&lt;x3&gt;&lt;x7&gt;7&lt;/x7&gt;&lt;/x3&gt;
&lt;x4&gt;&lt;x8/&gt;&lt;x9&gt;&lt;x10&gt;&lt;x11&gt;&lt;/x11&gt;&lt;/x10&gt;&lt;/x9&gt;&lt;/x4&gt;&lt;/x1&gt;</pre>
          Zeichnen Sie dieses Dokument als Baum.
          Welche Dokumente selektieren, die folgenden XPath-Ausdr&uuml;cke ausgehend
  von der Wurzel dieses Dokuments
              
                //x5/x6
              
              
                /descendant-or-self::x5/..
              
              //x5/ancestor::*
              /x1/x2/following-sibling::*
              /descendant-or-self::text()/parent::node()
            
        Schreiben Sie eine MethodeList&lt;Node&gt; getLeaves(Node n);, 
die f&uuml;r einen DOM Knoten, die Liste aller seiner Bl&auml;tter zur&uuml;ckgibt.
          <pre>package name.panitz.xml.exercise;
import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.*;

public class GetLeaves{
  public List&lt;Node&gt; getLeaves(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    NodeList ns = n.getChildNodes();
    if (ns.getLength()==0){
      result.add(n); return result;
    }
    for (int i=0;i&lt;ns.getLength();i++){
      result.addAll(getLeaves(ns.item(i)));
    }
    return result;
  }
}</pre>
        
<h1>11. Steuerf&auml;den</h1>
<h2>11.1. Schreiben von Steuerf&auml;den</h2>
        Durch Ableiten von der Klasse Thread und
&uuml;berschreiben der Methode run.
        Durch Implementierung der Schnittstelle Runnable, die
Methode run enth&auml;lt.
      ThreadRunnableThreadgetName()Threadstart()run()runrunFolgendes Programm definiert einen simplen Steuerfaden, der unendlich oft seinen Namen auf den Bildschirm ausgibt.  In 
der main-Methode werden zwei Instanzen dieses Steuerfadens
erzeugt und gestartet. Anhand der Ausgabe des Programms kann verfolgt werden, wie Java zwischen den zwei Steuerf&auml;den umschaltet:<pre>class SimpleThread extends Thread { 

  public void run(){
    while (true){
      System.out.print(getName());
    }
  }

  public static void main(String [] args){
    new SimpleThread().start();
    new SimpleThread().start();
  }
}</pre>
<h3>11.1.1. Schlafenlegen von Prozessen</h3>Threadvoid sleep(long millis)
Unseren ersten Steuerfaden aus dem letzten Beispiel erweitern wir jetzt
darum, da&szlig; er sich jeweils eine bestimmte Zeit zur Ruhe legt, nachdem er seinen Namen ausgedruckt hat: <pre>class SleepingThread extends Thread {
  public SleepingThread(int s){this.s=s;}
  private int s; 

  public void run(){
    while (true){
      System.out.print(getName());
      try {Thread.sleep(s);}catch (InterruptedException _){}
    }
  }

  public static void main(String [] args){
    new SleepingThread(1000).start();
    new SleepingThread(300).start();
  }
}</pre>
Wenn das Programm l&auml;uft, sieht man, da&szlig; der Steuerfaden, der k&uuml;rzer schl&auml;ft, h&auml;ufiger seinen Namen ausgibt: sep@swe10:~/fh/internal/beispiele&gt; java SleepingThread
Thread-1Thread-0Thread-1Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1
Thread-0Thread-1Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1Thread-1
Thread-0Thread-1Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1Thread-0
Thread-1Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1Thread-1Thread-0
Thread-1Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1Thread-0Thread-1
Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1Thread-1Thread-0Thread-1
Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1Thread-0
sep@swe10:~/fh/internal/beispiele&gt;
sleepThreadrunsleep<h2>11.2. Koordination nebenl&auml;ufiger Steuerf&auml;den</h2>
<h3>11.2.1. Benutzung gemeinsamer Objekte</h3>swapswapsleep<pre>class TwoNumbers{
   int x;
   int y;

   TwoNumbers(int x, int y) {this.x=x; this.y=y;}

   void swap(){
     int z=x;
     x=y;
     try {Thread.sleep(100);}catch (InterruptedException _){}
     y=z;
   }

   public String toString(){return "("+x+","+y+")";}
}</pre>swapTwoNumbers<pre>class Swap extends Thread{

  public Swap(TwoNumbers twoN){this.twoN=twoN;}

  private TwoNumbers twoN;

  public void run(){
    while (true){twoN.swap();}
  }
}</pre>TwoNumbers<pre>class PrintTwoNumbers extends Thread {
  public PrintTwoNumbers(TwoNumbers twoN){this.twoN=twoN;}

  private TwoNumbers twoN;

  public void run(){
    while (true){
      System.out.println(twoN);
      try {Thread.sleep(1000);}catch (InterruptedException _){}
    }
  }

  public static void main(String [] _){
    TwoNumbers twoN = new TwoNumbers(1,2);
    new Swap(twoN).start();
    new PrintTwoNumbers(twoN).start();
  }
}</pre>sep@swe10:~/fh/internal/beispiele&gt; java PrintTwoNumbers
(1,2)
(1,1)
(2,2)
(1,1)
(2,2)
(1,1)
(1,1)
(2,2)
(1,1)
(2,2)
(1,1)
(1,1)
(2,2)

sep@swe10:~/fh/internal/beispiele&gt;TwoNumbersswap<h3>11.2.2. Synchronisation</h3>
<h4>11.2.2.1. Synchronisation von Methoden</h4>synchronizedsynchronizedTwoNumberstoStringswap<pre>class SafeTwoNumbers{
  int x;
  int y;

  SafeTwoNumbers(int x, int y) {this.x=x; this.y=y;}

  synchronized void swap(){
    int z=x;
    x=y;
    try {Thread.sleep(400);}catch (InterruptedException _){}
    y=z;
  }

  synchronized public String toString(){
    return "("+x+","+y+")";
  }
}</pre>PrintTwoNumbersSafeTwoNumberssep@swe10:~/fh/internal/beispiele&gt; java PrintTwoNumbers
(1,2)
(2,1)
(1,2)
(2,1)
(1,2)
(2,1)
(1,2)
(2,1)

sep@swe10:~/fh/internal/beispiele&gt;<h4>11.2.2.2. Synchronisation von Bl&ouml;cken</h4>synchronized
            
              synchronized (
              obj
              )
              stats
              
                
              
            
          twoNswap<pre>class SafeSwap extends Thread{

  public SafeSwap(TwoNumbers twoN){this.twoN=twoN;}

  private TwoNumbers twoN;

  public void run(){
    while (true){
      synchronized(twoN){twoN.swap();}
    }
  }
}</pre>
<pre>class SafePrintTwoNumbers extends Thread {
  public SafePrintTwoNumbers(TwoNumbers twoN){this.twoN=twoN;}

  private TwoNumbers twoN;

  public void run(){
    while (true){
      synchronized (twoN){System.out.println(twoN);}
      try {Thread.sleep(1000);}catch (InterruptedException _){}
    }
  }

  public static void main(String [] _){
    TwoNumbers twoN = new TwoNumbers(1,2);
    new SafeSwap(twoN).start();
    new SafePrintTwoNumbers(twoN).start();
  }
}</pre>twoNswap<h3>11.2.3. Verklemmungen</h3>Im Skript von Herrn 
Grude findet sich die etwas drastischere deutsche Bezeichnung t&ouml;dliche  Umklammerung.<h4>11.2.3.1. Verklemmung bei der Buchausleihe</h4>HansLisaProgrammierenSoftwaretechnik<h4>11.2.3.2. Das 5-Philosophenproblem</h4>
<h4>11.2.3.3. Verklemmung im Stra&szlig;enverkehr</h4>
<h4>11.2.3.4. Verklemmung in Java</h4>run<pre>class Deadlock extends Thread{

  Object a;
  Object b;

  Deadlock (Object a,Object b){this.a=a;this.b=b;}

  public void run(){
    synchronized (a){
      System.out.println(
        getName()+"jetzt habe ich das erste Objekt: "+a);   
      try {Thread.sleep(1000);}catch (InterruptedException _){}
      synchronized (b){
	  System.out.println(getName()+"jetzt habe ich beide");   
      }
    }
  }

  public static void main(String [] _){
    String s1 = "hallo";
    String s2 = "welt";
    new Deadlock(s1,s2).start();
    new Deadlock(s2,s1).start();
  }
}</pre>s1s2sep@swe10:~/fh/internal/beispiele&gt; java Deadlock
Thread-0jetzt habe ich das erste Objekt: hallo
Thread-1jetzt habe ich das erste Objekt: welt

<h3>11.2.4. Warten und Benachrichtigen</h3>waitnotifyAll<pre>class GetSet1 {
  private int i;
  GetSet1(int i){this.i=i;}

  synchronized int get(){return i;}
  synchronized void set(int i){this.i=i;}
}</pre>
<pre>class Set extends Thread{
  GetSet1 o;
  Set(GetSet1 o){this.o=o;}
  public void run(){
    for (int i=1;i&lt;=1000;i=i+1){
      o.set(i);
    }
  }
}</pre>
<pre>class Get extends Thread{
  GetSet1 o;
  Get(GetSet1 o){this.o=o;}
  public void run(){
    for (int i=1;i&lt;=1000;i=i+1){
      System.out.print(o.get()+" ");
    }
  }

  public static void main(String [] _){
    GetSet1 gss = new GetSet1(0);
    new Get(gss).start();
    new Set(gss).start();
  }
}</pre>
<pre>class GetSet2 {
  private int i;
  private boolean available= true;
  GetSet2(int i){this.i=i;}

  synchronized int get(){
    while (!available){
      try{Thread.sleep(1000);}catch (Exception _){}
    }    
    available=false;
    return i;
  }

  synchronized void set(int i){
    while (available){
      try{Thread.sleep(1000);}catch (Exception _){}
    }
    this.i=i;
    available=true;
  }
}</pre>waitnotifyAllsleepwaitwaitnotifyAll<pre>class GetSet3 {
  private int i;
  private boolean available= true;
  GetSet3(int i){this.i=i;}

  synchronized int get(){
    while (!available){
      try{wait();}catch (Exception _){}
    }    
    available=false;
    notifyAll();
	 
    return i;
  }

  synchronized void set(int i){
    while (available){
      try{wait();}catch (Exception _){}
    }
    this.i=i;
    available=true;
    notifyAll();
  }
}</pre>wait<h1>12. Swing: Eine Bibliothek f&uuml;r graphische Oberfl&auml;chen</h1>GUI ist die Abk&uuml;rzung 
f&uuml;r graphical user interface. Entsprechend w&auml;re GRABO eine 
Abk&uuml;rzung f&uuml;r das deutsche graphische Benutzeroberfl&auml;che. Im
Skript von Herrn Grude wird dieser sehr sch&ouml;ne  Ausdruck f&uuml;r 
GUI verwendet.
      java.awt: Dieses ist das &auml;ltere Paket zur
GUI-Programmierung. Es enth&auml;lt Klassen f&uuml;r viele graphische Objekte
(z.B.eine Klasse Button) und Unterpakete, 
zur Programmierung der Funktionalit&auml;t der einzelnen
Komponenten. 
      javax.swing: Dieses neuere Paket ist noch universeller
und platformunabh&auml;ngiger als das java.awt-Paket. Auch hier
finden sich Klassen f&uuml;r unterschiedliche GUI-Komponenten. Sie
entsprechen den Klassen aus dem Paket java.awt. Die Klassen
haben oft den gleichen Klassennamen wie in java.awt jedoch
mit einem J vorangestellt. So gibt es z.B.eine
Klasse JButton.
    awtswingjavax.swingjava.awtjava.awtjavax.swing<h2>12.1. Graphische Benutzeroberfl&auml;chen</h2>
        Komponenten
        Ereignisbehandlung
        Layoutsteuerung
      <h3>12.1.1. Graphische Komponenten</h3>swing
          Top-Level Komponenten
          Zwischenkomponenten
          Atomare Komponenten
        java.awt.Component<h4>12.1.1.1. Top-Level Komponenten</h4>JFrame, JDialogAppletsJAppletJFrame
Das minimalste GUI-Programm ist wahrscheinlich folgendes
Programm, das ein Fensterobjekt erzeugt und dieses sichtbar macht.<pre>package name.panitz.simpleGui;
import javax.swing.*;

public class Window1{
  public static void main(String [] _){
    new JFrame("erstes Fenster").setVisible(true);
  }
}</pre>

Dieses Programm erzeugt ein leeres Fenster und gibt das auf dem
Bildschirm aus. 
Der Fenstertitel kann als Argument dem Konstruktor der 
Klasse JFrame als String &uuml;bergeben werden.
Die optische Auspr&auml;gung des Fensters kann vom Betriebssystem
abh&auml;ngen. In Abbildung  ist dieses Fenster
beispielhaft in einer Suse Linux Umgebung mit KDE zu bewundern.<h4>12.1.1.2. Zwischenkomponenten</h4>JPanelJScrollPaneJTabbedPaneJFramegetContentPane<h4>12.1.1.3. Atomare Komponenten</h4>JButton, JTextField, JTable JComBoxaddpack
Das folgende Programm erzeugt ein Fenster mit einer Textfl&auml;che. <pre>package name.panitz.simpleGui;
import javax.swing.*;

class JT {
  public static void main(String [] _){
    JFrame frame = new JFrame();
    JTextArea textArea = new JTextArea();
    textArea.setText("hallo da drau&szlig;en");
    frame.getContentPane().add(textArea);
    frame.pack();
    frame.setVisible(true);
  }
}</pre>
Das Programm erzeugt das folgende Fenster:JFrame
Die folgende Klasse definiert ein Fenster, das einen Knopf und eine
Textfl&auml;che enth&auml;lt. In der Hauptmethode wird das Objekt instanziiert: <pre>package name.panitz.simpleGui;
import javax.swing.*;

class JTB extends JFrame {
  JPanel pane = new JPanel();
  JTextArea textArea = new JTextArea();
  JButton button = new JButton("ein Knopf");

  public JTB(){
    textArea.setText("hallo da drau&szlig;en");
    pane.add(textArea);
    pane.add(button);
    getContentPane().add(pane);
    pack();
    setVisible(true);
  }

  public static void main(String [] _){
    new JTB();
  }
}</pre>
Das Programm erzeugt folgendes Fenster:<h3>12.1.2. Ereignisbehandlung</h3>Listenerjava.awt.event.*
Als erstes Beispiel f&uuml;r eine Ereignisbehandlung betrachten wir die vielleicht
elementarste Art eines Ereignisses: ein Knopf wird gedr&uuml;ckt. Hierzu gibt es
die elementare 
Ereignisbehandlungsschnittstelle: java.awt.event.ActionListener. 
Diese Schnittstelle enth&auml;lt nur eine Methode: actionPerformed

Wir implementieren diese Schnittstelle. Unsere Klasse zur Ereignisbehandlung
bekommt dabei ein Textfeld &uuml;bergeben. Intern enthalte die
Klasse einen Z&auml;hler. Wann immer das Ereignis eintritt, soll der Z&auml;hler um eins
erh&ouml;ht werden und das neue Ergebnis des Z&auml;hlers im Textfeld angezeigt werden.<pre>package name.panitz.simpleGui;
import java.awt.event.*;
import javax.swing.*;

public class CounterListener implements ActionListener{
  private final JTextArea textArea;
  private int counter = 0;
  public CounterListener(JTextArea ta){textArea=ta;}

  public void actionPerformed(ActionEvent _){
    counter = counter+1;
    textArea.setText(counter+"");
  } 
}</pre>
 
Jetzt k&ouml;nnen wir eine Unterklasse unserer letzten  kleinen 
Gui-Klasse JTB schreiben, in der diese Ereignisbehandlung dem Knopf
hinzugef&uuml;gt wird. Hierzu gibt es f&uuml;r Kn&ouml;pfe die 
Methode addActionListener.<pre>package name.panitz.simpleGui;
import javax.swing.*;

class Counter extends JTB {
  public Counter(){
    super();
    button.addActionListener(new CounterListener(textArea));
  }

  public static void main(String [] _){new Counter();}
}</pre>

Und tats&auml;chlich, wenn wir dieses Programm starten, so bewirkt, da&szlig; ein Dr&uuml;cken
des Knopfes mit der Maus bewirkt, da&szlig; im Textfeld angezeigt wird, wie oft
bisher der Knopf gedr&uuml;ckt wurde.
Die Methode actionPerformed der 
Schnittstelle ActionListener bekommt ein Objekt der 
Klasse ActionEvent &uuml;bergeben. In dieser gibt es eine 
Methode getWhen, die den Zeitpunkt, zu dem das Ereignis aufgetreten
ist als eine Zahl kodiert zur&uuml;ckgibt. Mit dieser Zahl k&ouml;nnen Sie die 
Klasse java.util.Date instanziieren, um ein Objekt zu bekommen, das
Datum und Uhrzeit enth&auml;lt.
Schreiben Sie jetzt eine Unterklasse von JTB, so da&szlig; beim Dr&uuml;cken des
Knopfes, jetzt die aktuelle Uhrzeit im Textfeld erscheint.Schreiben Sie eine kleine Guianwendung mit einer Textfl&auml;che und drei
Kn&ouml;pfen, die einen erweiterten Z&auml;hler darstellt:
            einen Knopf zum Erh&ouml;hen eines Z&auml;hlers.
            einen Knopf zum Verringern des Z&auml;hlers um 1.
            einen Knopf zum Zur&uuml;cksetzen des Z&auml;hlers auf 0.
          <h3>12.1.3. Setzen des Layouts</h3>addLayout-ManagerLayoutManagersetLayout<h4>12.1.3.1. Flow Layout</h4>FlowLayout
Die folgende Klasse definiert ein Fenster, dessen Layout &uuml;ber ein
Objekt der Klasse FlowLayout gesteuert wird. Dem Fenster
werden f&uuml;nf Kn&ouml;pfe hinzugef&uuml;gt:<pre>package name.panitz.gui.layoutTest;

import java.awt.*;
import javax.swing.*;

class FlowLayoutTest extends JFrame {

  public FlowLayoutTest(){
    Container pane = getContentPane();
    pane.setLayout(new FlowLayout());
    pane.add(new JButton("eins"));
    pane.add(new JButton("zwei"));
    pane.add(new JButton("drei (ein langer Knopf)"));
    pane.add(new JButton("vier"));
    pane.add(new JButton("fuenf"));
    pack();
    setVisible(true);
  }

  public static void main(String [] _){new FlowLayoutTest();}
}</pre>
Das Fenster hat folgende optische Auspr&auml;gung.
Ver&auml;ndert man mit der Maus die Fenstergr&ouml;&szlig;e, macht es
z.B.schmal und hoch, so werden die Kn&ouml;pfe nicht mehr
nebeneinander sonder &uuml;bereinander angeordnet.<h4>12.1.3.2. Border Layout</h4>BorderLayoutaddBorderLayout
In dieser Klasse wird die Klasse BorderLayout zur Steuerung
des Layoout benutzt. Die f&uuml;nf Kn&ouml;pfe werden an jeweils eine der f&uuml;nf
Positionen hinzugef&uuml;gt:<pre>package name.panitz.gui.layoutTest;

import java.awt.*;
import javax.swing.*;

class BorderLayoutTest extends JFrame {

  public BorderLayoutTest(){
    Container pane = getContentPane();
    pane.setLayout(new BorderLayout());
    pane.add(new JButton("eins"),BorderLayout.NORTH);
    pane.add(new JButton("zwei"),BorderLayout.SOUTH);
    pane.add(new JButton("drei (ein langer Knopf)")
                                ,BorderLayout.CENTER);
    pane.add(new JButton("vier"),BorderLayout.WEST);
    pane.add(new JButton("fuenf"),BorderLayout.EAST);
    pack();
    setVisible(true);
  }

  public static void main(String [] _){new BorderLayoutTest();}
}</pre>

Die Klasse erzeugt das folgende Fenster.
Das Layout &auml;ndert sich nicht, wenn man mit der Maus die Gr&ouml;&szlig;e und das
Format des Fensters ver&auml;ndert. <h4>12.1.3.3. Grid Layout</h4>GridLayout
Folgende Klasse benutzt ein Grid-Layout mit zwei Zeilen zu je drei
Spalten. <pre>package name.panitz.gui.layoutTest;

import java.awt.*;
import javax.swing.*;

class GridLayoutTest extends JFrame {
  public GridLayoutTest(){
    Container pane = getContentPane();
    pane.setLayout(new GridLayout(2,3));
    pane.add(new JButton("eins"));
    pane.add(new JButton("zwei"));
    pane.add(new JButton("drei (ein langer Knopf)"));
    pane.add(new JButton("vier"));
    pane.add(new JButton("f&uuml;nf"));
    pack();
    setVisible(true);
  }

  public static void main(String [] _){new GridLayoutTest();}
}</pre>
Folgendes Fensters wird durch dieses Programm ge&ouml;ffnet.
Auch hier &auml;ndert sich das Layout nicht, wenn man mit der Maus die
Gr&ouml;&szlig;e und das 
Format des Fensters ver&auml;ndert. <h2>12.2. Exkurs: verschachtelte Klassen</h2>innere Klassen<h3>12.2.1. Innere Klassen</h3>
Unser erstes GUI mit einer Funktionalit&auml;t l&auml;&szlig;t sich jetzt mit Hilfe einer
inneren Klasse in einer Datei schreiben. Das Feld counter, das wir in
der vorherigen Implementierung als privates Feld der 
Klass CounterListener definiert hatten, haben wir hier als Feld der
GUI-Klasse modelliert. Trotzdem kann die 
Klasse CounterListener weiterhin darauf zugreifen. Ebenso brauch die
Textfl&auml;che nicht der Klasse CounterListener im Konstruktor &uuml;bergeben
werden. Als innere Klasse kann in CounterListener auf dieses Feld der
&auml;u&szlig;eren Klasse zugegriffen werden.<pre>package name.panitz.simpleGui;
import javax.swing.*;
import java.awt.event.*;

class InnerCounter extends JTB {
  private int counter = 0;

  class CounterListener implements ActionListener{
    public void actionPerformed(ActionEvent _){
      counter = counter+1;
      textArea.setText(counter+"");
    } 
  }

  public InnerCounter(){
    button.addActionListener(new CounterListener());
  }

  public static void main(String [] _){new InnerCounter();}
}</pre>
Tats&auml;chlich ist die Implementierung k&uuml;rzer und etwas &uuml;bersichtlicher
geworden. sep@linux:~/fh/prog2/examples/classes/name/panitz/simpleGui&gt; ll *.class
-rw-r--r--    1 sep      users        1082 2004-03-29 11:36 InnerCounter$CounterListener.class
-rw-r--r--    1 sep      users         892 2004-03-29 11:36 InnerCounter.class
Schreiben Sie Ihr Programm eines Z&auml;hlers mit drei Kn&ouml;pfen jetzt so, da&szlig; sie
innere Klassen benutzen.<h3>12.2.2. Anonyme Klassen</h3>new
Wir schreiben ein drittes Mal die Klasse Counter. Diesmal wird statt
der nur einmal instanziierten inneren Klasse eine anonyme Implementierung der
Schnittstelle ActionListener Instanziiert.<pre>package name.panitz.simpleGui;
import javax.swing.*;
import java.awt.event.*;

class AnonymousCounter extends JTB {
  private int counter = 0;

  public AnonymousCounter(){
    button.addActionListener(
      new ActionListener(){
        public void actionPerformed(ActionEvent _){
          counter = counter+1;
          textArea.setText(counter+"");
        } 
      });
  }

  public static void main(String [] _){new AnonymousCounter();}
}</pre>sep@linux:~/fh/prog2/examples/classes/name/panitz/simpleGui&gt; ll *.class
-rw-r--r--    1 sep      users        1106 2004-03-29 11:59 AnonymousCounter$1.class
-rw-r--r--    1 sep      users         887 2004-03-29 11:59 AnonymousCounter.class
sep@linux:~/fh/prog2/examples/classes/name/panitz/simpleGui&gt;<h3>12.2.3. Statische verschachtelte Klassen</h3>
<h2>12.3. Applets</h2>appletsAppletAppletTag&lt;applet&gt;mosaicnetscapeWohingehend, wenn man heute das winkende
M&auml;nnchen sieht, es sich meistens um eine animierte gif-Datei handelt. Animiert
hinjtereinander zu spielende Bilder kannte auch damals bereits das gif-Format,
wurde allerdings nur von wenigen Werkzeugen unterst&uuml;tzt.<h3>12.3.1. Die Klasse JApplet</h3>java.applet.Appletjavax.swing.JAppletAppletAppletPaneladdCounterJFrameJPanelJFrameJApplet<pre>
import javax.swing.*;
import java.awt.event.*;
public class  CounterPanel extends JPanel{
  int i=0;
  JButton b=new JButton("just Push");
  JLabel l=new JLabel("  ");
  public CounterPanel(){
    b.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent e){
        i=i+1;
	l.setText(i+"");
	repaint();
      }
    });
    add(b);
    add(l);
  }
}</pre>JAppletaddJApplet<pre>import javax.swing.*;
public class CountApplet extends JApplet{
  public CountApplet(){add(new CounterPanel());}
}</pre>appletcode<pre>&lt;html&gt;&lt;body&gt;
&lt;h1&gt;Ein erstes Applet&lt;/h1&gt;
Dieses Applet z&auml;hlt einen internen Z&auml;hler hoch, wenn der Knopf gedr&uuml;ckt wird.
&lt;applet code="CountApplet.class" 
        codebase="../classes/"
        width="600" height="60"&gt;
    &lt;param name="maxwidth" value="120"&gt;
    &lt;param name="nimgs" value="17"&gt;
    &lt;param name="offset" value="-57"&gt;
Your browser is completely ignoring the &amp;lt;APPLET&amp;gt; tag!
&lt;/applet&gt;
&lt;/body&gt;&lt;/html&gt;</pre>
<h3>12.3.2. Methoden eines Applets</h3>
<h3>12.3.3. Sicherheit</h3>
<h3>12.3.4. Laden von weiteren Resourcen</h3>
<h2>12.4. Selbstdefinierte graphische Komponenten</h2>
<h3>12.4.1. Graphics Objekte</h3>JFrameJFrameJComponentpaintComponentpaintComponent<pre>public void paintComponent(java.awt.Graphics g)</pre>java.awt.GraphicsGraphicspaintComponentGraphicsJPanelpaintComponentFolgende Klasse definiert eine neue graphische Komponente,
die zwei Linien, einen Text, ein Rechteck, ein Oval und ein gef&uuml;lltes
Kreissegment enth&auml;lt.<pre>package name.panitz.gui.graphicsTest;

import javax.swing.JPanel;
import javax.swing.JFrame;
import java.awt.Graphics;

class SimpleGraphics extends JPanel{
  public void paintComponent(Graphics g){
    g.drawLine(0,0,100,200);
    g.drawLine(0,50,100,50);
    g.drawString("hallo",10,20);
    g.drawRect(10, 10, 60,130); 
    g.drawOval( 50,  100, 30, 80); 
    g.fillArc(-20, 150, 80, 80, 0, 50); 
  } 
}</pre>

Diese Komponente k&ouml;nnen wir wie jede andere Komponente auch einem
Fenster hinzuf&uuml;gen, so da&szlig; sie auf dem Bildschirm angezeigt werden
kann. <pre>package name.panitz.gui.graphicsTest;
 
import javax.swing.JFrame;

class UseSimpleGraphics {
  public static void main(String [] args){
    JFrame frame = new JFrame();
    frame.getContentPane().add(new SimpleGraphics());

    frame.pack();
    frame.setVisible(true);
  }
}</pre>

Wird dieses Programm gestartet, so &ouml;fnet Java das  Fenster 
aus Abbildung auf dem Bildschirm.  

Erst wenn wir das Fenster mit der Maus gr&ouml;&szlig;er
ziehen, k&ouml;nnen wir das ganze Bild sehen. <h3>12.4.2. Dimensionen</h3>JComponentSimpleGraphics<pre>  public java.awt.Dimension getPreferredSize() {
    return new java.awt.Dimension(100,200);
  }</pre> Schreiben Sie eine
GUI-Komponente StrichKreis, die mit geraden Linien einen Kreis 
entsprechend untenstehender Abbildung malt. Der Radius des Kreises 
soll dabei dem Konstruktor der 
Klasse StrichKreis als int-Wert 
&uuml;bergeben werden. 
Testen Sie Ihre Klasse mit folgender Hauptmethode: <pre>public static void main(String [] args) {
  StrichKreis k = new StrichKreis(120);
  JFrame f = new JFrame();
  JPanel p = new JPanel();
  p.add(new StrichKreis(120));
  p.add(new StrichKreis(10));
  p.add(new StrichKreis(60));
  p.add(new StrichKreis(50));
  p.add(new StrichKreis(70));
  f.getContentPane().add(p);

  f.pack();
  f.setVisible(true);
}</pre>Hinweis: In der Klasse java.lang.Math finden Sie Methoden 
trigeometrischer Funktionen. 
Insbesondere toRadians zum Umrechnen von Gardwinkel in Bogenma&szlig; 
sowie sin und cos. <h3>12.4.3. Farben</h3>GraphicsGraphicsGraphics<pre>public abstract void setColor(java.awt.Color c)</pre>java.awt.ColorColorColor.REDColor.GREEN
Wir k&ouml;nnen eine kleine Klasse schreiben, in der wir ein wenig
mit Farben spielen. Wir setzen die Hintergrundfarbe des Objekts
auf einen dunklen Grauwert, zeichnen darin ein dunkelgr&uuml;nes Rechteck, 
ein rotes Oval und ein gelbes Oval.<pre>package name.panitz.gui.graphicsTest;

import javax.swing.JPanel;
import javax.swing.JFrame;

public class ColorTest extends JPanel{
  public ColorTest(){
    //Hintergrundfarbe auf einen dunklen Grauton setzen
    setBackground(new java.awt.Color(100,100,100));
  }  

  public void paintComponent(java.awt.Graphics g){
    //Farbe auf einen dunklen Gr&uuml;nton setzen
    g.setColor(new java.awt.Color(22,178,100));
    //Rechteck zeichnen
    g.fillRect(25,50,50,100);
    //Farbe auf rot setzen
    g.setColor(java.awt.Color.RED);
    g.fillOval(25,50,50,100);
    //Farbe auf gelb setzen
    g.setColor(java.awt.Color.YELLOW);
    g.fillOval(37,75,25,50);
  }

  public java.awt.Dimension getPreferredSize() {
    return new java.awt.Dimension(100,200);
  }

  public static void main(String [] _){
    javax.swing.JFrame f = new JFrame("Farben");
    f.getContentPane().add(new ColorTest());
    f.pack();f.setVisible(true);
  }
} </pre>

Das Programm ergibt das Bild aus Abbildung .Erweitern Sie die Strichkreisklasse aus der letzten Aufgabe, so da&szlig;
jeder Strich in einer anderen Farbe gezeichnet wird.<h4>12.4.3.1. Fraktale</h4>
<pre>package name.panitz.crempel.tool.apfel;

public class Complex{</pre>
<pre>  public double re;
  public double im;</pre>
<pre> public Complex(double re,double im){
  this.re=re;this.im=im;
}</pre>
<pre>  public Complex add(Complex other){
    return new Complex(re+other.re,im+other.im);
  }

  public Complex mult(Complex other){
    return new Complex
      (re*other.re-im*other.im,re*other.im+im*other.re);
  }</pre>
<pre>  public double norm(){return re*re+im*im;}
}</pre>z_{n+1} = z_n^2 + cz_00+0i0cnz_nn<pre>package name.panitz.crempel.tool.apfel;

import java.awt.Graphics;
import java.awt.Color;
import java.awt.Dimension;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Apfelmaennchen extends JPanel {</pre>
<pre>  final int width = 480;
  final int height = 430;</pre>
<pre>  double zelle=0.00625;</pre>
<pre>  final Color colAppleman = new Color(0,129,190);</pre>Graphics<pre>  double startX = -2;
  double startY = -1.35;</pre>nz_n<pre>  final int recDepth = 50;
  final int schwellwert = 4;</pre>z_{n+1} = z_n^2 + ccnz_n<pre>  //C-Werte checken nach zn+1 = zn*zn + c, 
  public int checkC(Complex c) {        
    Complex zn = new Complex(0,0);

    for (int n=0;n&lt;recDepth;n=n+1) {
      final Complex znp1 = zn.mult(zn).add(c);
      if (znp1.norm() &gt; schwellwert) return n;
      zn=znp1;
    }
    return recDepth;
  }</pre>GraphicscheckCz_n<pre>  public void paint(Graphics g) {
    for (int y=0;y&lt;height;y=y+1) {
      for (int x=0;x&lt;width;x=x+1) {

        final Complex current
          =new Complex(startX+x*zelle,startY+y*zelle);  

        final int iterationenC = checkC(current);

        paintColorPoint(x,y,iterationenC,g);
      }
    }
  }</pre>it(x,y)<pre>  private void paintColorPoint
                 (int x,int y,int it,Graphics g){
    final Color col
      = it==recDepth
        ?colAppleman   
        :new Color(255-5*it%1,255-it%5*30,255-it%5* 50);
    g.setColor(col); 
    g.drawLine(x,y,x,y);
  }</pre>
<pre>  public Dimension getPreferredSize(){
    return new Dimension(width,height);
  }

  public static void main(String [] args){
    JFrame f = new JFrame();
    f.getContentPane().add(new Apfelmaennchen());
    f.pack();
    f.setVisible(true);
  }
}</pre>
<h3>12.4.4. Fonts und ihre Metrik</h3>Graphicsjava.awt.FontgetColorsetColorGraphicsgetFontsetFontjava.awt.FontMetricsGraphicsFontMetrics
Folgende Kleine Klasse vergr&ouml;&szlig;ert nach und nach den Font, und
malt in verschiedenen Gr&ouml;&szlig;en einen Text in ein Fenster.<pre>package name.panitz.gui.graphicsTest;

import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Dimension;
import javax.swing.JPanel;
import javax.swing.JFrame;


class FontTest extends JPanel {

  public Dimension getPreferredSize(){
    return new Dimension(250,650);
  }
  
  public void paintComponent(Graphics g){
    //die y-Koordinate f&uuml;r einen Text
    int where = 0;

    //25 mal
    for (int i=1; i&lt;=25;i=i+1){
      //nimm aktuellen Font und seine Ma&szlig;e
      final Font f = g.getFont();
      final FontMetrics fm = g.getFontMetrics(f);

      //gehe die H&ouml;he des Fonts weiter in Richtung x
      where = where + (f.getSize()) ;

      //male "hallo"
      g.drawString("hallo",0,where);      

      //berechne wo der gerade gemalte String endet
      //und male dort "welt"
      g.drawString
        ("welt!",fm.stringWidth("hallo "),where);      

      //ver&auml;ndere die Fontgr&ouml;&szlig;e. Erh&ouml;he sie um 1.
      g.setFont(getFont().deriveFont(f.getSize2D()+1));
    }
  } 

  public static void main(String [] _){
    JFrame f = new JFrame("Fonts");
    f.getContentPane().add(new FontTest());
    f.pack();
    f.setVisible(true); 
  }
}</pre>

Das Programm ergibt das Bild aus Abbildung .<h3>12.4.5. Erzeugen graphischer Dateien</h3>java.awt.image.RenderedImageGraphicsRenderedImagepaintGraphicsjavax.imageio.ImageIORenderedImage
Wir schreiben eine kleine Klasse mit Methoden, 
um das Bild einer graphischen Komponente in eine
Datei zu speichern.

Zun&auml;chst brauchen wir eine ganze Reihe von Klassen, die wir importieren:<pre>package name.panitz.gui.graphicsFile;

import name.panitz.crempel.tool.apfel.Apfelmaennchen;
import java.awt.image.BufferedImage;
import java.awt.image.RenderedImage;
import java.awt.Dimension;
import java.awt.Graphics;

import javax.imageio.ImageIO; 
import javax.swing.JComponent; 

import java.io.File;
import java.io.IOException;</pre>

Wir schreiben eine Hauptmethode, die als Kommandozeilenparameter den
Namen der zu schreibenen Bilddatei &uuml;bergeben bekommt:<pre>public class ComponentToFile {
  public static void main(String [] args){</pre>
Zu Testzwecken schreiben wir je eine png- und 
eine jpg-Datei, in die wir die Komponente zeichnen wollen:<pre>   try {
     final JComponent component = new Apfelmaennchen();
     final RenderedImage image = createComponentImage(component);
     ImageIO.write(image,"png", new File(args[0]+".png"));
     ImageIO.write(image,"jpg", new File(args[0]+".jpg"));
    }catch (IOException e) {System.out.println(e);}
  }</pre>

Die folgende Methode erzeugt das eigentliche Bild der Komponente:<pre>  static public RenderedImage createComponentImage
                                (JComponent component) {</pre>
Wir erzeugen ein Bildobjekt in der f&uuml;r die Komponente ben&ouml;tigten Gr&ouml;&szlig;e.<pre>     Dimension d = component.getPreferredSize();
     BufferedImage bufferedImage 
      = new BufferedImage((int)d.getWidth(),(int)d.getHeight()
                         ,BufferedImage.TYPE_INT_RGB);</pre>
Nun besorgen wir dessen Graphics-Umgebung:<pre>    Graphics g = bufferedImage.createGraphics();</pre>

Darin l&auml;&szlig;t sich  unsere Komponente zeichnen:<pre>   component.paint(g);</pre>
Die Methode kann das fertig gezeichnete Bild als Ergebnis zur&uuml;ckgeben: <pre>    return bufferedImage;
  }
}</pre>
<h3>12.4.6. Graphics2D</h3>Graphicsjava.awt.Graphics2DpaintGraphicsGraphics2D<pre>public void paint(Graphics g) {
    Graphics2D g2 = (Graphics2D) g;
    ...
}</pre>Graphics2DFolgende Klasse benutzt willk&uuml;rlich ein paar Eigenschaften 
der Graphics2D-Klasse, um einen Eindruck &uuml;ber die Arbeitsweise dieser
Klasse zu geben. Eine systematische Behandlung aller graphischen 
Methoden
ist nicht
Gegenstand dieser Vorlesung. <pre>package name.panitz.gui.g2d;
import javax.swing.JPanel;
import javax.swing.JFrame;

import java.awt.font.*;
import java.awt.*;
import java.awt.geom.*;

public class G2DTest extends JPanel{
  int w = 550;
  int h = 650;

  public Dimension getPreferredSize(){
    return new Dimension(w,h);}

  public void paintComponent(Graphics g){
    Graphics2D g2 = (Graphics2D) g;
    TextLayout textTl 
     = new TextLayout
             ("Kommunismus", new Font("Helvetica", 1, 96)
             , new FontRenderContext(null, false, false));

    AffineTransform textAt = new AffineTransform();
    textAt.translate(0,(float)textTl.getBounds().getHeight());
    Shape shape = textTl.getOutline(textAt);

    AffineTransform at = new AffineTransform();
    at.rotate(Math.toRadians(45));
    at.shear(1.5, 0.0);

    g2.transform(at);

    float dash[] = {10.0f};
    g2.setStroke(
      new BasicStroke
           (3.0f, BasicStroke.CAP_BUTT
           ,BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f)
    );

    g2.setPaint(
      new GradientPaint(0,0,Color.black,w,h
                       ,new Color(255,100,100),false)
    );

    g2.fill(shape);
    g2.setColor(Color.darkGray);
    g2.draw(shape);
  }
  
  public static void main(String [] _){
    JFrame f = new JFrame("G2");
    f.getContentPane().add(new G2DTest());
    f.pack();
    f.setVisible(true);
  }
}</pre>

Das Programm &ouml;ffnet das Fenster aus 
Abbildung auf dem Bildschirm. <h2>12.5. B&auml;ume graphisch darstellen</h2>
<h3>12.5.1. B&auml;ume mit JTree graphisch darstellen</h3>swingjavax.swingJTreeJTree(TreeNode root)JTreejavax.swing.tree.TreeNodeTree<pre>package javax.swing.tree;
interface TreeNode{
  Enumeration children();
  int getChildCount(); 
  TreeNode getParent(); 
  boolean isLeaf(); 
  TreeNode getChildAt(int childIndex); 

  boolean getAllowsChildren(); 
  int getIndex(TreeNode node);
}</pre>TreeTreeJTree<pre>public class Tree&lt;a&gt;implements TreeNode{</pre>childrentheChildrenjava.utilEnumerationIterator<pre>  public Enumeration&lt;TreeNode&gt; children() {
    final Iterator&lt;Tree&lt;a&gt;&gt; it = theChildren().iterator();

    return new Enumeration&lt;TreeNode&gt;(){
      public boolean hasMoreElements(){return it.hasNext();} 
      public Tree&lt;a&gt; nextElement() {return it.next();}
    };
  }</pre>getChildCountgetParentisLeafgetChildAt<pre>  public TreeNode getChildAt(int childIndex) {
    return theChildren().get(childIndex);
  }

  public int getChildCount(){return theChildren().size();}

  public TreeNode getParent(){return parent;}</pre>TreeNode<pre>  public boolean getAllowsChildren(){
    throw new UnsupportedOperationException();
  } 

  public int getIndex(TreeNode node) {
    throw new UnsupportedOperationException();
  }</pre>toStringString<pre>  public String toString(){return mark().toString();}}</pre>TreeJTree
Wir k&ouml;nnen jetzt ein beliebiges Objekt der 
Klasse Tree der 
Klasse JTree &uuml;bergeben, um es graphisch darzustellen.
Der Code hierzu ist denkbar einfach. <pre>package name.panitz.data.tree.example;

import javax.swing.JFrame;
import javax.swing.JTree;

public class JTreeTest {
  public static void main(String [] args){
    JFrame frame = new JFrame("Baumtest Fenster");
    frame.getContentPane()
         .add(new JTree(SkriptTree.getSkript()));

    frame.pack();
    frame.setVisible(true);
  }
}</pre>
Diese Methode erzeugt die graphische Baumdarstellung aus 
Abbildung.

Dieser Baum reagiert dabei sogar auf Mausaktionen, in dem durch
  Klicken auf Baumknoten deren Kinder ein- und ausgeblendet werden
  k&ouml;nnen.  JTree<h3>12.5.2. B&auml;ume zeichnen</h3>
<pre>package name.panitz.data.tree;

import java.util.Enumeration;

import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.tree.TreeNode;

import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Dimension;

public class DisplayTree extends JPanel{</pre>JTree<pre>  private TreeNode treeModell;</pre>
<pre>  static final public int VERTICAL_SPACE = 50;  
  static final public int HORIZONTAL_SPACE = 20;</pre>
<pre>    private FontMetrics fontMetrics = null;</pre>
<pre>  private int height=0;
  private int width=0;</pre>
<pre>  private boolean dimensionCalculated = false;</pre>
<pre>  public DisplayTree(TreeNode tree){treeModell=tree;}

  public DisplayTree(TreeNode t,FontMetrics fm){
    treeModell=t;fontMetrics=fm;
  }</pre>
<pre>  private void calculateDimension(){</pre>
<pre>
    if (fontMetrics==null){
      final Font font = getFont();
      fontMetrics = getFontMetrics(font);
    }</pre>
<pre>    final int x
      = fontMetrics.stringWidth(treeModell.toString());</pre>
<pre>    final Dimension childrenDim = childrenSize();
    final int childrenX = (int)childrenDim.getWidth();
    final int childrenY = (int)childrenDim.getHeight();</pre>
<pre>    width=x&gt;childrenX?x:childrenX;

    height
      =  childrenY == 0
        ?fontMetrics.getHeight()
        :VERTICAL_SPACE+childrenY;

    dimensionCalculated = true;
  }</pre>
<pre>  Dimension childrenSize(){
    int x = 0;
    int y = 0;

    final Enumeration&lt;TreeNode&gt; it=treeModell.children();
    while (it.hasMoreElements()){
      final DisplayTree t
       = new DisplayTree(it.nextElement(),fontMetrics);

      y =  y &gt; t.getHeight()?y:t.getHeight();

      x=x+t.getWidth();

      if (it.hasMoreElements())  x=x+HORIZONTAL_SPACE;
    }
    return new Dimension(x,y);
  }</pre>
<pre>  public int getHeight(){
    if (!dimensionCalculated) calculateDimension();
    return height;
  }

  public int getWidth(){
    if (!dimensionCalculated) calculateDimension();
    return width;
  }

  public Dimension getSize(){
    if (!dimensionCalculated) calculateDimension();
    return new Dimension(width,height);
  }

  public Dimension getMinimumSize(){
    return getSize();
  }

  public Dimension getPreferredSize(){
    return getSize();
  }</pre>
<pre>  public void paintComponent(Graphics g){paintAt(g,0,0);}

  public void paintAt(Graphics g,int x,int y){
    fontMetrics = g.getFontMetrics();
    final String marks =treeModell.toString();</pre>
<pre>    g.drawString
     (marks
     ,x+(getWidth()/2-fontMetrics.stringWidth(marks)/2)
     ,y+10);</pre>
<pre>    final int startLineX = x+getWidth()/2;
    final int startLineY = y+10;</pre>
<pre>    final Enumeration it=treeModell.children();

    final int childrenWidth = (int)childrenSize().getWidth();

    //wieviel nach rechts zu r&uuml;cken ist
    int newX
      = getWidth()&gt;childrenWidth?(getWidth()-childrenWidth)/2:0;

    //die y-Koordinate der Kinder
    final int nextY = y+VERTICAL_SPACE;

    while (it.hasMoreElements()){
      DisplayTree t
       = new DisplayTree((TreeNode)it.nextElement());

      //x-Positionen f&uuml;r das n&auml;chste Kind
      final int nextX = x+newX;
 
      //zeichne das Kind
      t.paintAt(g,nextX,nextY);

      //zeichne Kante
      g.drawLine(startLineX,startLineY
                ,nextX+t.getWidth()/2,nextY);

      newX = newX+t.getWidth()+HORIZONTAL_SPACE;
    }
  }
}</pre>DisplayTreeJTree<pre>package name.panitz.data.tree.example;
import name.panitz.data.tree.DisplayTree;
import javax.swing.JFrame;
import javax.swing.JScrollPane;

class DisplayTreeTest {
  public static void main(String [] args){
    JFrame frame = new JFrame("Baum Fenster");
    frame.getContentPane()
         .add(new JScrollPane(
                new DisplayTree(SkriptTree.getSkript())));

    frame.pack();
    frame.setVisible(true);
  }
}</pre>
<pre>package name.panitz.data.tree;
import name.panitz.gui.graphicsFile.ComponentToFile;
import static name.panitz.gui.graphicsFile.ComponentToFile.*;

import java.io.File;
import java.io.IOException;

import javax.imageio.ImageIO; 
import javax.swing.JComponent;
import java.awt.image.RenderedImage;

public class TreeToFile{
  public static void treeToFile(Tree tree,String fileName){
    try {
     final JComponent component = new DisplayTree(tree);
     final RenderedImage image = createComponentImage(component);
     ImageIO.write(image,"png", new File(fileName+".png"));
     ImageIO.write(image,"jpg", new File(fileName+".jpg"));
    }catch (IOException e) {System.out.println(e);}
  }
}</pre>
<h2>12.6. Weitere Komponente und Ereignisse</h2>ActionListener<h3>12.6.1. Mausereignisse</h3>
          Mausereignisse, die sich auf das Dr&uuml;cken, Freilassen oder Klicken auf
einen der Mauskn&ouml;pfe bezieht. Hierf&uuml;r gibt es eine Schnittstelle zur
Behandlung solcher Ereignisse: MouseListener.
          Mausereignisse, die sich auf das Bewegen der Maus beziehen. Die
Behandlung solcher Ereignisse kann &uuml;ber eine Implementierung der 
Schnittstelle MouseMotionListener spezifiziert werden.
        addMouseListeneraddMouseMotionListenerjava.awt.eventAdapterMouseListenerMouseAdapterMouseListener
Wir erweitern die Klasse Apfelmaennchen um eine Mausbehandlung.
Der mit gedr&uuml;ckter Maus markierte Bereich soll vergr&ouml;&szlig;ert in dem Fenster
dargestellt werden.<pre>package name.panitz.crempel.tool.apfel;

import java.awt.Graphics;
import java.awt.event.*;
import javax.swing.JFrame;

public class ApfelWithMouse extends Apfelmaennchen{
  public ApfelWithMouse(){</pre>

Im Konstruktor f&uuml;gen wir der Komponente eine Mausbehandlung hinzu. Der
Mausbehandler merkt sich die Koordinaten, an denen die Maus gedr&uuml;ckt wird
und berechnet beim Loslassen des Mausknopfes den neuen darzustellenden Zahlenbereich:<pre>    addMouseListener(new MouseAdapter(){
      int mouseStartX=0;
      int mouseStartY=0;

      public void mousePressed(MouseEvent e) {
        mouseStartX=e.getX();
        mouseStartY=e.getY();
      }
	
      public void mouseReleased(MouseEvent e) {
        int endX = e.getX();
        int endY = e.getY();
        startX = startX+(mouseStartX*zelle);
        startY = startY+(mouseStartY*zelle);
        zelle  = zelle*(endX-mouseStartX)/width;
        repaint();
      }
    });
  }</pre>
Auch f&uuml;r diese Klasse sehen wir eine kleine Startmethode vor:<pre>  public static void main(String [] _){
    JFrame f = new JFrame();
    f.getContentPane().add(new ApfelWithMouse());
    f.pack();
    f.setVisible(true);
  }
}</pre>
<h3>12.6.2. Fensterereignisse</h3>WindowListenerWindowAdapteraddWindowListener
In den bisher vorgestellten Programmen wird Java nicht beendet, wenn das
einzige Fenster der Anwendung geschlossen wurde. Man kann an der Konsole
sehen, da&szlig; der Javainterpreter weiterhin aktiv ist. Das liegt daran, da&szlig; wir
bisher noch nicht spezifiziert haben, wie die Fensterkomponenten auf das
Ereignis des Schlie&szlig;ens des Fensters reagieren sollen. Dieses kann mit einem
Objekt, das WindowListener implementiert in der 
Methode  windowClosing spezifiziert werden. Wir schreiben hier eine
Version des Apfelm&auml;nnchenprogramms, in dem das Schlie&szlig;en des Fensters den
Abbruch des gesammten Programms bewirkt.<pre>package name.panitz.crempel.tool.apfel;

import javax.swing.JFrame;
import java.awt.event.*;

public class ClosingApfelFrame {
  public static void main(String [] args){
    JFrame f = new JFrame();
    f.getContentPane().add(new ApfelWithMouse());
    f.addWindowListener(new WindowAdapter(){
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    });
    f.pack();
    f.setVisible(true);
  }
}</pre>
<h3>12.6.3. Weitere Komponenten</h3>
<pre>package name.panitz.gui.example;

import javax.swing.*;
import java.awt.*;
import java.util.*;

public class ComponentOverview  {
  public ComponentOverview(){</pre>
<pre>   JComponent [] cs1 =
    {new JButton("knopf")
    ,new JCheckBox("check mich")
    ,new JRadioButton("dr&uuml;ck mich")
    ,new JMenuItem("ins Menue mit mir")
    ,new JComboBox(combos)
    ,new JList(combos)
    ,new JSlider(0,350,79)
    ,new JSpinner(new SpinnerNumberModel(18,0.0,42.0,2.0))
    ,new JTextField(12)
    ,new JFormattedTextField("hallo")
    ,new JLabel("einfach nur ein Label")
    ,new JProgressBar(0,42)
    };</pre>
<pre>   JComponent [] cs2 =
    {new JColorChooser(Color.RED)
    ,new JFileChooser()
    ,new JTable(13,5)
    ,new JTree()
    };</pre>
<pre>   displayComponents(cs1,3);
   displayComponents(cs2,2);
  }</pre>
<pre>  String [] combos = {"friends","romans","contrymen"};</pre>
<pre>  public void displayComponents(JComponent [] cs,int col){</pre>
<pre>    JFrame f = new JFrame();
    JPanel panel = new JPanel();
    panel.setLayout(
     new GridLayout(cs.length/col+(cs.length%col==0?0:1),col));</pre>Panel<pre>    for (JComponent c:cs){
      JPanel p = new JPanel();
      p.add(c);  
      p.setBorder(BorderFactory
                 .createTitledBorder(c.getClass().getName()));  
      panel.add(p);
    }</pre>
<pre>    f.getContentPane().add(panel);
    f.pack();
    f.setVisible(true);
  }</pre>
<pre>  public static void main(String [] _){
    new  ComponentOverview();
  }
}</pre>
<h2>12.7. Swing und Steuerf&auml;den</h2>The first rule of using threads is this: avoid them when you
can.
        Bestimmte Operationen k&ouml;nnen sehr lange dauern und damit das GUI
blockieren. Das Laden oder Bearbeiten von Multimediadateien kann unter
Umst&auml;nden sehr lange dauern. W&auml;hrend dieser Zeit, werden Fensterinhalte nicht
aktualisiert. 
        F&uuml;r Animationen soll nach bestimmten Zeitintervallen die Graphik eines
GUIs ver&auml;ndert und neu gezeichnet werden. Hierzu ben&ouml;tigt man so etwas wie 
ein sleep der Steuerf&auml;den.
      
Wir k&ouml;nnen uns zun&auml;chst davon &uuml;berzeugen, da&szlig; die einzelnen Komponenten in
einer Swinganwendung nicht in einzelnen Steuerf&auml;den laufen. Hierzu schreiben
wir ein Programm mit zwei Knopfkomponenten, von denen der eine eine 
Ereignisbehandlung hat, die nicht terminiert.<pre>package name.panitz.swing.threadTest;

import javax.swing.JFrame;
import javax.swing.JButton;
import java.awt.event.*;

public class GuiHangs {
  public static void main(String [] _){
    JFrame f1 = new JFrame("f1");
    JFrame f2 = new JFrame("f2");
    JButton b1 = new JButton("b1");
    JButton b2 = new JButton("b2");

    b1.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent _){
        System.out.println("b1 action");
      }
    });

    b2.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent _){
        System.out.println("b2 action");
        while (true){}
      }
    });

    f1.getContentPane().add(b1);
    f2.getContentPane().add(b2);
    f1.pack();
    f2.pack();
    f1.setVisible(true);
    f2.setVisible(true);
  }
}</pre>
Starten wir dieses Programm, so werden zun&auml;chst zwei Fenster mit Kn&ouml;pfen
    ge&ouml;ffnet. Sobald der Knopf b2 das erste Mal gedr&uuml;ckt wird, h&auml;ngt
    die komplette Anwendung. Es k&ouml;nnen keine Aktionen mehr durchgef&uuml;hrt werden
    und die Fenster werden auch nicht mehr neu gezeichnet.Threadthread safepaintComponent<h3>12.7.1. Timer in Swing</h3>TimerTimerTimerActionListenerFolgende Klasse implementiert eine simple Uhr. In 
einem JLabel wird die aktuelle Zeit angegeben. Die Komponente wird
einem Timer &uuml;bergeben, der jede Sekunde eine neues
Ereigniserzeugt. Diese Ereignisse sorgen daf&uuml;r, da&szlig; die Zeit im Label
aktualisiert wird.<pre>package name.panitz.swing.threads;

import javax.swing.*;
import java.util.Date;
import java.awt.event.*;</pre>
Die Klasse Uhr ist nicht nur ein JPanel, in dem 
ein JLabel benutzt wird, Datum und Uhrzeit anzuzeigen, sondern
implementiert gleichfalls auch einen ActionListener.<pre>public class Uhr extends JPanel implements ActionListener{</pre>
Zun&auml;chst sehen wir das Datumsfeld f&uuml;r diese Komponente vor:<pre>  JLabel l = new JLabel(new Date()+"");</pre>
Im Konstruktor erzeugen wir ein Objekt vom Typ Timer. Dieses Objekt
soll alle Sekunde (alle 1000 Millisekunden) ein Ereignis erzeugen. 
Dem Timer wird das gerade im Konstruktor erzeute Objekt vom 
Typ Uhr &uuml;bergeben, das, da es ja 
einen  ActionListener implementiert, auf diese Ereignisse reagieren
soll. <pre>  public Uhr (){
    new Timer(1000,this).start();
    add(l);	
  }</pre>
Um die Schnittstelle ActionListener korrekt zu implementieren, mu&szlig;
die Methode actionPerformed implementiert werden. In dieser setzen
wir jeweils Datum und Uhrzeit mit dem aktuellen Wert neu ins Label.<pre>  public void actionPerformed(ActionEvent _){
    l.setText(""+new Date());
  }</pre>
Und nat&uuml;rlich sehen wir zum Testen eine kleine Hauptmethode vor, die die Uhr
in einem Fensterrahmen anzeigt.<pre>  public static void main(String [] _){
    JFrame f = new JFrame();
    f.getContentPane().add(new Uhr());
    f.pack();
    f.setVisible(true);
  }
}</pre>
Das so erzeugte Fenster mit einer laufenden Uhr findet sich in 
Abbildung dargestellt.Implementieren Sie eine Analoguhr. Das Ziffernblatt dieser Uhr k&ouml;nnen
Sie dabei mit den Methoden auf einem Graphics-Objekt zeichnen, oder
Sie k&ouml;nnen versuchen eine Bilddatei zu laden und das Ziffernblatt als Bild
bereitstellen. Als Anregung f&uuml;r ein  Ziffernblatt k&ouml;nnen Sie sich das Bild
des 
Ziffernblatts der handgefertigten Sekundenuhr des Uhrmachers 
G.Wiebking herunterladen.<h4>12.7.1.1. Animationen mit Timern</h4>
<pre>package name.panitz.animation;

public interface Animation {
  public void move();
}</pre>JPanelJPanelmove<pre>package name.panitz.animation;

import javax.swing.JPanel;
import javax.swing.Timer;
import java.awt.event.*;

public abstract class AnimatedJPanel 
  extends JPanel implements Animation {</pre>Timer<pre>  Timer t;</pre>move<pre>  public AnimatedJPanel(){
    super(true);
    t = new Timer(29,new ActionListener(){
      public void actionPerformed(ActionEvent _){
        move();
        repaint();
      }
    });
    t.start();
  }
}</pre>movepaintComponent<pre>package name.panitz.animation;

import java.awt.Graphics;
import java.awt.Dimension;
import java.awt.Color;
import javax.swing.JFrame;

public class BouncingBall extends AnimatedJPanel {</pre>
<pre>  final int width = 100;
  final int height = 200;
  final int ballSize = 20;</pre>
<pre>  int yDir = 4;</pre>
<pre>  int ballX = width/2-ballSize/2;
  int ballY = 0;</pre>
<pre>  public void move(){
    if (ballY&gt;height-ballSize || ballY&lt;0) yDir=-yDir;
    ballY=ballY+yDir;
  }</pre>
<pre>  public void paintComponent(Graphics g){
    g.setColor(Color.RED);
    g.fillRect(0,0,width,height);
    g.setColor(Color.YELLOW);
    g.fillOval(ballX,ballY,ballSize,ballSize); 
  }</pre>
<pre>  public Dimension getPreferredSize(){
    return new Dimension(width,height);
  }</pre>
<pre>  public static void main(String [] _){
    JFrame f = new JFrame("");
    f.getContentPane().add(new BouncingBall());
    f.pack();
    f.setVisible(true);
  }
}</pre>Schreiben Sie eine Animation, in der zwei Kreise sich bewegen. Die
Kreise sollen an den R&auml;ndern der Spielfl&auml;che abprallen und sie sollen
ihre Richtung &auml;ndern, wenn sie sich ber&uuml;hren.Schreiben Sie eine Animation, deren Verhalten &uuml;ber Mausklicks
beeinflussen k&ouml;nnen.<h3>12.7.2. Eine kleine Spielbibliothek</h3>Timer<pre>package name.panitz.games;
//import java.awt.Graphics;

public interface AMovable{
  public void move();
  public boolean touches(int x, int y);
  public void reverseXDirection();
  public void reverseYDirection();  
  public void reverseDirection();

  public boolean leftOf(int x);    
  public boolean rightOf(int x);   
  public boolean above(int     y); 
  public boolean underneath(int y);

  public int getX();
  public void setX(int x);
  public int getY();
  public void setY(int y);
  public int getMoveX();
  public void setMoveX(int x);
  public int getMoveY();
  public void setMoveY(int y);
  public int getHeight();
}</pre>
<pre>package name.panitz.games;
import java.awt.Graphics;

public interface Movable extends AMovable{
  public void paintMeTo(Graphics g);
}</pre>
<pre>package name.panitz.games;

public class ASimpleMovable implements AMovable{
  protected int x=2;
  protected int y=2;
  protected int moveX=1;
  protected int moveY=1;
  protected int width=10;
  protected int height=10;

  public void move(){
    setX(getX()+getMoveX());
    setY(getY()+getMoveY());
  }

  public void reverseYDirection(){  
    moveY=-1*moveY;
  }

  public void reverseXDirection(){  
    moveX=-1*moveX;
  }

  public void reverseDirection(){
      reverseXDirection();
      reverseYDirection();
  }

  public boolean touches(int x, int y){
    return  x&gt;=getX()&amp;&amp;x&lt;=getX()+width
         &amp;&amp; y&gt;=getY()&amp;&amp;y&lt;=getY()+height;
  }

  public boolean leftOf(int x)    {return x&gt;=getX();}
  public boolean rightOf(int x)   {return x&lt;=getX()+width;}
  public boolean above(int     y) {return getY()&lt;=y;}
  public boolean underneath(int y){return getY()+height&gt;=y;}

  public int getX(){return x;}
  public void setX(int x){this.x=x;}
  public int getY(){return y;}
  public void setY(int y){this.y=y;}
  public int getMoveX(){return moveX;}
  public void setMoveX(int x){moveX=x;}
  public int getMoveY(){return moveY;}
  public void setMoveY(int y){moveY=y;}
  public int getHeight(){return height;}
}</pre>
<pre>package name.panitz.games;
import java.awt.Graphics;
import java.awt.Color;

public class SimpleMovable extends ASimpleMovable implements Movable{
  public void paintMeTo(Graphics g){
    g.setColor(Color.YELLOW);
    g.fillRect(x,y,width,height); 
  }
}</pre>
<pre>package name.panitz.games;

import name.panitz.animation.AnimatedJPanel;
import java.awt.Graphics;
import java.awt.Dimension;
import java.awt.Color;
import javax.swing.JFrame;

import java.util.List;
import java.util.ArrayList;
import java.awt.event.*;

public class SimpleAnimation extends  AnimatedJPanel{
  final int width = 400;
  final int height = 300;
  final List&lt;Movable&gt; mvs = new ArrayList&lt;Movable&gt;();
    
  public SimpleAnimation(){
    addMouseListener(new MouseAdapter(){
      public void mouseClicked(MouseEvent me){
        mvs.add(new SimpleMovable());
      } 
    });
  }

  public void move(){
    for (Movable mv:mvs) mv.move();
  }  

  public void paintComponent(Graphics g){
    g.setColor(Color.RED);
    g.fillRect(0,0,width,height);
    for (Movable mv:mvs) mv.paintMeTo(g);
  }

  public Dimension getPreferredSize(){
    return new Dimension(width,height);
  }

  public static void main(String [] _){
    JFrame f = new JFrame("");
    f.getContentPane().add(new SimpleAnimation());
    f.pack();
    f.setVisible(true);
  }
}</pre>
<h4>12.7.2.1. Das Telespiel Pong</h4>
<pre>package name.panitz.games;
import java.awt.Graphics;
import java.awt.Color;

public class Ball extends SimpleMovable{
    public Ball(){}
    public Ball(int x,int y){this.x=x;this.y=y;moveX=3;}

  public void paintMeTo(Graphics g){
    g.setColor(Color.YELLOW);
    g.fillOval(x,y,width,height); 
  }
}</pre>
<pre>package name.panitz.games;
import java.awt.Graphics;
import java.awt.Color;

public class Paddle extends SimpleMovable{
  public Paddle(int xPos){
    x=xPos;
    width=10;
    height=30;
    moveX=0;
    moveY=2;
  }
}</pre>
<pre>package name.panitz.games;

import name.panitz.animation.AnimatedJPanel;
import java.awt.Graphics;
import java.awt.event.*;
import java.awt.Dimension;
import java.awt.Color;
import javax.swing.JFrame;

import java.util.List;
import java.util.ArrayList;

public class Pong extends AnimatedJPanel{
  enum Player{left,right};
  Player nextPlayer=Player.left;

  final char leftPlayerKey = 'a';
  final char rightPlayerKey = 'l';
  final char newBallKey = ' ';
  final List&lt;Movable&gt; mvs = new ArrayList&lt;Movable&gt;();
  final Movable leftPaddle = getPaddle(10); 
  final Movable rightPaddle = getPaddle(getWidth()-20); 
  final Movable[] paddles = {leftPaddle,rightPaddle};

  Movable ball = null;

  int leftPoints=0;
  int rightPoints=0;

  Movable getPaddle(int x){return new Paddle(x);}
  Movable getBall(int x,int y){return new Ball(x,y);}

  public Pong(){
    mvs.add(leftPaddle);
    mvs.add(rightPaddle);

    setFocusable(true);
    addKeyListener(new KeyAdapter(){
      public void keyPressed(KeyEvent e){
	if (e.getKeyChar() == leftPlayerKey){
          leftPaddle.setMoveY(Math.abs(leftPaddle.getMoveY()));
        }
        if (e.getKeyChar() == rightPlayerKey){
          rightPaddle.setMoveY(Math.abs(rightPaddle.getMoveY()));
        }
      }
      public void keyReleased(KeyEvent e){ 
        if (e.getKeyChar() == leftPlayerKey){
          leftPaddle.setMoveY(-Math.abs(leftPaddle.getMoveY()));
        } 
        if (e.getKeyChar() == rightPlayerKey){
          rightPaddle.setMoveY(-Math.abs(rightPaddle.getMoveY()));
        }
      }
      public void keyTyped(KeyEvent e){
        if (ball==null &amp;&amp; e.getKeyChar() == newBallKey){
          switch (nextPlayer){
            case right: 
      	      ball=getBall(getWidth()-32,rightPaddle.getY()+10);
              ball.setMoveX(-ball.getMoveX());
              break;
            case left: 
              ball=getBall(22,leftPaddle.getY()+10);
              break;
	    }
            mvs.add(ball);
        }
      }
    });
  }

  public void move(){
    rightPaddle.setX(getWidth()-20); 
    if (ball!=null){
      if (ball.above(0) || ball.underneath(getHeight())){
        ball.reverseYDirection();
        ball.move();
      }

      if (ball.leftOf(0) ){
	mvs.remove(ball);
	ball=null;
	rightPoints=rightPoints+1;
	nextPlayer=Player.right;
      }

      else if (ball.rightOf(getWidth()) ){
	mvs.remove(ball);
	ball=null;
	leftPoints=leftPoints+1;
	nextPlayer=Player.left;
      }

      else if (
         (    ball.rightOf(getWidth()-20) 
          &amp;&amp; ball.underneath(rightPaddle.getY())
	  &amp;&amp; ball.above(rightPaddle.getY()+rightPaddle.getHeight())
         )
         ||
         (    ball.leftOf(20) 
          &amp;&amp; ball.underneath(leftPaddle.getY())
	  &amp;&amp; ball.above(leftPaddle.getY()+leftPaddle.getHeight())
         )
        )
	ball.reverseXDirection();
    }

    for (Movable mv:mvs) mv.move();
    for (Movable p:paddles){
      if (p.getY()&lt;0) p.setY(0);
      if (p.getY()+p.getHeight()&gt;getHeight()) 
        p.setY(getHeight()-p.getHeight());
    }
  }  

  public void paintComponent(Graphics g){
    g.setColor(Color.GREEN);
    g.fillRect(0,0,getWidth(),getHeight());
    for (Movable mv:mvs) mv.paintMeTo(g);
    g.setColor(Color.BLACK);
    g.drawString(""+leftPoints,40,40);
    g.drawString(""+rightPoints,getWidth()-80,40);
  }

  public Dimension getPreferredSize(){
    return new Dimension(400,300);
  }

  public static void main(String [] _){
    JFrame f = new JFrame("");
    f.getContentPane().add(new Pong());
    f.pack();
    f.setVisible(true);
  }
}</pre>
            
<pre>import javax.swing.*;
import name.panitz.games.Pong;
public class PongApplet extends JApplet{
  public PongApplet(){add(new Pong());}
}</pre>
            
<pre>&lt;html&gt;&lt;body&gt;
&lt;h1&gt;Das Spiel Pong&lt;/h1&gt;
&lt;b&gt;Tastaturbelegung:&lt;/b&gt;&lt;p /&gt;

'a': linker Schl&auml;ger&lt;br/&gt;
'l': rechter Schl&auml;ger&lt;br/&gt;
' ': neuer Ball&lt;br/&gt;

&lt;applet code="PongApplet.class" 
        codebase="../classes/"
        width="400" height="300"&gt;
Der Browser ignoriert das Applets. Hier w&auml;re jetzt ein Spiel
gewesen.
&lt;/applet&gt;
&lt;/body&gt;&lt;/html&gt;</pre>
          
            
<pre>package name.panitz.games;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.image.ImageObserver;

public class SmileBall extends Ball{
  static final Toolkit toolkit = Toolkit.getDefaultToolkit();
  static Image smile;
  ImageObserver obs;

  public SmileBall(ImageObserver obs){
    this.obs=obs;
    try {
      if (smile==null)
        smile = toolkit.getImage(
                 getClass().getClassLoader()
                  .getResource("../../images/smile.gif"));
    }catch(Exception e){System.out.println(e);}
    width=40;height=30;
    moveX=8;
    moveY=6;
  }

  public SmileBall(ImageObserver obs,int x,int y){
    this(obs);
    this.x=x;this.y=y;
  }

  public void paintMeTo(Graphics g){
    g.drawImage(smile, x, y, obs);
  }
 
  public void loadImages(java.applet.Applet a){
    try {
      smile = a.getImage(a.getCodeBase(),"../../images/smile.gif");
    }catch(Exception _){}
  }
}</pre>
            
<pre>package name.panitz.games;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.image.ImageObserver;

public class ImagePaddle extends Paddle{
  static Image paddle;
  ImageObserver obs;

  public ImagePaddle(  ImageObserver obs,int x){
    super(x);
    this.obs=obs;
    try {
      if (paddle==null)
        paddle = SmileBall.toolkit.getImage(
                 getClass().getClassLoader()
                  .getResource("../../images/schlaeger.gif"));
    }catch(Exception e){System.out.println(e);}
    width=10;height=99;
    moveY=4;
  }

  public void paintMeTo(Graphics g){
    g.drawImage(paddle, x, y, obs);
  }
 
  public void loadImages(java.applet.Applet a){
    try {
      paddle = a.getImage(a.getCodeBase(),"../../images/smile.gif");
    }catch(Exception _){}
  }
}</pre>
            
<pre>package name.panitz.games;
import java.awt.Dimension;
import javax.swing.JFrame;
public class ImagePong extends Pong{
  Movable getPaddle(int x){return new ImagePaddle(this,x);}
  Movable getBall(int x,int y){return new SmileBall(this,x,y);}  
  public Dimension getPreferredSize(){
    return new Dimension(800,600);
  }

  public static void main(String [] _){
    JFrame f = new JFrame("");
    f.getContentPane().add(new ImagePong());
    f.pack();
    f.setVisible(true);
  }
}
</pre>
          
<h3>12.7.3. SwingWorker f&uuml;r Steuerf&auml;den in der Ereignisbehandlung</h3>SwingWorkerSwingWorkerSwingWorkerSwingWorker<pre>public void actionPerformed(ActionEvent e) {
    ...
    //...Code, der sehr lange dauert ...
    ...
}</pre>constructSwingWorker<pre>public void actionPerformed(ActionEvent e) {
    ...
    final SwingWorker worker = new SwingWorker() {
        public Object construct() {
            //...Code, der sehr lange dauert, ist jetzt hier...
            return someValue;
        }
    };
    worker.start();
    ...
}

 </pre>
Jetzt k&ouml;nnen wir unser Eingangsbeispiel mit der SwingWorker-Klasse so
umschreiben, da&szlig; es  nicht mehr zum H&auml;ngen des gesamten Programms  kommt.<pre>package name.panitz.swing.threadTest;

import javax.swing.JFrame;
import javax.swing.JButton;
import java.awt.event.*;

public class GuiHangsNoLonger {
  public static void main(String [] _){
    JFrame f1 = new JFrame("f1");
    JFrame f2 = new JFrame("f2");
    JButton b1 = new JButton("b1");
    JButton b2 = new JButton("b2");

    b1.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent _){
        System.out.println("b1 action");
      }
    });

    b2.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent _){
        final SwingWorker worker = new SwingWorker() {
          public Object construct() {
            System.out.println("b2 action");
            int x = 1; while (true){if (x==0) break;}
            return null;
          }
        };
        worker.start();  
      }
    });

    f1.getContentPane().add(b1);
    f2.getContentPane().add(b2);
    f1.pack();
    f2.pack();
    f1.setVisible(true);
    f2.setVisible(true);
  }
}</pre>



Nach Dr&uuml;cken des Knopfes b2 bleibt das Gui weiterhin voll
funktionsf&auml;hig. Allerdings stellt man fest, indem man sich z.B. 
mit top die laufenden Prozesse in einem Unixsystem anschaut, da&szlig;
jedes Dr&uuml;cken des Knopfes einen neuen Unterprozess von Java erzeugt.<h4>12.7.3.1. SwingWorkerbeispiel</h4>SwingWorkerJLabel<pre>package name.panitz.gui;

import java.io.File;
import java.net.MalformedURLException;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class ImageIcon extends JLabel {
  private int height = 60;
  private int width = 80;
  final Toolkit toolkit = Toolkit.getDefaultToolkit();
  private Image image;

  public ImageIcon(String fileName){this(new File(fileName));}
  public ImageIcon(final File file){
    setImage(file);
  }</pre>
<pre>  public void setImage(File jpgFile){
    try{
      image=toolkit.getImage(jpgFile.toURL());
      final MediaTracker tracker = new MediaTracker(this);
      tracker.addImage(image, 0,width,height);
      try {tracker.waitForAll();}
      catch (Exception e) {e.printStackTrace();}
      fitImage();
      setIcon(new javax.swing.ImageIcon(image));
    }catch (MalformedURLException e){}
  }</pre>
<pre>  private void fitImage(){
    final int w = image.getWidth(this); 
    final int h = image.getHeight(this); 
    
    final int w1 = width;        final int h1 = h*width/w;
    final int w2 = w*height/h;   final int h2 = height;
    final int w3 = w1&lt;w2?w1:w2;  final int h3 = h1&lt;h2?h1:h2;

    image=image.getScaledInstance
                  (w3&lt;w?w3:w,h3&lt;h?h3:h,Image.SCALE_FAST); 
  }
}</pre>
<pre>package name.panitz.gui;

import name.panitz.swing.threads.Uhr;

import java.io.File;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

class UseImageIcon {
  public static void main(String [] args){
    JFrame f= new JFrame();
    final JPanel p = new JPanel();
    f.getContentPane().add(p);
    final int c = 10;
    final int n = args.length;
 
    p.setLayout(new GridLayout(n/c+((n%c)==0?0:1),c));
    for (final String arg:args)p.add(new ImageIcon(arg));

    f.pack();
    f.setVisible(true);

    JFrame f2 = new JFrame();
    f2.getContentPane().add(new Uhr());
    f2.pack();
    f2.setVisible(true);
  }
}</pre>SwingWorkerImageIconActionListenerTimer<pre>package name.panitz.gui;

import name.panitz.swing.threads.Uhr;
import name.panitz.swing.threadTest.SwingWorker;

import java.io.File;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class BetterUseOfImageIcon{
  public static void main(String [] args){
    final JFrame f= new JFrame();
    final JPanel p = new JPanel();
    f.getContentPane().add(p);
    final int c = 10;
    final int n = args.length;

    p.setLayout(new GridLayout(n/c+((n%c)==0?0:1),c));
    for (final String arg:args){
      ActionListener listen = new ActionListener(){ 
        public void actionPerformed(ActionEvent e) {
         final SwingWorker worker = new SwingWorker() {
           public Object construct() {
              p.add(new ImageIcon(arg)); f.pack();
              f.repaint();
              return null;
           }
         };
         worker.start(); 
        }
      };

      Timer t = new Timer(10,listen);
      t.setRepeats(false);

      t.start();
    }
    f.pack();
    f.setVisible(true);

    JFrame f2 = new JFrame();
    f2.getContentPane().add(new Uhr());
    f2.pack();
    f2.setVisible(true);
  }
}</pre>
<h1>13. 3 dimensionale Graphiken</h1>
<h1>14. Formale Sprachen, Grammatiken, Parser</h1>ProgrammiersprachenGrammatikCompilerbau<h2>14.1. formale Sprachen</h2>Chomsky gilt
als der am h&auml;ufigsten zitierte Wissenschaftler 
des 20.Jahrhunderts. Heutzutage tritt Chomsky weniger durch
seine wissenschaftlichen Arbeiten als vielmehr durch seinen Einsatz
f&uuml;r Menschenrechte und bedrohte V&ouml;lker in Erscheinung.<h3>14.1.1. kontextfreie Grammatik</h3>
          einer Menge T von W&ouml;rteren,
 den Terminalsymbole.
          einer Menge N von Nichtterminalsymbolen.
          ein ausgezeichnetes Startsymbol $S\in$N.
          einer endlichen Menge R von Regeln der Form:nt::= $t_1 t_n$, 
wobei nt$\in$N, $t_i\in$N$\cup$T. 
        Wir geben eine Grammatik an, die einfache S&auml;tze &uuml;ber unser
Sonnensystem auf Englisch
bilden kann:
            T$=\{$mars,mercury,deimos,phoebus,orbits,is,a,moon,planet$\}$
            N$=\{$start,noun-phrase,verb-phrase,noun,verb,article$\}$
            $S=$start
            start ::= noun-phrase verb-phrasenoun-phrase ::= nounnoun-phrase ::= article nounverb-phrase ::= verb noun-phrasenoun ::= planetnoun ::= moonnoun ::= marsnoun ::= deimosnoun ::= phoebusverb ::= orbitsverb ::= isarticle ::= a
          
Wir k&ouml;nnen mit dieser Grammatik S&auml;tze in der folgenden Art bilden:
            startnoun-phrase verb-phrasearticle noun verb-phrasearticle noun verb noun-phrase a noun verb noun-phrase a moon verb noun-phrase a moon orbits noun-phrase a moon orbits noun a moon orbits mars
            startnoun-phrase verb-phrasenoun verb-phrase mercury verb-phrase mercury verb noun-phrase mercury is noun-phrase mercury is article noun mercury is a noun mercury is a planet
            Mit dieser einfachen Grammatik lassen sich auch S&auml;tze bilden,
die weder korrektes Englisch sind, noch eine vern&uuml;nftige inhaltliche
Aussage machen:start noun-phrase verb-phrasenoun verb-phrase planet verb-phrase planet verb noun-phrase planet orbits noun-phrase planet orbits article noun planet orbits a  noun planet orbits a phoebus
          <h4>14.1.1.1. Rekursive Grammatiken</h4>Die folgende Grammatik erlaubt es arithmetische Ausdr&uuml;cke zu
generieren: 
              T$=\{0,1,2,3,4,5,6,7,8,9,+,-,*,/\}$
              N$=\{$start,expr,op,integer,digit,$\}$
              $S=$start
              start ::= exprexpr ::= integerexpr ::= integer op exprinteger ::= digitinteger ::= digit integerop ::= +op ::= -op ::= *op ::= /digit ::= 0digit ::= 1digit ::= 2digit ::= 3digit ::= 4digit ::= 5digit ::= 6digit ::= 7digit ::= 8digit ::= 9
            
Diese Grammatik hat zwei rekursive Regeln: eine f&uuml;r das 
Nichtterminal expr und eines f&uuml;r das 
Nichtterminal integer. 

Folgende Abeleitung generiert einen arithmetischen Ausdrucke mit dieser
Grammatik:
              startexprinteger op exprinteger op integer op exprinteger op integer op integer op exprinteger op integer op integer op integerinteger + integer op integer op integerinteger + integer $*$ integer op integerinteger + integer $*$ integer $-$integerdigit integer + integer $*$ integer $-$ integer $1$ integer + integer $*$ integer
$-$ integer $1$ digit integer + integer $*$integer $-$ integer $12$ integer + integer $*$integer $-$ integer $12$ digit + integer $*$ integer
$-$ integer $129+$ integer $*$ integer $-$integer $129+$ digit $*$ integer $-$integer $129+4*$ integer $-$ integer $129+4*$ digit integer $-$ integer $129+4*5$integer $-$ integer $129+4*5$digit $-$ integer $129+4*53-$ integer $129+4*53-$ digit integer $129+4*53-8$ integer $129+4*53-8$ digit $129+4*53-87$
            Erweitern Sie die obige Grammatik so, da&szlig; sie mit ihr auch
geklammerte arithmetische Ausdr&uuml;cke ableiten k&ouml;nnen. Hierf&uuml;r gibt es
zwei neue Terminalsymbolde: ( und ). 
Schreiben Sie
eine Ableitung f&uuml;r den Ausdruck: 1+(2*20)+1<h4>14.1.1.2. Grenzen kontextfreier Grammatiken</h4>
Es gibt syntaktisch recht einfache Sprachen, die sich nicht durch eine
kontextfreie Grammatik beschreiben lassen. Eine sehr einfache solche
Sprache besteht aus drei W&ouml;rtern: T$=\{$a,b,c$\}$. Die
S&auml;tze dieser Sprache sollen so gebildet sein, da&szlig; f&uuml;r eine Zahl $n$
eine Folge von $n$ mal dem Zeichen a, $n$ mal das Zeichen b und
schlie&szlig;lich $n$ mal das Zeichen c folgt, 
also $\{a^nb^nc^n|n\in I\!\!N\}$. 

Die S&auml;tze dieser Sprache lassen sich aufz&auml;hlen:
abc 
aabbcc 
aaabbbccc 
aaaabbbbcccc 
aaaaabbbbbccccc 
aaaaaabbbbbbcccccc
Es gibt formale Beweise, da&szlig; derartige Sprachen sich nicht mit
kontextfreie Grammatiken bilden lassen. Versuchen Sie einmal das
Unm&ouml;gliche: eine Grammatik aufzustellen, die diese Sprache erzeugt.
Eine weitere einfache Sprache, die nicht durch eine kontextfreie auszudr&uuml;cken
ist, hat zwei Terminalsymbole und verlangt, da&szlig; in jedem Satz die
beiden Symbole gleich oft vorkommen, die Reihenfolge jedoch beliebig
sein kann.
&Uuml;ber die Syntax hinaus, haben Sprachen noch weitere Einschr&auml;nkungen,
die sich nicht in der Grammatik ausdr&uuml;cken lassen. Die meisten
syntaktisch korrekten Javaprogramme werden trotzdem vom Java&uuml;bersetzer
als inkorrekt zur&uuml;ckgewiesen. Diese Programme versto&szlig;en gegen
semantische Beschr&auml;nkungen, wie z.B.gegen die
Zuweisungskompatibilit&auml;t. Das Programm:<pre>class SemanticalIncorrect{int i = "1";}</pre>
ist syntaktisch nach den Regeln der Javagrammatik korrekt gebildet,
verletzt aber die Beschr&auml;nkung, da&szlig; einem Feld vom 
Typ int kein Objekt des Typs String zugewiesen
werden darf.

Aus diesen Grund besteht ein &Uuml;bersetzer aus zwei gro&szlig;en Teilen. Der
syntaktischen Analyse, die pr&uuml;ft, ob der Satz mit den Regeln der
Grammatik erzeugt werden kann und der semantischen Analyse, die
anschlie&szlig;end zus&auml;tzliche semantische Bedingungen pr&uuml;ft.<h4>14.1.1.3. Das leere Wort</h4>$t$::=$t$::=$\epsilon$<h4>14.1.1.4. Lexikalische Struktur</h4>LexerTokenizer<h4>14.1.1.5. Andere Grammatiken</h4>kontextfreiWir k&ouml;nnen mit der folgenden nicht-kontextfreien Grammatik
die Sprache beschreiben, in der jeder Satz gleich oft die beiden
Terminalsymbole, eber in beliebiger Reihenfolge enth&auml;lt.
              T$=\{$a,b$\}$
              N$=\{$start,A,B$\}$
              $S=$start
              start ::= ABstartstart ::= $\epsilon$AB ::= BABA ::= ABA ::= aB ::= b
            startABstartABABstartABABABstartABABABABstartABABABABABstartABABABABABAABBABABABAABBBAABABAABBBABAABAABBBABABAAABBBABBAAAABBBBABAAAABBBBBAAA aABBBBBAAA aaBBBBBAAA aabBBBBAAA aabbBBBAAA aabbbBBAAA aabbbbBAAA aabbbbbAAA aabbbbbaAA aabbbbbaaA aabbbbbaaa
Auch die nicht durch eine kontextfreie Grammatik darstellbare Sprache:$\{a^nb^nc^n|n\in I\!\!N\}$. 
l&auml;&szlig;t sich mit einer solchen Grammatik generieren:S::=abTcT::=AbTc$\epsilon$
bA::=Ab
aA::=aa
Eine Ableitung mit dieser Grammatik sieht wie folgt aus:S abTc abAbTcc abAbAbTccc abAbAbAbTcccc abAbAbAbAbTccccc abAbAbAbAbccccc abAAbbAbAbccccc abAAbAbbAbccccc abAAAbbbAbccccc abAAAbbAbbccccc abAAAbAbbbccccc abAAAAbbbbccccc aAbAAAbbbbccccc aAAbAAbbbbccccc aAAAbAbbbbccccc aAAAAbbbbbccccc aaAAAbbbbbccccc aaaAAbbbbbccccc aaaaAbbbbbccccc aaaaabbbbbccccc<h4>14.1.1.6. Grammatiken und B&auml;ume</h4>Die Ableitungen der S&auml;tze unserer ersten Grammatik haben
folgende Baumdarstellung:Betrachten Sie die einfache Grammatik f&uuml;r arithmetische
Ausdr&uuml;cke aus dem letzen Abschnitt. Zeichnen Sie einen Syntaxbaum f&uuml;r den 
Audruck 1+1+2*20.<h3>14.1.2. Erweiterte Backus-Naur-Form</h3>
<h4>14.1.2.1. Alternativen</h4>
Die Regeln unserer ersten Grammatik k&ouml;nnen damit wie folgt geschrieben
werden:start ::= noun-phrase verb-phrasenoun-phrase ::= nounarticle nounverb-phrase ::= verb noun-phrasenoun ::= planetmoonmarsdeimosphoebusverb ::= orbitsisarticle ::= a<h4>14.1.2.2. Gruppierung</h4>
Die einfache Grammatik f&uuml;r arithmetische Ausdr&uuml;cke l&auml;&szlig;t sich damit
ohne das Nichtterminalzeichen op schreiben:start ::= exprexpr ::= integerinteger
$(+$$-$$*$$/)$  exprinteger ::= digitdigit integerdigit ::=
0123456789<h4>14.1.2.3. Wiederholungen</h4>Eine Zahl besteht aus einer Folge von $n$ Ziffern
($n&gt;0$). Dieses l&auml;&szlig;t sich durch folgende Regel ausdr&uuml;cken:Zahl ::= Ziffer ZahlZiffer
Im obigen Beispiel handelt es sich um eine 1 bis $n$-fache
Wiederholung des Zeichens Ziffer. Hierzu gibt es eine
abk&uuml;rzende Schreibweise. Dem zu wiederholenden Teil wird das 
Zeichen + nachgestellt.
Obige Regel f&uuml;r das Nichtterminal Zahl l&auml;&szlig;t sich mit dieser
abk&uuml;rzenden Schreibweise schreiben als:Zahl ::= Ziffer+
Soll ein Teil in einer Wiederholung auch keinmal vorkommen, so wird
statt des Zeichens + das Zeichen * genommen.
Folgende Regel dr&uuml;ckt aus, da&szlig; ein Ausdruck eine durch Operatoren
getrennte Liste von Zahlen ist.expr ::= Zahl (OpZahl)* 
Ein weiterer Spezialfall der Wiederholung ist die, in der der
entsprechende Teil keinmal oder einmal vorkommen darf, d.h.~der Teil
ist optional. Optionale Teile werden in der erweiterten Form in eckige
Klammern gesetzt.<h2>14.2. Parser</h2>ParserLateinisch Pars
bedeutet Teil.<h3>14.2.1. Parsstrategien</h3>
<h4>14.2.1.1. Rekursiv absteigend</h4>backtracking
Wir suchen mit dieser Strategie die Ableitung des 
Satzes a moon orbits mars in dem
Sonnensystembeispiel. Sackgassen sind durch einen Punkt $\bullet$
markiert. 
              
                (0)
                
                
                  start
                
              
              
                (1) aus 0
                
                  
                
                
                  noun-phrase verb-phrase
                
              
              
                (2a) aus 1
                
                  
                
                
                  noun verb-phrase
                
              
              
              
                (2a3a) aus 2a
                
                  
                
                planet  verb-phrase
                $\bullet$
              
              
                (2a3b) aus 2a
                
                  
                
                moon  verb-phrase
                $\bullet$
              
              
                (2a3c) aus 2a
                
                  
                
                mars  verb-phrase
                $\bullet$
              
              
                (2a3d) aus 2a
                
                  
                
                deimos  verb-phrase
                $\bullet$
              
              
                (2a3e) aus 2a
                
                  
                
                phobus  verb-phrase
                $\bullet$
              
              
              
                (2b)  aus 1
                
                  
                
                
                  article noun verb-phrase
                
              
              
                (3) aus 2b
                
                  
                
                a  noun verb-phrase
              
              
              
                (4a) aus 3
                
                  
                
                a planet  verb-phrase
                $\bullet$
              
              
                (4b) aus 3
                
                  
                
                a moon  verb-phrase
              
              
              
                (5) aus 4b
                
                  
                
                a moon  verb noun-phrase
              
              
              
                (6) aus 5
                
                  
                
                a moon orbits  noun-phrase
              
              
              
                (7) aus 6
                
                  
                
                a moon orbits  noun
              
              
              
                (8a) aus 7
                
                  
                
                a moon orbits planet
                $\bullet$
              
              
                (8b) aus 7
                
                  
                
                a moon orbits moon
                $\bullet$ 
              
              
                (8c) aus 7
                
                  
                
                a moon orbits mars
              
            
Die Strategie des rekursiven Abstiegs auf der linken Seite
funktioniert f&uuml;r eine bestimmte Art von Regeln nicht. Dieses sind
Regeln, die in einer Alternative als erstes Symbol wieder das
Nichtterminalsymbol stehen haben, das auch auf der linken Seite
steht. Solche Regeln hei&szlig;en linksrekursiv. Unsere Strategie terminiert
in diesen Fall nicht.
Gegeben sei eine Grammatik mit einer linksrekursiven Regel:expr::=expr+zahlzahl
Der Versuch den Satzzahl+zahl
mit einem links rekursiv absteigenden Parser abzuleiten, f&uuml;hrt zu
einem nicht terminierenden rekursiven Abstieg. Wir gelangen nie in
eine Sackgasse:
                
                  
                  
                    expr
                  
                
                
                  
                    
                  
                  expr+zahl
                
                
                  
                    
                  
                  expr+zahl+zahl
                
                
                  
                    
                  
                  expr+zahl+zahl+zahl
                
                
                  
                    
                  
                  expr+zahl+zahl+zahl+zahl
                
                
                  
                  
                    
                  
                
              

Es l&auml;&szlig;t sich also nicht f&uuml;r alle Grammatiken mit dem Verfahren des
rekursiven Abstiegs entscheiden, ob ein Satz mit der Grammatik erzeugt
werden kann; aber es ist m&ouml;glich, eine Grammatik mit linksrekursiven
Regeln so umzuschreiben, da&szlig; sie die gleiche Sprache generiert, jedoch
nicht mehr linksrekursiv ist. Hierzu gibt es ein einfaches Schema:
Eine Regel nach dem Schema:A ::= Arestalt2
ist zu ersetzen durch die zwei Regeln:A::= alt2RR::= restR$\epsilon$
wobei R ein neues Nichtterminalsymbol ist.
Die rekursiv absteigende Strategie hat einen weiteren Nachteil. Wenn
sie streng schematisch angewendet wird, f&uuml;hrt sie dazu, da&szlig; bestimmte
Pr&uuml;fungen mehrfach durchgef&uuml;hrt werden. Diese mehrfache Ausf&uuml;hrung
kann sich bei wiederholter Regelanwendung multipizieren und zu einem
sehr ineffizienten Parser f&uuml;hren. Grund daf&uuml;r sind Regeln, die zwei
Alternativen mit gleichem Anfang haben:S ::= ABA
Beide Alternativen f&uuml;r das Nichtterminalzeichen S starten mit
dem Zeichen A. F&uuml;r unseren Parser bedeutet das soweit:
versuche nach der ersten Alternative zu parsen. Hierzu parse erst nach
dem Symbol A. Das kann eine sehr komplexe Berechnung
sein. Wenn sie gelingt, dann versuche anschlie&szlig;end weiter nach dem
Symbol B zu parsen. Wenn das fehlschl&auml;gt, dann verwerfe die
Regelalternative und versuche nach der zweiten Regelalternative zu
parsen. Jetzt ist wieder nach dem Symbol A zu parsen, was wir
bereits gemacht haben.
Regeln der obigen Art wirken sich auf unsere Parsstrategie ung&uuml;nstig
aus. Wir k&ouml;nnen aber ein Schema angegeben, wie man solche Regeln aus
der Grammatik eleminiert, ohne die erzeugte Sprache zu &auml;ndern:
Regeln der Form
  S ::= ABA
sind zu ersetzen durch
  S ::= ATT ::= B$\epsilon$
  
wobei T ein neues Nichtterminalzeichen ist.
Im letzten Abschnitt haben wir gesehen, wie wir die Grammatik
umschreiben k&ouml;nnen, so da&szlig; nach dem Zur&uuml;cksetzen in unserem
Algorithmus es nicht vorkommt, bereits ausgef&uuml;hrte Regeln ein weiteres
Mal zu durchlaufen. Sch&ouml;ner noch w&auml;re es, wenn wir auf das
Zur&uuml;cksetzen ganz verzichten k&ouml;nnten. Dieses l&auml;&szlig;t sich allgemein nicht
erreichen, aber es gibt Grammatiken, in denen man durch Betrachtung
des n&auml;chsten zu parsenden Zeichens erkennen kann, welche der
Regelalternativen als einzige Alternative in betracht kommt. Hierzu
kann man f&uuml;r eine  Grammatik f&uuml;r jedes Nichtterminalzeichen in jeder
Regelalternative berechnen, welche Terminalzeichen als linkestes
Zeichen in einem mit dieser Regel abgelittenen Satz auftreten
kann. Wenn die Regelalternativen disjunkte solche Menge des ersten
Zeichens haben, so ist eindeutig bei Betrachtung des ersten Zeichens
eines zu parsenden Satzes erkennbar, ob und mit welcher Alternative
dieser Satz nur parsbar sein kann.
Die g&auml;ngigsten Parser benutzen diese Entscheidung, nach dem erstem
Zeichen. Diese Parser sind darauf angewiesen, da&szlig; die Menge der ersten
Zeichen der verschiedenen Regelalternativen disjunkt sind.
Der Vorteil an diesem Verfahren ist, da&szlig; die Token nach und nach von
links nach rechts st&uuml;ckweise konsumiert werden. Sie k&ouml;nnen durch einen
Datenstro, relisiert werden. Wurden sie einmal konsumiert, so werden
sie nicht mehr zum Parsen ben&ouml;tigt, weil es kein Zur&uuml;cksetzen gibt.   <h4>14.2.1.2. Schieben und Reduzieren</h4>
Wir leiten im folgenden unserer allseits bekannten Beispielsatz aus
dem Sonnensystem durch Schieben und Reduzieren ab. Als Marker benutzen
wir einen Punkt.
              
                
                
                . a moon orbits mars
              
              
                (shift)
                
                  
                
                 a . moon orbits mars
              
              
                (reduce)
                
                  
                
                article . moon orbits mars
              
              
                (shift)
                
                  
                
                article moon . orbits mars
              
              
                (reduce)
                
                  
                
                article noun  . orbits mars
              
              
                (reduce)
                
                  
                
                noun-phrase . orbits mars
              
              
                (shift)
                
                  
                
                noun-phrase  orbits . mars
              
              
                (reduce)
                
                  
                
                noun-phrase verb . mars
              
              
                (shift)
                
                  
                
                noun-phrase verb mars .
              
              
                (reduce)
                
                  
                
                noun-phrase verb noun .
              
              
                (reduce)
                
                  
                
                noun-phrase verb noun-phrase .
              
              
                (reduce)
                
                  
                
                noun-phrase verb-phrase .
              
              
                (reduce)
                
                  
                
                start.
              
            <h2>14.3. Handgeschriebene Parser</h2>
<h3>14.3.1. Basisklassen der Parserbibliothek</h3>parseParser<pre>package name.panitz.parser;
import java.util.List;
public interface Parser&lt;a&gt; {
  ParseResult&lt;a&gt; parse(List&lt;Token&gt; ts);
}</pre>aParser&lt;String&gt;Token<pre>package name.panitz.parser;
public interface Token {}</pre>ParseResult&lt;a&gt;Parser&lt;a&gt;aParseResult&lt;a&gt;
          dem eigentlichen Ergebnis vom Typ a.
          der Liste der durch den Parsvorgang nicht konsumierten restlichen Token.
        <pre>package name.panitz.parser;
import java.util.List;
public class ParseResult&lt;a&gt; {
  final private a result;
  final private List&lt;Token&gt; remainingToken;
  public ParseResult(a r,List&lt;Token&gt; toks){
    result=r;remainingToken=toks;
  }
  public a getResult(){return result;}
  public List&lt;Token&gt; getRemainingToken(){return remainingToken;}
  public boolean failed(){return result==null;}
}</pre>getfailed<h4>14.3.1.1. Der Epsilon Parser</h4>true<pre>package name.panitz.parser;
import java.util.List;

public class Epsilon implements Parser&lt;Boolean&gt;{
  public ParseResult&lt;Boolean&gt; parse(List&lt;Token&gt; ts){
     return new ParseResult&lt;Boolean&gt;(true,ts);
  }
}</pre>
<h3>14.3.2. Parser zum Erkennen von Token</h3>Parserparseparse<pre>package name.panitz.parser;
import java.util.List;

public class ParseToken&lt;a extends Token&gt; implements Parser&lt;a&gt;{
  final private a t;
  public ParseToken(a _t){t=_t;}
  public ParseResult&lt;a&gt; parse(List&lt;Token&gt; ts){
    if (ts.isEmpty()) return new ParseResult&lt;a&gt;(null,ts);
    if (ts.get(0).equals(t))
      return new ParseResult&lt;a&gt;((a)ts.get(0),ts.subList(1,ts.size()));
    return new ParseResult&lt;a&gt;(null,ts);
  }
}</pre>
<h3>14.3.3. Parser zum Bilden der Sequenz zweier Parser</h3>
          durch die Sequenz mehrer Symbole auf der rechten Seite einer 
Regel. 
          durch mehrere Regelalternativen.
        A ::= B ~CABCA<pre>package name.panitz.parser;

public class Pair&lt;a,b&gt;{
  final private a e1;
  final private b e2;
  public Pair(a x1,b x2){e1=x1;e2=x2;}
  public a getE1(){return e1;}
  public b getE2(){return e2;}
}</pre>
<pre>package name.panitz.parser;

import java.util.List;

public class Seq&lt;a,b&gt; implements Parser&lt;Pair&lt;a,b&gt;&gt;{
  final private Parser&lt;a&gt; p1;
  final private Parser&lt;b&gt; p2;
  public Seq(Parser&lt; a&gt; _p1,Parser&lt; b&gt; _p2){p1=_p1;p2=_p2;}</pre>parse<pre>  public ParseResult&lt;Pair&lt;a,b&gt;&gt; parse(List&lt;Token&gt; ts){
    ParseResult&lt;a&gt; r1 = p1.parse(ts);</pre>
<pre>    if (r1.failed()) return new ParseResult&lt;Pair&lt;a,b&gt;&gt;(null,ts);</pre>
<pre>    ParseResult&lt;b&gt; r2 = p2.parse(r1.getRemainingToken());</pre>
<pre>    if (r2.failed()) return new ParseResult&lt;Pair&lt;a,b&gt;&gt;(null,ts);</pre>
<pre>    return new ParseResult&lt;Pair&lt;a,b&gt;&gt;
                 (new Pair&lt;a,b&gt;(r1.getResult(),r2.getResult())
                 ,r2.getRemainingToken());
  }
}</pre>
<h3>14.3.4. Parser zum Bilden der Alternative zweier Parser</h3>A ::= BA ::= CABCSeqAlt<pre>package name.panitz.parser;

import java.util.List;
import java.util.ArrayList;

public class Alt&lt;a&gt; implements Parser&lt;a&gt;{
  final private Parser&lt;a&gt; p1;
  final private Parser&lt;a&gt; p2;
  public Alt(Parser&lt;a&gt; _p1,Parser&lt;a&gt; _p2){p1=_p1;p2=_p2;}</pre>
<pre>  public ParseResult&lt;a&gt; parse(List&lt;Token&gt; ts){
    ParseResult&lt;a&gt; r1 = p1.parse(ts);</pre>
<pre>    if (r1.failed()) return p2.parse(ts);
    return r1;
  }
}</pre>
<h3>14.3.5. Parser zum Ver&auml;ndern des Ergebnisses</h3>
          elementare Parser definieren, die bestimmte Token erkennen
          aus zwei Parsern die Sequenz bilden, die als Ergebnis das Paar der zwei
 Tailparses hat.
          aus zwei Parsern einen neuen Parser bilden, der einen der beiden Parser
 anzuwendet.
        <pre>package name.panitz.parser;
public interface Function&lt;a,b&gt;{
    b apply(a x);
}</pre>
<pre>package name.panitz.parser;
import java.util.List;
import java.util.ArrayList;

public class Map&lt;a,b&gt; implements Parser&lt;b&gt;{
  final private Parser&lt;a&gt; p1;
  final private Function&lt;a,b&gt; f;
  public Map(Parser&lt;a&gt; _p1,Function&lt;a,b&gt; _f){p1=_p1;f=_f;}</pre>
<pre>  public ParseResult&lt;b&gt; parse(List&lt;Token&gt; ts){
    ParseResult&lt;a&gt; r1 = p1.parse(ts);</pre>
<pre>    if (r1.failed()) return new ParseResult&lt;b&gt;(null,ts);
    return new ParseResult&lt;b&gt;
      (f.apply(r1.getResult()),r1.getRemainingToken());
  }
}</pre>
<h3>14.3.6. Beispiel: arithmetische Ausdr&uuml;cke</h3>start     ::= addExpraddExpr ::=  multExpraddOpaddExprmultExprmultExpr ::=  zahlmultOpmultExpr zahlmultOp ::= */addOp ::= +-<h4>14.3.6.1. Token</h4>
<pre>package name.panitz.parser;
public class Zahl implements Token{
  final public int i;
  public Zahl(int _i){i=_i;}
  public boolean equals(Object o){return o instanceof Zahl;} 
}</pre>
<pre>package name.panitz.parser;
public enum OpToken implements Token{
 add,sub,mult,div;</pre>
<pre>package name.panitz.parser;

public interface BinFunction&lt;a,b,c&gt;{
  c apply(a x,b y);
}</pre>
<pre>package name.panitz.parser;

public interface IntOp 
         extends BinFunction&lt;Integer,Integer,Integer&gt;{}</pre>
<pre>
 public IntOp getFunction(){
   switch (this){
     case div : return new IntOp(){
          public Integer apply(Integer x,Integer y){return x/y;}};
     case mult : return new IntOp(){
          public Integer apply(Integer x,Integer y){return x*y;}};
     case add : return new IntOp(){
          public Integer apply(Integer x,Integer y){return x+y;}};
     default : return new  IntOp(){
          public Integer apply(Integer x,Integer y){return x-y;}};
   }
  }
}</pre>
<h4>14.3.6.2. AuswertungsParser</h4>Zahl<pre>package name.panitz.parser;
import java.util.List;

public class ZahlEval implements Parser&lt;Integer&gt;{
  public ParseResult&lt;Integer&gt; parse(List&lt;Token&gt; ts){
    return new Map&lt;Zahl,Integer&gt;
        (new ParseToken&lt;Zahl&gt;(new Zahl(0))
        ,new Function&lt;Zahl,Integer&gt;(){
           public Integer apply(Zahl z){return z.i;}}
        ).parse(ts);
  }
}</pre>
<pre>package name.panitz.parser;
import java.util.List;

public class GetIntOp implements Function&lt;OpToken,IntOp&gt;{
  public IntOp apply(OpToken t){
    return t.getFunction();
  }
}</pre>
<pre>package name.panitz.parser;
import java.util.List;

public class MultOpEval implements Parser&lt;IntOp&gt;{
  public ParseResult&lt;IntOp&gt; parse(List&lt;Token&gt; ts){
    return new Map&lt;OpToken,IntOp&gt;
      (new Alt&lt;OpToken&gt;
         (new ParseToken&lt;OpToken&gt;(OpToken.mult)
         ,new ParseToken&lt;OpToken&gt;(OpToken.div))
      ,new GetIntOp()).parse(ts);
  }
}</pre>
<pre>package name.panitz.parser;
import java.util.List;

public class AddOpEval implements Parser&lt;IntOp&gt;{
  public ParseResult&lt;IntOp&gt; parse(List&lt;Token&gt; ts){
    return new Map&lt;OpToken,IntOp&gt;
      (new Alt&lt;OpToken&gt;
         (new ParseToken&lt;OpToken&gt;(OpToken.add)
         ,new ParseToken&lt;OpToken&gt;(OpToken.sub))
      ,new GetIntOp()).parse(ts);
  }
}</pre>multExprmultExpr ::=  zahlmultOpmultExpr zahl Zahl multOp multExprZahlPair&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt;DoIntOp<pre>package name.panitz.parser;

public class DoIntOp
   implements Function&lt;Pair&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt;,Integer&gt;{
  public Integer apply(Pair&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt; x){
    return x.getE2().getE1().apply(x.getE1(),x.getE2().getE2());
  }
}</pre>multExpr<pre>package name.panitz.parser;
import java.util.List;

public class MultExprEval implements Parser&lt;Integer&gt;{
  public ParseResult&lt;Integer&gt; parse(List&lt;Token&gt; ts){
    return
      new Alt&lt;Integer&gt;
       (new Map&lt;Pair&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt;,Integer&gt;
         (new Seq&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt;
           (new ZahlEval(),new Seq&lt;IntOp,Integer&gt;
                            (new MultOpEval(),new MultExprEval()))
         ,new DoIntOp()
         )
       ,new ZahlEval()
       ).parse(ts);
  }
}</pre>addExpraddExpr ::=  multExpraddOpaddExprmultExpr<pre>package name.panitz.parser;
import java.util.List;

public class AddExprEval implements Parser&lt;Integer&gt;{
  public ParseResult&lt;Integer&gt; parse(List&lt;Token&gt; ts){
    return
      new Alt&lt;Integer&gt;
       (new Map&lt;Pair&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt;,Integer&gt;
         (new Seq&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt;
           (new MultExprEval(),new Seq&lt;IntOp,Integer&gt;
                            (new AddOpEval(),new AddExprEval()))
         ,new DoIntOp()
         )
       ,new MultExprEval()
       ).parse(ts);
  }
}</pre>addExpr<pre>package name.panitz.parser;
import java.util.List;

public class EvalArith implements Parser&lt;Integer&gt;{
  Parser&lt;Integer&gt; startExpr = new AddExprEval();

  public ParseResult&lt;Integer&gt; parse(List&lt;Token&gt; ts){
    return startExpr.parse(ts);
  }
}</pre>
<pre>package name.panitz.parser;
import java.util.List;
import java.util.ArrayList;

public class TestEvalArith {

  public static void main(String[] _){
    List&lt;Token&gt; ts = new ArrayList&lt;Token&gt;();
    ts.add(new Zahl(17));
    ts.add(OpToken.mult);
    ts.add(new Zahl(2));
    ts.add(OpToken.add);
    ts.add(new Zahl(8));

    ParseResult&lt;Integer&gt; res = new EvalArith().parse(ts);
    System.out.println(res.getResult());
    System.out.println(res.getRemainingToken());
  }
}</pre>
<h4>14.3.6.3. Aufbau eines Parsbaumes</h4>
<pre>package name.panitz.parser;
import name.panitz.data.tree.*;
import java.util.List;

public class ZahlTree implements Parser&lt;Tree&lt;String&gt;&gt;{
  public ParseResult&lt;Tree&lt;String&gt;&gt; parse(List&lt;Token&gt; ts){
    return new Map&lt;Zahl,Tree&lt;String&gt;&gt;
        (new ParseToken&lt;Zahl&gt;(new Zahl(0))
        ,new Function&lt;Zahl,Tree&lt;String&gt;&gt;(){
           public Tree&lt;String&gt; apply(Zahl z){
             return new Tree&lt;String&gt;(""+z.i);}}
        ).parse(ts);
  }
}</pre>
<pre>package name.panitz.parser;
import name.panitz.data.tree.*;

public interface OpTree 
    extends BinFunction&lt;Tree&lt;String&gt;,Tree&lt;String&gt;,Tree&lt;String&gt;&gt;{}</pre>
<pre>package name.panitz.parser;
import name.panitz.data.tree.*;

import java.util.List;
import java.util.ArrayList;

public class GetOpTree implements Function&lt;OpToken,OpTree&gt;{
  public OpTree apply(final OpToken t){
    return 
      new OpTree(){
        public Tree&lt;String&gt; apply(Tree&lt;String&gt;op1,Tree&lt;String&gt; op2){
          List&lt;Tree&lt;String&gt;&gt; cs = new ArrayList&lt;Tree&lt;String&gt;&gt;();
          cs.add(op1);
          cs.add(op2);
          return new Tree&lt;String&gt;(t.toString(),cs);
        }
      };
  }
}</pre>
<pre>package name.panitz.parser;
import name.panitz.data.tree.*;

import java.util.List;

public class MultOpTree implements Parser&lt;OpTree&gt;{
  public ParseResult&lt;OpTree&gt; parse(List&lt;Token&gt; ts){
    return new Map&lt;OpToken,OpTree&gt;
      (new Alt&lt;OpToken&gt;
         (new ParseToken&lt;OpToken&gt;(OpToken.mult)
         ,new ParseToken&lt;OpToken&gt;(OpToken.div))
      ,new GetOpTree()).parse(ts);
  }
}</pre>
<pre>package name.panitz.parser;
import name.panitz.data.tree.*;

import java.util.List;

public class AddOpTree implements Parser&lt;OpTree&gt;{
  public ParseResult&lt;OpTree&gt; parse(List&lt;Token&gt; ts){
    return new Map&lt;OpToken,OpTree&gt;
      (new Alt&lt;OpToken&gt;
         (new ParseToken&lt;OpToken&gt;(OpToken.add)
         ,new ParseToken&lt;OpToken&gt;(OpToken.sub))
      ,new GetOpTree()).parse(ts);
  }
}</pre>
<pre>package name.panitz.parser;
import name.panitz.data.tree.*;

public class DoOpTree
 implements  Function&lt;Pair&lt;Tree&lt;String&gt;,Pair&lt;OpTree,Tree&lt;String&gt;&gt;&gt;
                     ,Tree&lt;String&gt;&gt; {
  public Tree&lt;String&gt; apply
                   (Pair&lt;Tree&lt;String&gt;,Pair&lt;OpTree,Tree&lt;String&gt;&gt;&gt; x){
    return x.getE2().getE1().apply(x.getE1(),x.getE2().getE2());
  }
}</pre>
<pre>package name.panitz.parser;
import name.panitz.data.tree.*;

import java.util.List;

public class MultExprTree implements Parser&lt;Tree&lt;String&gt;&gt;{
  public ParseResult&lt;Tree&lt;String&gt;&gt; parse(List&lt;Token&gt; ts){
    return
      new Alt&lt;Tree&lt;String&gt;&gt;
       (new Map&lt;Pair&lt;Tree&lt;String&gt;,Pair&lt;OpTree,Tree&lt;String&gt;&gt;&gt;,Tree&lt;String&gt;&gt;
         (new Seq&lt;Tree&lt;String&gt;,Pair&lt;OpTree,Tree&lt;String&gt;&gt;&gt;
           (new ZahlTree(),new Seq&lt;OpTree,Tree&lt;String&gt;&gt;
                            (new MultOpTree(),new MultExprTree()))
         ,new DoOpTree()
         )
       ,new ZahlTree()
       ).parse(ts);
  }
}</pre>
<pre>package name.panitz.parser;
import name.panitz.data.tree.*;

import java.util.List;

public class AddExprTree implements Parser&lt;Tree&lt;String&gt;&gt;{
  public ParseResult&lt;Tree&lt;String&gt;&gt; parse(List&lt;Token&gt; ts){
    return
      new Alt&lt;Tree&lt;String&gt;&gt;
       (new Map&lt;Pair&lt;Tree&lt;String&gt;,Pair&lt;OpTree,Tree&lt;String&gt;&gt;&gt;,Tree&lt;String&gt;&gt;
         (new Seq&lt;Tree&lt;String&gt;,Pair&lt;OpTree,Tree&lt;String&gt;&gt;&gt;
           (new MultExprTree(),new Seq&lt;OpTree,Tree&lt;String&gt;&gt;
                            (new AddOpTree(),new AddExprTree()))
         ,new DoOpTree()
         )
       ,new MultExprTree()
       ).parse(ts);
  }
}</pre>
<pre>package name.panitz.parser;
import java.util.List;
import name.panitz.data.tree.*;

public class TreeArith implements Parser&lt;Tree&lt;String&gt;&gt;{
  Parser&lt;Tree&lt;String&gt;&gt; startExpr = new AddExprTree();

  public ParseResult&lt;Tree&lt;String&gt;&gt; parse(List&lt;Token&gt; ts){
    return startExpr.parse(ts);
  }
}</pre>
<pre>package name.panitz.parser;
import name.panitz.data.tree.*;
import java.util.List;
import java.util.ArrayList;
import javax.swing.*;

public class TestTreeArith {

  public static void main(String[] _){
    List&lt;Token&gt; ts = new ArrayList&lt;Token&gt;();
    ts.add(new Zahl(17));
    ts.add(OpToken.mult);
    ts.add(new Zahl(2));
    ts.add(OpToken.add);
    ts.add(new Zahl(8));
    ts.add(OpToken.mult);
    ts.add(new Zahl(2));
    ts.add(OpToken.div);
    ts.add(new Zahl(1));
    ts.add(OpToken.add);
    ts.add(new Zahl(1));
    ts.add(OpToken.sub);
    ts.add(new Zahl(1));
    ParseResult&lt;Tree&lt;String&gt;&gt; res = new TreeArith().parse(ts);
    JFrame f = new JFrame();
    f.getContentPane().add(new DisplayTree(res.getResult()));
    f.pack();
    f.setVisible(true);
    System.out.println(res.getRemainingToken());
  }
}</pre>
<h3>14.3.7. Tokenizer</h3>
<pre>package name.panitz.parser;
import java.util.List;
import java.util.ArrayList;
import java.io.Reader;
import java.io.StringReader;
import java.io.IOException;

class ArithTokenizer {</pre>Reader<pre>  Reader reader; 
  int next=0;
  List&lt;Token&gt; result = new ArrayList&lt;Token&gt;();</pre>
<pre>  ArithTokenizer(Reader reader){
    this.reader=reader;
    try {
      next= reader.read();
    }catch (IOException _){}
  }</pre>tokenize<pre>  List&lt;Token&gt; tokenize() throws Exception{
    try {
      while (next&gt;=0){
        char c = (char)next;
        switch (c){</pre>
<pre>          case '\u0020'  : break;
          case '\n' : break;
          case '\t' : break;</pre>
<pre>          case '+'  : result.add(OpToken.add) ; break;
          case '-'  : result.add(OpToken.sub) ; break;
          case '*'  : result.add(OpToken.mult); break;
          case '/'  : result.add(OpToken.div) ; break;</pre>
<pre>          default   : if (Character.isDigit(c)) {
                        result.add(getInt());
                        continue;
                      }else throw new Exception
                            ("unexpected Token found: '"+c+"'");
        }</pre>
<pre>
        next = reader.read();
      }
    }catch (IOException _){}
    return result;
  }
</pre>
<pre>
  Token getInt() throws IOException {
    int res=0;
    while (next&gt;=0 &amp;&amp; Character.isDigit((char)next)){
      res=res*10+next-48;
        next = reader.read();
    }
      
    return new Zahl(res);
  }
</pre>
<pre>
  static List&lt;Token&gt; tokenize(String inp) throws Exception{
    return tokenize(new StringReader(inp));
  }

  static List&lt;Token&gt; tokenize(Reader inp) throws Exception{
      return new ArithTokenizer(inp).tokenize();
  }
}</pre>sep@swe10:~/fh/prog2/examples&gt; java Jugs
     __ __  __  ____   ___      _________________________________________
     || ||  || ||  || ||__      Jugs: the interactive Java interpreter
     || ||__|| ||__||  __||     Copyright (c) 2003 Sven Eric Panitz
     ||         ___||           World Wide Web:
||   ||                                  http://www.tfh-berlin.de/~panitz
\\__//  Version: February 2003  _________________________________________


&gt;ArithTokenizer.tokenize("888+0009   *+-/   9")
[888, add, 9, mult, add, sub, div, 9]
&gt;ArithTokenizer.tokenize("888+0009   *uiu**+- 09")
java.lang.Exception: unexpected Token found: 'u'
&gt;.arithpng<pre>package name.panitz.parser;
import java.io.*;
import javax.imageio.ImageIO; 
import javax.swing.*; 
import name.panitz.data.tree.Tree;
import name.panitz.data.tree.DisplayTree;
import static name.panitz.data.tree.TreeToFile.treeToFile;

class ArithParsTreeBuilder{
  
  public static void main(String [] args) throws Exception{
    final String fileName = args[0];
    writeParsTreeFile(new FileReader(fileName+".arith"),fileName);    
  }

  static void writeParsTreeFile(Reader reader,String fileName)
                                               throws Exception{
    treeToFile(parsArith(reader),fileName);            
  }

  public static Tree&lt;String&gt; parsArith(Reader reader) 
                                               throws Exception{
    final ParseResult&lt;Tree&lt;String&gt;&gt; res
     = new TreeArith().parse(ArithTokenizer.tokenize(reader));
    return res.getResult();
  }

  public static DisplayTree parseAndShow(String inp) 
                                      throws Exception{
    return new DisplayTree(parsArith(new StringReader(inp)));
  }

  public static void parseAndShowInFrame(String inp)
                                      throws Exception{
    JComponent c = ArithParsTreeBuilder.parseAndShow(inp);
    JFrame f = new JFrame();
    f.getContentPane().add(c);
    f.pack();
    f.setVisible(true);
  }
}</pre>(2 Punkte) In dieser Aufgabe sollen Sie den Parser f&uuml;r
arithmetische Ausdr&uuml;cke um geklammerte Ausdr&uuml;cke erweitern. 
Hierzu sei die Grammatik f&uuml;r die Regel multExpr wie folgt ge&auml;ndert:multExpr ::=  atomExprmultOpmultExpratomExpratomExpr ::= (addExpr)|zahl

Hierzu sei die entsprechende zus&auml;tzliche Tokenaufz&auml;hlung f&uuml;r die zwei
Klammersymbole gegeben:<pre>package name.panitz.parser;
public enum Parentheses implements Token{lpar,rpar;}</pre>

Zus&auml;tzlich gegeben sei die die folgende Funktion:<pre>package name.panitz.parser;

public class DoParentheses
  implements  
    Function&lt;Pair&lt;Parentheses,Pair&lt;Integer,Parentheses&gt;&gt;,Integer&gt;{
  public Integer 
             apply(Pair&lt;Parentheses,Pair&lt;Integer,Parentheses&gt;&gt; x){
    return x.getE2().getE1();
  }
}</pre>
          Schreiben Sie eine Klasse AtomExprEval, 
die Parser&lt;Integer&gt; implementiert und der Regel 
f&uuml;r atomExpr entspricht.
          &Auml;ndern Sie die Klasse MultExprEval, so da&szlig; sie der ge&auml;nderten
Grammatikregel entspricht. 
          Erweitern Sie die Klasse ArithTokenizer, so da&szlig; er auch die
beiden Klammersymbole erkennt.
        <h2>14.4. Parsergeneratoren</h2>yet
another compiler compilerBisonlexyavaccantlrgentle<h3>14.4.1. javacc</h3>javaccjjtree: Dieses Programm generiert Klassen, mit denen
der Ableitungsbaum eines Parses dargestellt werden kann. Es nimmt als
Eingabedatei eine Beschreibung der Grammatik. Diese Datei hat die
Endung .jjt. Sie generiert Klassen f&uuml;r die Baumknoten. 
Zus&auml;tzlich generiert
es eine Datei mit der Endung .jj. die im n&auml;chsten Schritt
Eingabe f&uuml;r den eigentlichen Parsergenerator ist.javacc: Dieses Programm generiert eine Klasse f&uuml;r den
eigentlichen Parser. Seine Eingabe ist eine Beschreibung der Grammatik
in einer Datei mit Endung .jj. Sie generiert eine
Klasse f&uuml;r den Parser und eine f&uuml;r die
Token, die in der Grammatik spezifiziert werden. Zus&auml;tzlich werden
Klassen zur Fehlerbehandlung generiert.backtrackingshift-reduceshiftjavaccbacktrackingjavaccAls erstes Beispiel  wollen wir f&uuml;r unsere Sprache astronomischer
Aussagen einen Parser generieren lassen. Hierzu schreiben wir eine
Eingabegrammatikdatei mit den Namen sms.jjt.SMS
stehe hier f&uuml;r Sonne Mond und Sterne..
Die Datei sms.jjt beginnt mit einer Definition der Klasse,
die den Parser enthalten soll. In unserem Beispiel soll die generierte
Klasse SMS hei&szlig;en:<pre>PARSER_BEGIN(SMS)
public class SMS {
}
PARSER_END(SMS)</pre>

Anschlie&szlig;end lassen sich die Token der Sprache definieren. In unserem
Beispiel gibt es 8 W&ouml;rter. Wir k&ouml;nnen f&uuml;r  javacc definieren,
da&szlig; Gro&szlig;-und-Kleinschreibung f&uuml;r unsere W&ouml;rter irrelevant ist. <pre>TOKEN [IGNORE_CASE] :
{ &lt;MOON: "moon"&gt;
| &lt;MARS: "mars"&gt;
| &lt;MERCURY: "mercury"&gt;
| &lt;PHOEBUS: "phoebus"&gt;
| &lt;DEIMOS: "deimos"&gt;
| &lt;ORBITS: "orbits"&gt;
| &lt;IS: "is"&gt;
| &lt;A: "a"&gt;
}</pre>

Zus&auml;tzlich gibt es in javacc die M&ouml;glichkeit anzugeben, was
f&uuml;r Zwischenraum zwischen den Token stehen darf. In unserem Beispiel
wollen wir Leerzeichen, Tabularturzeichen und Zeilenendezeichen
zwischen den W&ouml;rtern als Trennung zulassen: <pre>SKIP :
{ " "
| "\t"
| "\n"
| "\r"
}</pre>

Und schlie&szlig;lich und endlich folgen die Regeln f&uuml;r die Grammatik:<pre>void start() : {}
{
  nounPhrase() verbPhrase() 
}

void nounPhrase() : {}
{
  noun()|article() noun()
}

void noun() : {}
{ &lt;MOON&gt;|&lt;MARS&gt;|&lt;MERCURY&gt;|&lt;PHOEBUS&gt;|&lt;DEIMOS&gt;
}

void article() : {}
{&lt;A&gt;}

void verbPhrase() : {}
{
verb() nounPhrase()
}

void verb() : {}
{
 &lt;IS&gt;|&lt;ORBITS&gt;
}</pre>

Aus dieser Datei sms.jj lassen sich jetzt mit dem 
Programm jjtree Klassen f&uuml;r die Darstellung des
Ableitungsbaums generieren:sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; ls
sms.jjt
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; jjtree sms.jjt
Java Compiler Compiler Version 2.1 (Tree Builder)
Copyright (c) 1996-2001 Sun Microsystems, Inc.
Copyright (c) 1997-2001 WebGain, Inc.
(type "jjtree" with no arguments for help)
Reading from file sms.jjt . . .
File "Node.java" does not exist.  Will create one.
File "SimpleNode.java" does not exist.  Will create one.
Annotated grammar generated successfully in sms.jj
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; ls
JJTSMSState.java  SMSTreeConstants.java  sms.jj
Node.java         SimpleNode.java        sms.jjt
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt;

Wie zu sehen ist, werden Klassen f&uuml;r Baumknoten 
generiert (SimpleNode.java) und eine Eingabedatei f&uuml;r den
eigentlichen Parsergenerator (sms.jj). Jetzt k&ouml;nnen wir
diesen Parser generieren lassen:sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; javacc sms.jj
Java Compiler Compiler Version 2.1 (Parser Generator)
Copyright (c) 1996-2001 Sun Microsystems, Inc.
Copyright (c) 1997-2001 WebGain, Inc.
(type "javacc" with no arguments for help)
Reading from file sms.jj . . .
File "TokenMgrError.java" does not exist.  Will create one.
File "ParseException.java" does not exist.  Will create one.
File "Token.java" does not exist.  Will create one.
File "SimpleCharStream.java" does not exist.  Will create one.
Parser generated successfully.
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; ls
JJTSMSState.java     SMSConstants.java      SimpleNode.java     sms.jjt
Node.java            SMSTokenManager.java   Token.java
ParseException.java  SMSTreeConstants.java  TokenMgrError.java
SMS.java             SimpleCharStream.java  sms.jj
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt;

Die generierten Javaklassen lassen sich &uuml;bersetzen:sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; javac *.java
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; ls
JJTSMSState.class     SMSConstants.class      SimpleNode.class
JJTSMSState.java      SMSConstants.java       SimpleNode.java
Node.class            SMSTokenManager.class   Token.class
Node.java             SMSTokenManager.java    Token.java
ParseException.class  SMSTreeConstants.class  TokenMgrError.class
ParseException.java   SMSTreeConstants.java   TokenMgrError.java
SMS.class             SimpleCharStream.class  sms.jj
SMS.java              SimpleCharStream.java   sms.jjt
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt;
Bevor wir den Parser benutzen k&ouml;nnen, schauen wir uns die generierter
Parserdatei SMS.java in Ausz&uuml;gen einmal an:<pre>/* Generated By:JJTree&amp;JavaCC: Do not edit this line. SMS.java */
public class SMS/*bgen(jjtree)*/
implements SMSTreeConstants, SMSConstants {/*bgen(jjtree)*/

  protected static JJTSMSState jjtree = new JJTSMSState();

  static final public void start() throws ParseException {
                /* bgen(jjtree) start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      nounPhrase();
      verbPhrase();
    } catch (Throwable jjte000) {

...



  static final public void nounPhrase() throws ParseException {
                     /* bgen(jjtree) nounPhrase */
  SimpleNode jjtn000 = new SimpleNode(JJTNOUNPHRASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MOON:
      case MARS:
      case MERCURY:
      case PHOEBUS:
      kcase DEIMOS:


  public SMS(java.io.InputStream stream) {
    if (jj_initialized_once) {


....
</pre>
Als erstes ist festzustellen, da&szlig; der generierte Parser kein gutes
objektorientiertes Design hat. 
Es gibt f&uuml;r jede Regel der Grammatik eine Methode, allerdings sind
alle Methoden statisch.
Es gibt einen Konstruktor dem ein Objekt des 
Typs java.io.InputStream, in dem die zu parsende Eingabe
&uuml;bergeben wird.
Alle Methoden k&ouml;nnen im Fehlerfall 
eine ParseException werfen, die angibt, wieso eine Eingabe
nicht geparst werden konnte.

Es gibt ein Feld jjtreedes Typs  JJTSMSState, in
welchem das Ergebnis des Parses gespeichert ist. Diese Klasse enth&auml;lt
eine Methode Node rootNode(), mit der die Wurzel des
Ableitungsbaums erhalten werden kann.
 
Damit k&ouml;nnen wir eine Hauptmethode schreiben, in der wir den
generierten Parser aufrufen. <pre>public class MainSMS {
  public static void main(String args[]) throws ParseException {
    SMS parser = new SMS(System.in);
    parser.start();
    ((SimpleNode)parser.jjtree.rootNode()).dump("");
  }
}</pre>
Als Eingabestrom definieren wir die Tastatureingabe. Wir benutzen die
  Methode dump, um den Ableitungsbaum auf dem Bilschirm
  auszugeben. Wir k&ouml;nnen nun das Hauptprgramm starten und mit der
  Tastatur S&auml;tze eingeben:sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; javac *.java
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; java MainSMS
a moon orbits mars
start
 nounPhrase
  article
  noun
 verbPhrase
  verb
  nounPhrase
   noun
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; java MainSMS
mars is a red planet
Exception in thread "main" TokenMgrError: 
Lexical error at line 1, column 11.  Encountered: "r" (114), after : ""
        at SMSTokenManager.getNextToken(SMSTokenManager.java:447)
        at SMS.jj_ntk(SMS.java:298)
        at SMS.noun(SMS.java:84)
        at SMS.nounPhrase(SMS.java:50)
        at SMS.verbPhrase(SMS.java:133)
        at SMS.start(SMS.java:12)
        at MainSMS.main(MainSMS.java:4)
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt;
F&uuml;gen Sie der Datei sms.jjt folgende Zeilen am
Anfang ein:<pre>options {
   MULTI=true;
   STATIC=false;
}</pre>
Generieren Sie mit jjtree und javac den Parser
   neu. Was hat sich ge&auml;ndert?<h1>15. Java und der Rest der Welt</h1>
<h2>15.1. I18N, L12N</h2>
<h2>15.2. Socketkommunikation </h2>
<h2>15.3. RMI</h2>remote method 
invocationjava.rmi.RemotegetDate<pre>package name.panitz.rmi.date;

import java.util.Date;
import java.rmi.Remote;
import java.rmi.RemoteException;

public interface GetDate extends Remote {
    Date getDate() throws RemoteException;
}</pre>throwsRemoteExceptionRemote<pre>package name.panitz.rmi.date;
import java.util.Date;

public class GetDateImpl implements GetDate {
  public Date getDate() {return new Date();}
}</pre>
<h3>15.3.1. RMI Server</h3>GetDatejava.rmi.registryjava.rmi.server
          UnicastRemoteObject: die statische 
Methode exportObject dieser Klasse wandelt ein Objekt in ein Instanz
um, die geeignet ist, &uuml;ber das Netz aufgerufen zu werden. Dahinter verbirgt
sich tats&auml;chlich unter der Hand, der ganze Code, der f&uuml;r die Vorbereitung der
Kommunikation notwendig ist.
          LocateRegistry: hier kann mit der statischen 
Methode getRegistry eine Instanz der auf dem Server laufenden
Registrierumgebung f&uuml;r RMI Objekte erhalten werden. 
          Registry: Objekte dieser Klasse haben die 
Methode bind, in der Remote Objekte in der RMI Umgebung
bekannt gemacht werden k&ouml;nnen. Hierbei bindet man einen beliebigen Namen an
das Remote Objekt. Unter diesen Namen k&ouml;nnen Client-Applikationen auf
das Remote-Objekt zugreifen.
        <pre>package name.panitz.rmi.date;

import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class DateServer {
  public static void main(String args[]) {
    try {
      GetDateImpl obj = new GetDateImpl();
      GetDate stub = (GetDate) UnicastRemoteObject.exportObject(obj, 0);
      Registry registry = LocateRegistry.getRegistry();
      registry.bind("date", stub);
      System.err.println("Server ready");
    } catch (Exception e) {
      System.err.println("Server exception: " + e.toString());
      e.printStackTrace();
    }
  }
}</pre>DateServerrmiregistryDateServerjava.rmi.server.codebasesep@pc305-3:~/fh/java/student/classes&gt; rmiregistry &amp;
[1] 5492
sep@pc305-3:~/fh/java/student/classes&gt; java -Djava.rmi.server.codebase=fil
e:///home/sep/fh/java/student/classes/ name.panitz.rmi.date.DateServer &amp;
[2] 5502
sep@pc305-3:~/fh/java/student/classes&gt; Server ready

sep@pc305-3:~/fh/java/student/classes&gt;<h3>15.3.2. RMI Client</h3>
<pre>package name.panitz.rmi.date;
import javax.swing.*;
import java.awt.event.*;

import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class DateClient extends JPanel {
  JButton getButton = new JButton("get new time from server");
  JLabel l    = new JLabel();
  DateClient(String host){
    add(getButton);
    add(l);
    try {
      Registry registry = LocateRegistry.getRegistry(host);
      final GetDate stub = (GetDate) registry.lookup("date");
      l.setText(""+stub.getDate());

      getButton.addActionListener(new ActionListener(){
        public void actionPerformed(ActionEvent e){
          try {
            l.setText(""+stub.getDate());
          }catch (Exception e1){}
        }
      });
    }catch (Exception e) {}
  }

  public static void main(String[] args) {
    JFrame f = new JFrame();
    f.add(new DateClient(args[0]));
    f.pack();
    f.setVisible(true);
  }
}</pre>
<h3>15.3.3. Serialisierbarkeit</h3>Serializable<h3>15.3.4. Verteilte Spielanwendung</h3>Remote
          eine zum Erzeugen eines neuen Balls, wobei jeder Ball durch einen Namen
identifiziert wird.
          eine zum Bewegen eines Balles mit einem bestimmten Namen.
          und eine zum Erfragen der Position eines jeden Balls, der 
existiert.
        <pre>package name.panitz.rmi.game;

import java.rmi.*;
import java.util.Map;

public interface BallGame extends Remote {

  void createBall(String name) throws RemoteException;
  void move(String name,int x,int y) throws RemoteException;
  Map&lt;String,java.awt.Dimension&gt; getBalls()throws RemoteException;
}</pre>DimensionwidthhieghtcreateBallmove<pre>package name.panitz.rmi.game;
import java.util.*;

import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.awt.Dimension;

public class BallGameImpl implements BallGame {
  private Map&lt;String,java.awt.Dimension&gt; bs
    = new HashMap&lt;String,java.awt.Dimension&gt;();

  public void createBall(String name){
    bs.put(name,new Dimension(10,10));}

  public void move(String name,int x,int y){
    Dimension d=bs.get(name);
    if (d!=null) d.setSize(d.width+x,d.height+y);
  }

  public Map&lt;String,java.awt.Dimension&gt; getBalls(){return bs;}
}</pre>
<pre>package name.panitz.rmi.game;

import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
public class BallGameServer {
  public static void main(String args[]) {
    try {
      BallGameImpl obj = new BallGameImpl();
      BallGame stub = (BallGame) UnicastRemoteObject.exportObject(obj, 0);
      Registry registry = LocateRegistry.getRegistry();
      registry.bind("ballgame", stub);
      System.err.println("Server ready");
    } catch (Exception e) {
      System.err.println("Server exception: " + e.toString());
      e.printStackTrace();
    }
  }
}</pre>
<pre>package name.panitz.rmi.game;
import javax.swing.*;
import java.awt.event.*;
import java.awt.Graphics;
import java.awt.Dimension;
import java.awt.Color;

import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import static java.awt.event.KeyEvent.*;

import name.panitz.animation.AnimatedJPanel;

public class BallGameClient extends AnimatedJPanel {
  final String name;
  BallGame game=null;
  final int width = 400;
  final int height = 300;

  BallGameClient(String host,String n){
    this.name=n;
    setFocusable(true);
    try {
      Registry registry = LocateRegistry.getRegistry(host);
      game = (BallGame) registry.lookup("ballgame");
    } catch (Exception e) {}

    addMouseListener(new MouseAdapter(){
      public void mouseClicked(MouseEvent e){
        try{game.createBall(name);}catch(Exception e1){}
      }
    });

    addKeyListener(new KeyAdapter(){
      public void keyReleased(KeyEvent e){
        try{
          switch (e.getKeyCode()){
            case VK_DOWN: game.move(name,0,2);break;
	    case VK_LEFT:game.move(name,-2,0);break;
            case VK_RIGHT:game.move(name,2,0);break;
            case VK_UP:game.move(name,0,-2);break;
          }
        }catch(Exception e1){System.out.println(e);}
      }
    });
  }

  public void paintComponent(Graphics g){
    g.setColor(Color.WHITE);
    g.fillRect(0,0,width,height);
    try{
      for (Dimension d:game.getBalls().values()){
        g.setColor(Color.RED);
        g.fillOval(d.height,d.width,10,10);
      }
    }catch (Exception e){}
  }

  public Dimension getPreferredSize(){
    return new Dimension(width,height);}

  public static void main(String[] args) {
    JFrame f = new JFrame();
    f.add(new BallGameClient(args[0],args[1]));
    f.pack();
    f.setVisible(true);
  }
  public void move(){}
}</pre>
<h2>15.4. Java und Datenbanken</h2>
        auf eine bestehende relationale Datenbank soll zugegriffen werden. In
diesem wahrscheinlich h&auml;ufigeren Fall definiert die Datenbank die Art der
Daten und die Javaanwendung orientiert sich an dieser. 
        eine vollkommen neue Anwendung soll objektorientiert entworfen
werden. Hier stehen die Objekte im Mittelpunkt. Objekte sollen dann auch in
einer Datenbank persistent gehalten werden. Nun sind Objekte auf Tabellen
einer relationalen Datenbank abzubilden. Man spricht von OR-Mapping (object
relational mapping)
      <h3>15.4.1. JDBC Verbindungen</h3>
<pre>package name.panitz.sheetMusic.db;
import java.sql.*;
public class MusicDB{
  final public Connection con;
  public MusicDB(String host,String database,String userid,String password) 
                                                   throws Exception {
    con = DriverManager
          .getConnection("jdbc:mysql://"+host+"/"+database,userid,password);
  }</pre>
<h4>15.4.1.1. SQL expressions</h4>
            
<pre>  public void createTable(String tableName,String tableSpec) 
        throws Exception {    
    final Statement s = con.createStatement();
    s.execute ("create table "+tableName+" "+tableSpec);      
    s.close ( );
  }</pre>
          
            
<pre>  public void insertRow(String tableName,String values ) 
                                                   throws Exception {    
    final Statement s = con.createStatement();
    s.execute("insert into "+tableName+" values "+values);      
    s.close ( );
  }</pre>
          
            
<pre>  public ResultSet query(String sqlExpr) 
                                           throws Exception {
    return con.createStatement().executeQuery(sqlExpr);
  }</pre>
            
<pre>}</pre>
          
<h4>15.4.1.2. Transaktionen</h4>
<h4>15.4.1.3. Beispiellauf</h4>
<pre>package name.panitz.sheetMusic.db;
public class Example{
  public static void main(String [] args) throws Exception{
    MusicDB db = new MusicDB("localhost","test","sep","stammel");
    try{
    db.createTable
     ("composer"
     ,"(last_name varchar(60),first_name varchar(60),biography text)" );
    db.createTable
     ("opus"
     ,"(composer varchar(60),title varchar(256),opsNr varchar(20),url varchar(128))" );

    db.insertRow
     ("composer"
     ,"('Legnani','Luigi','')");
    db.insertRow
     ("composer"
     ,"('Giuliani','Mauro','')");
    db.insertRow
     ("composer"
     ,"('Fossa','Francois de','')");

    db.insertRow
     ("opus"
     ,"('Legnani'"+
      ",'36 capricci per tutti i tuoni maggiori e minori per la chitarra'"+
      ",'20'"+
      ",'http://www.kb.dk/elib/noder/rischel/RIBS0501.pdf')");
    db.insertRow
     ("opus"
     ,"('Legnani'"+
      ",'Coro e rondo, Pensa alla patria nell opera L italiana in Algeri del Rossini'"+
      ",'8a'"+
      ",'http://www.kb.dk/elib/noder/rischel/RIBS0480.pdf')");    
    db.insertRow
     ("opus"
     ,"('Legnani'"+
      ",'Introduction et th&ecirc;me'"+
      ",'237'"+
      ",'http://www.kb.dk/elib/noder/rischel/RIBS0490.pdf')");    
    }catch(Exception e){
    }   
  }  
}</pre>
<h2>15.5. JNI: Aufruf von C</h2>
<h2>15.6. Java unterwegs</h2>
        als Bildschirm existiert nur eine kleinste Fl&auml;che
        als Tastatur stehen in der Regel nur die Tasten eines Telephons zur
Verf&uuml;gung. 
        der Prozessor ist einfacher gestaltet und unterst&uuml;tzt oft keine
Flie&szlig;kommaoperationen. 
        die Kommunikation l&auml;uft auf eingeschr&auml;nkte definierte Wege.
        Arbeitsspeicher ist wesentlich kleiner.
        statt einer gro&szlig;en Festplatte gibt es einebaute oder austauschbare
Speicherchips.  
        eingehende Anrufe sollten in jedem Fall die Oberhand gegen&uuml;ber anderen
Applikationen behalten.
      Wie man am Namen J2ME sieht, hat
Java 5 noch 
nicht in die Welt der Kleinger&auml;te einzug gehalten.<h3>15.6.1. Hello Mobile World</h3>Appletjavax.microedition.midlet.MIDlet<pre>package name.panitz.mobile;

import javax.microedition.midlet.MIDlet; 
import javax.microedition.lcdui.*; 
 
public class HelloMobileWorld extends MIDlet{</pre>DisplayFormDisplayJFrameFormJPanel<pre>  public void startApp() {
    final Display display = Display.getDisplay(this);     
    final Form mainForm = new Form("TinyMIDlet");</pre>Form<pre>    mainForm.append("Welcome to the world of MIDlets!");</pre>AWTSwingFormFormexit<pre>    mainForm.setCommandListener(new CommandListener(){
      public void commandAction(Command c, Displayable s) { 
        if (c.getCommandType() == Command.EXIT) 
          notifyDestroyed(); 
       } 
    });</pre>Form<pre>    display.setCurrent(mainForm);</pre>Exit<pre>    mainForm.addCommand(new Command("Exit", Command.EXIT, 0)); 
  } 
  public void destroyApp(boolean b) {}
  public void pauseApp() {}
} </pre>
<h4>15.6.1.1. &Uuml;bersetzen der drahtlosen Anwendung</h4>
            
<pre>javac \
  -bootclasspath \
 /home/sep/software/WTK2.2/lib/cldcapi10.jar\
:/home/sep/software/WTK2.2/lib/midpapi20.jar \
-source 1.3 -target 1.3 -d classes HelloMobileWorld.java</pre>
          


Abbildung  zeigt die Simuation des Handies zu
Testzwecken. <h3>15.6.2. Pong f&uuml;rs Handy</h3>PongAMovablepaintGraphicsjavax.microedition.lcdui<pre>
package name.panitz.mobile.pong;
import javax.microedition.lcdui.Graphics;

public interface MMovable extends name.panitz.games.AMovable{
  public void paintMeTo(Graphics g);
}</pre>ASimpleMovable<pre>package name.panitz.mobile.pong;
import javax.microedition.lcdui.Graphics;

public class MSimpleMovable extends name.panitz.games.ASimpleMovable 
                            implements MMovable{
  public void paintMeTo(Graphics g){
    g.setColor(0x00FFFF);
    g.fillRect(x,y,width,height); 
  }
}</pre>
<pre>
package name.panitz.mobile.pong;
import javax.microedition.lcdui.Graphics;

public class MBall extends MSimpleMovable{
  public MBall(){}
  public MBall(int x,int y){this.x=x;this.y=y;moveX=3;}

  public void paintMeTo(Graphics g ){
    g.setColor(0x00FFFF);
    g.fillArc(x,y,width,height,0,360); 
  }
}</pre>
<pre>
package name.panitz.mobile.pong;

public class MPaddle extends MSimpleMovable{
  public MPaddle(int xPos){
    x=xPos;
    width=10;
    height=30;
    moveX=0;
    moveY=2;
  }
}</pre>
<pre>
package name.panitz.mobile.pong;

import javax.microedition.lcdui.*;

public class PongCanvas extends Canvas implements Runnable {
  Display display;
  MBall ball=null;
  MPaddle leftPaddle = new MPaddle(10);
  MPaddle rightPaddle= new MPaddle(getWidth()-20);
  final MMovable[] paddles = {leftPaddle,rightPaddle};
  int leftPoints=0;
  int rightPoints=0;
  static final int LEFT_PL=0;
  static final int RIGHT_PL=1;
  int nextPlayer=LEFT_PL;

  boolean paused = false;

  public PongCanvas(Display d) {display = d;}

  final int delay = 20;
  public void run() {
    while (!paused){
      move();
      repaint();
      try {
        Thread.sleep(delay);
      } catch (InterruptedException e) {}
    }
  }

  String msg = null;
  protected void paint(Graphics g) {
    int x = g.getClipX();
    int y = g.getClipY();
    int w = g.getClipWidth();
    int h = g.getClipHeight();

    // Draw the frame 
    g.setColor(0xffffff);
    g.fillRect(x, y, w, h);

    paddles[0].paintMeTo(g);
    paddles[1].paintMeTo(g);
    if (null!=ball) ball.paintMeTo(g);

    g.setColor(0x000000);
    g.drawString(""+leftPoints,30,30,g.TOP|g.LEFT);
    g.drawString(""+rightPoints,getWidth()-30,30,g.TOP|g.RIGHT);


    g.setColor(0);
    g.drawRect(0, 0, getWidth()-1, getHeight()-1);
  }

  public void move(){
    rightPaddle.setX(getWidth()-20); 
    if (ball!=null){
      if (ball.above(0) || ball.underneath(getHeight())){
        ball.reverseYDirection();
        ball.move();
      }

      if (ball.leftOf(0) ){
	ball=null;
	rightPoints=rightPoints+1;
	nextPlayer=RIGHT_PL;
      }

      else if (ball.rightOf(getWidth()) ){
	ball=null;
	leftPoints=leftPoints+1;
	nextPlayer=LEFT_PL;
      }

      else if (
         (    ball.rightOf(getWidth()-20) 
          &amp;&amp; ball.underneath(rightPaddle.getY())
	  &amp;&amp; ball.above(rightPaddle.getY()+rightPaddle.getHeight())
         )
         ||
         (    ball.leftOf(20) 
          &amp;&amp; ball.underneath(leftPaddle.getY())
	  &amp;&amp; ball.above(leftPaddle.getY()+leftPaddle.getHeight())
         )
        )
	ball.reverseXDirection();
    }

    paddles[0].move();
    paddles[1].move();
    if (ball!=null) ball.move();
    for (int i=0;i&lt;2;i++){
      if (paddles[i].getY()&lt;0) paddles[i].setY(0);
      if (paddles[i].getY()+paddles[i].getHeight()&gt;getHeight()) 
        paddles[i].setY(getHeight()-paddles[i].getHeight());
    }
  }  

  public void keyReleased(int keyCode) {
    int action = getGameAction(keyCode);
    switch (keyCode) {
      case KEY_NUM1:
        leftPaddle.setMoveY(-Math.abs(leftPaddle.getMoveY()));
	break;

      case KEY_NUM3:
        rightPaddle.setMoveY(-Math.abs(rightPaddle.getMoveY()));
	break;
    }
  }

  public void keyPressed(int keyCode) {
    int action = getGameAction(keyCode);
    switch (keyCode) {
      case KEY_NUM1:
        leftPaddle.setMoveY(Math.abs(leftPaddle.getMoveY()));
	break;
      case KEY_NUM3:
        rightPaddle.setMoveY(Math.abs(rightPaddle.getMoveY()));
	break;
      case KEY_NUM0:
        if (ball==null){
          switch (nextPlayer){
            case RIGHT_PL: 
      	      ball=new MBall(getWidth()-32,rightPaddle.getY()+10);
              ball.setMoveX(-ball.getMoveX());
              break;
            case LEFT_PL: 
              ball=new MBall(22,leftPaddle.getY()+10);
              break;
	    }
        }
	break;
    }
  }

  void destroy() {}

  boolean isPaused() {return paused;}
  void pause() {paused = true;}

  void start() {
    paused = false;
    display.setCurrent(this);
    new Thread(this).start();
  }
}</pre>
<pre>
package name.panitz.mobile.pong;

import javax.microedition.midlet.*;
import javax.microedition.lcdui.*;

public class MobilePong extends MIDlet implements CommandListener {
  final Display display = Display.getDisplay(this);
  final PongCanvas canvas = new PongCanvas(display);

  private final Command exitCommand
    = new Command("Exit", Command.EXIT, 99);
  private final Command toggleCommand
    = new Command("Stop/Go", Command.SCREEN, 1);
  private final Command helpCommand 
    = new Command("Help", Command.HELP, 2);
  private final Command aboutCommand
    = new Command("About", Command.HELP, 30);

  private final Form helpScreen = new Form("Pong Help");;
  private final String helpText
    = "0 = new ball\n1 = left paddle\n3 = right paddle";

  public  MobilePong() {
    canvas.addCommand(exitCommand);
    canvas.addCommand(toggleCommand);
    canvas.addCommand(helpCommand);
    canvas.addCommand(aboutCommand);
    canvas.setCommandListener(this);

    helpScreen.append("0 = new ball\n");
    helpScreen.append("1 = move left paddle up/down\n");
    helpScreen.append("3 = move right paddle up/down\n");
  }

  public void startApp() throws MIDletStateChangeException {
    canvas.start();
  }
    
  public void pauseApp() {canvas.pause();}

  public void destroyApp(boolean unconditional) 
      throws MIDletStateChangeException {
    canvas.destroy();
  }

  public void commandAction(Command c, Displayable s) {
    final boolean wasPaused = canvas.isPaused();
    canvas.pause();
    if (c == toggleCommand) {if (wasPaused)canvas.start();}
    else if (c == helpCommand) showHelp();
    else if (c == exitCommand) {
      try {
	destroyApp(false);
	notifyDestroyed();
      } catch (MIDletStateChangeException ex) {}
    } else if (c == aboutCommand) About.showAbout(display);
  }

  void showHelp() {
    helpScreen.addCommand(toggleCommand);
    helpScreen.setCommandListener(this);
    display.setCurrent(helpScreen);
  }
}</pre>
<pre>
package name.panitz.mobile.pong;
import javax.microedition.lcdui.*;

public class About {
  private static final String copyright
    = "Copyright (c) 2005 Sven Eric Panitz. All rights reserved.";

  public static void showAbout(Display display) {
    Alert alert = new Alert("About MIDP");
    alert.setTimeout(Alert.FOREVER);

    if (display.numColors() &gt; 2) {
      String icon = (display.isColor())
                    ?"/icons/JavaPowered-8.png" 
                    : "/icons/JavaPowered-2.png";
      try {
	Image image = Image.createImage(icon);
	alert.setImage(image);
      } catch (java.io.IOException x) {}
    }
    alert.setString(copyright);
    display.setCurrent(alert);
  }
}</pre>
<h1>16. Scala, das Java der Zukunft?</h1>
    
<h1>1. Javawerkzeuge</h1>
<h2>1.1. Klassenpfad und Java-Archive</h2>.class.jarJarJava archive.jar.tartartape archive<h3>1.1.1. Benutzung von jar-Dateien</h3>jarzipjarsep@swe10:~/fh/prog2&gt; jar
Syntax: jar {ctxu}[vfm0Mi] [JAR-Datei] [Manifest-Datei] [-C dir] Dateien ...
Optionen:
    -c  neues Archiv erstellen
    -t  Inhaltsverzeichnis f&uuml;r Archiv auflisten
    -x  benannte (oder alle) Dateien aus dem Archiv extrahieren
    -u  vorhandenes Archiv aktualisieren
    -v  ausf&uuml;hrliche Ausgabe f&uuml;r Standardausgabe generieren
    -f  Namen der Archivdatei angeben
    -m  Manifestinformationen aus angegebener Manifest-Datei einbeziehen
    -0  nur speichern; keine ZIP-Komprimierung verwenden
    -M  keine Manifest-Datei f&uuml;r die Eintr&auml;ge erstellen
    -i  Indexinformationen f&uuml;r die angegebenen JAR-Dateien generieren
    -C  ins angegebene Verzeichnis wechseln und folgende Datei einbeziehen
Falls eine Datei ein Verzeichnis ist, wird sie rekursiv verarbeitet.
Der Name der Manifest-Datei und der Name der Archivdatei m&uuml;ssen
in der gleichen Reihenfolge wie die Flags ''m'' und ''f'' angegeben werden.

Beispiel 1: Archivieren von zwei Klassendateien in einem Archiv 
mit dem Namen classes.jar:
       jar cvf classes.jar Foo.class Bar.class
Beispiel 2: Verwenden der vorhandenen Manifest-Datei ''meinmanifest'' 
und Archivieren aller
           Dateien im Verzeichnis foo/ in ''classes.jar'':
       jar cvfm classes.jar meinmanifest -C foo/ .

sep@swe10:~/fh/prog2&gt;jar<h4>1.1.1.1. Erzeugen von Jar-Dateien</h4>
              jar cf jar-file input-file(s)
            Das c steht daf&uuml;r, das eine Jar-Datei erzeugt werden
soll.Das f steht daf&uuml;r, da&szlig; der Dateiname der zu erzeugenden
Jar-Datei folgt. jar-file ist der Name, den die zu erzeugende Datei haben soll. Hier nimmt man &uuml;blicherweise die Erweiterung .jar f&uuml;r den 
Dateinamen.input-file(s) ist eine Liste beliebiger Dateien und Ordner. Hier kann auch die aus der Kommandozeile
bekannte *-Notation  benutzt werden. Der Befehl
                jar cf myProg.jar *.class
              
verpackt alle Dateien mit der Erweiterung .class in 
eine Jar-Datei namens myProg.jar.<h4>1.1.1.2. Anzeige des Inhalts einer Jar-Datei</h4>
              jar tf jar-file
             Das t steht daf&uuml;r, das eine Auflistung der enthaltenen
Dateien angezeigt werdent steht dabei 
f&uuml;r table.
soll.Das f steht daf&uuml;r, da&szlig; der Dateiname der ben&ouml;tigten 
Jar-Datei folgt. jar-file ist der Name der existierenden Jar-Datei.<h4>1.1.1.3. Extrahieren des Inhalts der Jar-Datei</h4>
              jar xf jar-file [archived-file(s)]
             Die x-Option gibt an, da&szlig; Dateien aus einer Jar-Datei
extrahiert werden sollen.  Das f gibt wieder an, da&szlig; der Name einer JAR-Datei folgt. jar-file ist der Name einer Jar-Datei, aus der die
entsprechenden Dateien zu extrahieren sind.Optional kann noch eine Liste von Dateinamen folgen, die angibt,
welche Dateien extrahiert werden sollen. Wird diese Liste weggelassen,
so werden alle Dateien extrahiert.<h4>1.1.1.4. &Auml;ndern einer Jar Datei</h4>
              jar uf jar-file input-file(s)
             Die Option u gibt an, da&szlig; eine bestehende Jar-Datei
ge&auml;ndert werden soll. Das f gibt wie &uuml;blich an, da&szlig; der Name einer Jar-Datei folgt. Eine Liste von Dateinamen gibt an, da&szlig; diese zur Jar-Datei
hinzuzuf&uuml;gen sind.<h3>1.1.2. Der Klassenpfad</h3>
<h4>1.1.2.1. Angabe des Klassenpfades als Option</h4>-cp-classpathsep@swe10:~/fh/prog2&gt; java -help -cp
Usage: java [-options] class [args...]
           (to execute a class)
   or  java -jar [-options] jarfile [args...]
           (to execute a jar file)

where options include:

    -cp -classpath &lt;directories and zip/jar files separated by :&gt;
                  set search path for application classes and resources
<h4>1.1.2.2. Angabe des Klassenpfades als Umgebungsvariable</h4>CLASSPATH$CLASSPATH%CLASSPATH%
In der Kommandozeile kann man sich &uuml;ber den aktuellen Wert einer 
Umgebungsvariablen informieren.
In Unix geschieht dieses leicht mit Hilfe des 
Befehls echo, dem die Variable in der Dollarnotation folgt: sep@swe10:~/fh/prog2&gt; echo $CLASSPATH
.:/home/sep/jarfiles/log4j-1.2.8.jar:/home/sep/jarfiles:
sep@swe10:~/fh/prog2&gt;

In Windows hingegen benutzt man den Konsolenbefehl set, dem
der Name der Umgebungsvariablen folgt.set CLASSPATH
Innerhalb einer Eingabeaufforderung kann f&uuml;r diese Eingabeaufforderung
der Wert einer Umgebungsvariablen ge&auml;ndert werden. Auch hierin
unterscheiden sich Unix und Windows marginal: Wir f&uuml;gen dem Klassenpfad eine weitere Jar-Datei an ihrem
Beginn an:sep@swe10:~/fh/prog2&gt; export CLASSPATH=~/jarfiles/jugs.jar:$CLASSPATH
sep@swe10:~/fh/prog2&gt; echo $CLASSPATH
/home/sep/jarfiles/jugs.jar:.:/home/sep/jarfiles/log4j-1.2.8.jar:/home/sep/jarfiles: In Windows werden Umgebungsvariablen auch mit dem set-Befehl ge&auml;ndert. Hierbei folgt dem Umgebungsvariablennamen mit einem
Gleichheitszeichen getrennt der neue Wert.
Der entsprechende Befehl des letzten Beispiels ist in Windows:set CLASSPATH=~\jarfiles\jugs.jar:%CLASSPATH%<h2>1.2. APT</h2>
<h2>1.3. Applets testen mit: appletviewer</h2>
<h2>1.4. native2ascii</h2>
<h2>1.5. Klassendateien analysieren mit javap</h2>
<h2>1.6. Parsergeneratoren</h2>
<h3>1.6.1. javacc</h3>
<h3>1.6.2. antlr</h3>
    
<h1>2. Jugs: Java interpetiert</h1>
    
<h1>3. Generierung von Klassen f&uuml;r XML DTDs</h1>
<h2>3.1. Introduction</h2>
<h3>3.1.1. Functional Programming</h3>higher ordercombintor<h4>3.1.1.1. Parser Combinators</h4>
<pre>type Parser result token = [token] -&gt; [(result,[token])]</pre>Parser<pre>getToken tok [] = []
getToken tok (x:xs)
  |tok==x = [(x,xs)]
  |otherwise = []</pre>
              the sequence of two parsers.
              the alternativ of two parsers.
            <pre>alt p1 p2 toks 
  |null res1 = p2 toks
  |otherwise = res1
 where
  res1 = p1 toks</pre>
<pre>seqP p1 p2 toks = concat
  [[((rs1,rs2),tks2) |(rs2,tks2)&lt;-(p2 tks1) ] 
  |(rs1,tks1)&lt;-p1 toks]</pre>
<pre>mapP f p toks = [(f rs,tks)|(rs,tks)&lt;-p toks]</pre>
A very simple parser implementation in Haskell:<pre>parantheses = mapP (\((x1,x2),x3) -&gt; x2)
     (getToken '(' `seqP` a `seqP` getToken ')')

a = getToken 'a' `alt` parantheses

main = do 
  print (parantheses "((((a))))")
  print (parantheses "((((a)))")
  print (parantheses "((((a))))bc")</pre>

The program has the following output:sep@linux:~/fh/xmlparslib/examples&gt; src/HsParse
[('a',"")]
[]
[('a',"bc")]
sep@linux:~/fh/xmlparslib/examples&gt;
In the first call the string could complete be parsed, in the second call the
parser failed and in the third call the parser succeeded but two further
tokens where not consumed by the parser.+*<h3>3.1.2. XML</h3>distributed 
object modell (DOM)<h4>3.1.2.1. Document Type Definition</h4>Throughout this paper we will ignore 
XML attributes.
              sequences of elements, denoted by a comma ,.
              alternatives of elements donoted by the vertical bar |.
              several kinds of repetition denoted by +, * and ?.
            <pre>&lt;!DOCTYPE musiccollection SYSTEM "musiccollection.dtd" [
  &lt;!ELEMENT musiccollection (lp|cd|mc)*&gt;  
  &lt;!ELEMENT lp (title,artist,recordingyear?,track+,note*)&gt;  
  &lt;!ELEMENT cd (title,artist,recordingyear?,track+,note*)&gt;  
  &lt;!ELEMENT mc (title,artist,recordingyear?,track+,note*)&gt;  
  &lt;!ELEMENT track (title,timing?)&gt;  
  &lt;!ELEMENT note (#PCDATA|author)*&gt;

  &lt;!ELEMENT timing (#PCDATA)&gt;  
  &lt;!ELEMENT title (#PCDATA)&gt;  
  &lt;!ELEMENT artist (#PCDATA)&gt;  
  &lt;!ELEMENT author (#PCDATA)&gt;  
  &lt;!ELEMENT recordingyear (#PCDATA)&gt;  
]&gt;</pre>
<pre>&lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
&lt;musiccollection&gt;
  &lt;lp&gt;
    &lt;title&gt;White Album&lt;/title&gt;
    &lt;artist&gt;The Beatles&lt;/artist&gt;
    &lt;recordingyear&gt;1968&lt;/recordingyear&gt;
    &lt;track&gt;&lt;title&gt;Revolution 9&lt;/title&gt;&lt;/track&gt;
    &lt;note&gt;&lt;author&gt;sep&lt;/author&gt;my first lp&lt;/note&gt;
  &lt;/lp&gt;
  &lt;cd&gt;
    &lt;title&gt;Open All Night&lt;/title&gt;
    &lt;artist&gt;Marc Almond&lt;/artist&gt;
    &lt;track&gt;&lt;title&gt;Tragedy&lt;/title&gt;&lt;/track&gt;
    &lt;note&gt;
     &lt;author&gt;sep&lt;/author&gt;
     Marc sung tainted love in the bandSoft Cell&lt;/note&gt;
  &lt;/cd&gt;
&lt;/musiccollection&gt;</pre>
<pre>&lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
&lt;musiccollection/&gt;</pre>
<h3>3.1.3. Java</h3>
<h4>3.1.3.1. Generic Types</h4>
<h2>3.2. Tree Parser</h2>
<h3>3.2.1. Parser Type</h3>Tuple2<pre>package name.panitz.crempel.util;

public class Tuple1&lt;t1&gt; {
  public t1 e1;
  public Tuple1(t1 a1){e1=a1;}
  String parenthes(Object o){return "("+o+")";}
  String simpleToString(){return e1.toString();}
  public String toString(){return parenthes(simpleToString());}
  public boolean equals(Object other){
    if (! (other instanceof Tuple1)) return false;
    return e1.equals(((Tuple1)other).e1);
  }
}</pre>
<pre>package name.panitz.crempel.util;

public class Tuple2&lt;t1,t2&gt; extends Tuple1&lt;t1&gt;{
  public t2 e2;
  public Tuple2(t1 a1,t2 a2){super(a1);e2=a2;}
  String simpleToString(){
    return super.simpleToString()+","+e2.toString();}
  public boolean equals(Object other){
    if (! (other instanceof Tuple2)) return false;
    return super.equals(other)&amp;&amp; e2.equals(((Tuple2)other).e2);
  }
}</pre>
<pre>package name.panitz.crempel.util;

public class Tuple3&lt;t1,t2,t3&gt; extends Tuple2&lt;t1,t2&gt;{
  public t3 e3;
  public Tuple3(t1 a1,t2 a2,t3 a3){super(a1,a2);e3=a3;}
  String simpleToString(){
    return super.simpleToString()+","+e3.toString();}
  public boolean equals(Object other){
    if (! (other instanceof Tuple3)) return false;
    return super.equals(other)&amp;&amp; e3.equals(((Tuple3)other).e3);
  }
}</pre>
<pre>package name.panitz.crempel.util;

public interface Function1&lt;arg,result&gt;{result eval(arg a);}</pre>
<pre>package name.panitz.crempel.util;

public interface Visitor&lt;arg,result&gt; 
                      extends Function1&lt;arg,result&gt;{
}</pre>
<pre>package name.panitz.crempel.util.xml.parslib;

import name.panitz.crempel.util.Tuple2;
import java.util.List;
import org.w3c.dom.Node;

public class ParseResult&lt;a&gt; extends Tuple2&lt;a,List&lt;Node&gt;&gt;{
  public ParseResult(a n,List&lt;Node&gt; xs){super(n,xs);}

  public boolean failed(){return false;}
}</pre>
<pre>package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import org.w3c.dom.Node;

public class Fail&lt;a&gt; extends ParseResult&lt;a&gt;{
  public Fail(List&lt;Node&gt; xs){super(null,xs);}
  public boolean failed(){return true;}
}</pre>parse<pre>package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.Node;
import name.panitz.crempel.util.Maybe;
import name.panitz.crempel.util.Tuple2;
import name.panitz.crempel.util.Function1;

public interface  Parser&lt;a&gt;{
  public ParseResult&lt;a&gt; parse(List&lt;Node&gt; xs);</pre>
<h3>3.2.2. Combinators</h3>
            seq to create a sequence of this parser with some other
  parser. 
            choice to create an alternative of this or some other parser. 
            star to create a zero or more repetition parser of this
  parser.
            plus to create a one or more repetition parser of this
  parser.
            query to create a zero or one repetition parser of this
  parser.
            map to create a  parser from this parser, which modifies the
  parse result with some further method.
          Parser<pre>  public &lt;b&gt; Parser&lt;Tuple2&lt;a,b&gt;&gt; seq(Parser&lt;b&gt; p2);
  public &lt;b extends a&gt; Parser&lt;a&gt; choice(Parser&lt;b&gt; p2);
  public Parser&lt;List&lt;a&gt;&gt; star();
  public Parser&lt;List&lt;a&gt;&gt; plus();
  public Parser&lt;Maybe&lt;a&gt;&gt; query();
  public &lt;b&gt; Parser&lt;b&gt; map(Function1&lt;a,b&gt; f);
}</pre>MaybeJustNothingAbstractParserAbstractParser<h4>3.2.2.1. Optional Parser</h4>?parseNothingJust<pre>package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import name.panitz.crempel.util.Maybe;
import name.panitz.crempel.util.Nothing;
import name.panitz.crempel.util.Just;
import org.w3c.dom.Node;

public  class Optional&lt;a&gt; extends  AbstractParser&lt;Maybe&lt;a&gt;&gt; {
  final Parser&lt;a&gt; p;
  public Optional(Parser&lt;a&gt; _p){p=_p;}
  public ParseResult&lt;Maybe&lt;a&gt;&gt; parse(List&lt;Node&gt; xs){
    final ParseResult&lt;a&gt; res = p.parse(xs);
    if (res.failed())
      return new ParseResult&lt;Maybe&lt;a&gt;&gt;(new Nothing&lt;a&gt;(),xs); 
    return new ParseResult&lt;Maybe&lt;a&gt;&gt;(new Just&lt;a&gt;(res.e1),res.e2);
  }
}</pre>
<h4>3.2.2.2. Sequence</h4>
<pre>package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import name.panitz.crempel.util.Tuple2;
import org.w3c.dom.Node;

public  class Seq&lt;a,b&gt; extends  AbstractParser&lt;Tuple2&lt;a,b&gt;&gt; {
  final Parser&lt;a&gt; p1;
  final Parser&lt;b&gt; p2;

  public Seq(Parser&lt;a&gt; _p1,Parser&lt;b&gt; _p2){p1=_p1;p2=_p2;}

  public ParseResult&lt;Tuple2&lt;a,b&gt;&gt; parse(List&lt;Node&gt; xs){ 
    ParseResult&lt;a&gt; res1 = p1.parse(xs);
    if (res1.failed())
      return new Fail&lt;Tuple2&lt;a,b&gt;&gt;(xs);
    ParseResult&lt;b&gt; res2 = p2.parse(res1.e2);
    if (res2.failed())
      return new Fail&lt;Tuple2&lt;a,b&gt;&gt;(xs);
    return new ParseResult&lt;Tuple2&lt;a,b&gt;&gt;
                 (new Tuple2&lt;a,b&gt;(res1.e1,res2.e1),res2.e2);
  }
}</pre>
<h4>3.2.2.3. Choice</h4>ParseResultFailb extends cParseResult&lt;b&gt;ParseResult&lt;c&gt;<pre>package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import java.util.ArrayList;
import name.panitz.crempel.util.Tuple2;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class  Choice&lt;c,a extends c,b extends c&gt; 
  extends  AbstractParser&lt;c&gt; {
  final Parser&lt;a&gt; p1;
  final Parser&lt;b&gt; p2;

  public Choice(Parser&lt;a&gt; _p1,Parser&lt;b&gt; _p2){p1=_p1;p2=_p2;}

  public ParseResult&lt;c&gt; parse(List&lt;Node&gt; xs){ 
    final ParseResult&lt;a&gt; res1 =  p1.parse(xs);
    if (res1.failed()){
      final ParseResult&lt;b&gt; res2 = p2.parse(xs);
      if (res2.failed()) return new Fail&lt;c&gt;(xs);
      return new  ParseResult&lt;c&gt;(res2.e1,res2.e2);
    }
    return new  ParseResult&lt;c&gt;(res1.e1,res1.e2);
  }
}</pre>
<h4>3.2.2.4. Repetitions</h4>
<pre>package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.Node;</pre>
<pre>public  class Repetition&lt;a&gt; extends  AbstractParser&lt;List&lt;a&gt;&gt; {
  final Parser&lt;a&gt; p;
  final boolean atLeastOne;
  public Repetition(Parser&lt;a&gt; _p,boolean one){
    p=_p;atLeastOne=one;
  }</pre>parse<pre>  public ParseResult&lt;List&lt;a&gt;&gt; parse(List&lt;Node&gt; xs){
    final List&lt;a&gt; resultList = new ArrayList&lt;a&gt;();
    int i = 0;

    while (true){
      final ParseResult&lt;a&gt; res = p.parse(xs);
      xs=res.e2;

      if (res.failed()) break;
      resultList.add(res.e1);
    }

    if (resultList.isEmpty()&amp;&amp; atLeastOne) 
      return new Fail&lt;List&lt;a&gt;&gt;(xs);
    return new ParseResult&lt;List&lt;a&gt;&gt;(resultList,xs);
  }
}</pre>
<pre>package name.panitz.crempel.util.xml.parslib;

import java.util.List;

public class Star&lt;a&gt; extends Repetition&lt;a&gt; {
  public Star(Parser&lt;a&gt; p){super(p,false);}
}</pre>
<pre>package name.panitz.crempel.util.xml.parslib;

import java.util.List;

public class Plus&lt;a&gt; extends Repetition&lt;a&gt; {
  public Plus(Parser&lt;a&gt; p){super(p,true);}
}</pre>
<h4>3.2.2.5. Map</h4>Function1<pre>package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import org.w3c.dom.Node;
import name.panitz.crempel.util.Function1;

public class Map&lt;a,b&gt; extends AbstractParser&lt;b&gt; {
  final Parser&lt;a&gt; p;
  final Function1&lt;a,b&gt; f;

  public Map(Function1&lt;a,b&gt; _f,Parser&lt;a&gt; _p){f=_f;p=_p;}

  public ParseResult&lt;b&gt; parse(List&lt;Node&gt; xs){
    final ParseResult&lt;a&gt; res = p.parse(xs);
    if (res.failed()) return new Fail&lt;b&gt;(xs);
    return new ParseResult&lt;b&gt;(f.eval(res.e1),res.e2); 
  }
}</pre>
<h4>3.2.2.6. Abstract Parser Class</h4>
<pre>package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import name.panitz.crempel.util.Tuple2;
import name.panitz.crempel.util.Maybe;
import name.panitz.crempel.util.Function1;

public abstract class AbstractParser&lt;a&gt; implements Parser&lt;a&gt;{
  public &lt;b&gt; Parser&lt;Tuple2&lt;a,b&gt;&gt; seq(Parser&lt;b&gt; p2){
    return new Seq&lt;a,b&gt;(this,p2);
  }

  public &lt;b extends a&gt; Parser&lt;a&gt; choice(Parser&lt;b&gt; p2){
    return new Choice&lt;a,a,b&gt;(this,p2);
  }

  public Parser&lt;List&lt;a&gt;&gt; star(){return new Star&lt;a&gt;(this);}
  public Parser&lt;List&lt;a&gt;&gt; plus(){return new Plus&lt;a&gt;(this);}
  public Parser&lt;Maybe&lt;a&gt;&gt; query(){return new Optional&lt;a&gt;(this);}
  public &lt;b&gt; Parser&lt;b&gt; map(Function1&lt;a,b&gt; f){
    return new Map&lt;a,b&gt;(f,this);
  }
}</pre>choice<h3>3.2.3. Atomic Parsers</h3>getToken<h4>3.2.3.1. PCDATA</h4>StringString<pre>package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import org.w3c.dom.Node;

public class PCData extends AbstractParser&lt;String&gt; {

  public ParseResult&lt;String&gt; parse(List&lt;Node&gt; xs){
    if (xs.isEmpty()) return new Fail&lt;String&gt;(xs);
    final Node x = xs.get(0);
    if (x.getNodeType()==Node.TEXT_NODE)
      return new ParseResult&lt;String&gt;
                  (x.getNodeValue(),xs.subList(1,xs.size()));
System.out.println("expected pcdata but got: "+x);
    return new Fail&lt;String&gt;(xs);
  }
}</pre>
<h4>3.2.3.2. Empty</h4>
<pre>package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import org.w3c.dom.Node;

public class Return&lt;a&gt; extends AbstractParser&lt;a&gt; {
  final a returnValue;
  public Return(a r){returnValue=r;}
  public ParseResult&lt;a&gt; parse(List&lt;Node&gt; xs){
    return new ParseResult&lt;a&gt;(returnValue,xs);
  }
}</pre>
<h4>3.2.3.3. Element</h4>
              the name of the element to be read.
              the parser to be applied to the children of the element.
            <pre>package name.panitz.crempel.util;

public interface Closure&lt;result&gt;{
  public result eval();
}</pre>
<pre>package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import name.panitz.crempel.util.Closure;


public class Element&lt;a&gt; extends AbstractParser&lt;a&gt; {
  Parser&lt;a&gt; p=null;
  private final Closure&lt;Parser&lt;a&gt;&gt; pc;
  final String elementName;

  public Element(String n,Parser&lt;a&gt; _p){elementName=n;p=_p;pc=null;}
  public Element(String n,Closure&lt;Parser&lt;a&gt;&gt; _p){elementName=n;pc=_p;}

  public Parser&lt;a&gt; getP(){if (p==null) p=pc.eval(); return p;}</pre>
<pre>  public ParseResult&lt;a&gt; parse(List&lt;Node&gt; xs){
    if (xs.isEmpty()) {return new Fail&lt;a&gt;(xs);}
    Node x = xs.get(0);
    while (   x.getNodeType()==Node.TEXT_NODE
           &amp;&amp; x.getNodeValue().trim().length()==0
          ){
      xs=xs.subList(1,xs.size());
      if (xs.isEmpty()) return new Fail&lt;a&gt;(xs);  

      x = xs.get(0);
    }</pre>
<pre>    final String name = x.getNodeName();
System.out.println(name+" &lt;-&gt; "+elementName);
    if (!name.equals(elementName)) 
      return new Fail&lt;a&gt;(xs);</pre>
<pre>    final List&lt;Node&gt; ys = nodelistToList(x.getChildNodes());
    ParseResult&lt;a&gt; res = getP().parse(ys);

    if( res.failed()) return new Fail&lt;a&gt;(xs); </pre>
<pre>    for (Node y :res.e2){
      if (y.getNodeType()!=Node.TEXT_NODE 
             || y.getNodeValue().trim().length()!=0)
         return new Fail&lt;a&gt;(xs);
    }</pre>
<pre>    return new ParseResult&lt;a&gt;(res.e1,xs.subList(1,xs.size()));    
  }</pre>
<pre>  static public List&lt;Node&gt; nodelistToList(NodeList xs){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (int i=0;i&lt;xs.getLength();i=i+1){
      result.add(xs.item(i));
    }
    return result;
  }
}</pre>
<h3>3.2.4. Building parsers</h3>
<h4>3.2.4.1. Defining a Parser</h4>String<pre>package name.panitz.crempel.test;

import java.util.List;
import org.w3c.dom.Node;
import name.panitz.crempel.util.*;
import name.panitz.crempel.util.xml.parslib.*;

public class MusiccollectionParser extends AbstractParser&lt;String&gt;{</pre>Function1String<pre>  final private Function1&lt;Tuple2&lt;String,String&gt;,String&gt; concat
    = new Function1&lt;Tuple2&lt;String,String&gt;,String&gt;(){
         public String eval(Tuple2&lt;String,String&gt; p){
           return p.e1+p.e2;
         }
      };</pre>StringMaybe&lt;String&gt;<pre>  final private Function1&lt;Maybe&lt;String&gt;,String&gt; getString
    = new Function1&lt;Maybe&lt;String&gt;,String&gt;(){
         public String eval(Maybe&lt;String&gt; p){
           if (p instanceof Nothing) return "";  
           return ((Just&lt;String&gt;)p).getJust();
         }
      };</pre>StringString<pre>  final private Function1&lt;List&lt;String&gt;,String&gt; concatList
    = new Function1&lt;List&lt;String&gt;,String&gt;(){
         public String eval(List&lt;String&gt; xs){
           final StringBuffer result = new StringBuffer();
           for (String x:xs) result.append(x);
           return result.toString();
         }
      };</pre>
<pre>  final private Parser&lt;String&gt; recordingyear
    = new Element&lt;String&gt;("recordingyear",new PCData());
  final private Parser&lt;String&gt; artist
    = new Element&lt;String&gt;("artist",new PCData());
  final private Parser&lt;String&gt; title
    = new Element&lt;String&gt;("title",new PCData());
  final private Parser&lt;String&gt; timing
    = new Element&lt;String&gt;("timing",new PCData());
  final private Parser&lt;String&gt; author
    = new Element&lt;String&gt;("author",new PCData());</pre>
<pre>  final private Parser&lt;String&gt; note
    = new Element&lt;String&gt;
       ("note",author.seq(new PCData()).map(concat));

  final private Parser&lt;String&gt; track
    = new Element&lt;String&gt;("track"
        ,title.seq(timing.query().map(getString)).map(concat));
                    
  final private Parser&lt;String&gt; content
    =    title
        .seq(artist).map(concat)
        .seq(recordingyear.query().map(getString)).map(concat)
        .seq(track.plus().map(concatList)).map(concat)
        .seq(note.star().map(concatList)).map(concat);

  final private Parser&lt;String&gt; lp
    = new Element&lt;String&gt;("lp",content);
  final private Parser&lt;String&gt; cd
    = new Element&lt;String&gt;("cd",content);
  final private Parser&lt;String&gt; mc
    = new Element&lt;String&gt;("mc",content);

  final private Parser&lt;String&gt; musiccollection
   = new Element&lt;String&gt;
      ("musiccollection",lp.choice(cd).choice(mc)
                           .star().map(concatList));

  public ParseResult&lt;String&gt; parse(List&lt;Node&gt; xs){
    return musiccollection.parse(xs);
  }
}</pre>
<h4>3.2.4.2. Starting the parser</h4>musiccollection<pre>package name.panitz.crempel.test;

import name.panitz.crempel.util.*;
import name.panitz.crempel.util.xml.parslib.*;

import org.w3c.dom.*;
import java.util.*;
import java.io.*;
import javax.xml.parsers.*;

public class MainParser{
  public static void main(String [] args){
    System.out.println(pFile(args[0],args[1]));
  }

  public static Object pFile(String parserClass,String fileName){
    try{
      DocumentBuilderFactory factory
        = DocumentBuilderFactory.newInstance();

      factory.setIgnoringElementContentWhitespace(true);
      factory.setCoalescing(true); 
      factory.setIgnoringComments(true);

      Document doc
	=factory.newDocumentBuilder()
	.parse(new File(fileName)) ;
      doc.normalize();
      List&lt;Node&gt; xs = new ArrayList&lt;Node&gt;();
      xs.add(doc.getChildNodes().item(0));
 
      Parser&lt;Object&gt; p
       = (Parser&lt;Object&gt;)Class.forName(parserClass).newInstance();
      
      Tuple2 res = p.parse(xs);

      return res.e1;
    }catch (Exception e){e.printStackTrace();return null;}
  }
}</pre>sep@linux:~/fh/xmlparslib/examples&gt; java -classpath classes/  name.panitz.crempel.test.MainParser 
  name.panitz.crempel.test.MusiccollectionParser src/mymusic.xml
White AlbumThe Beatles1968Revolution 9sepmy first lpOpen All NightMarc AlmondTragedysepMarc sung tainted love
sep@linux:~/fh/xmlparslib/examples&gt;<h2>3.3. Building a Tree Structure</h2>
<h3>3.3.1. Java types for DTDs</h3>
<h3>3.3.2. An algebraic type for DTDs</h3>
            PCData
            some element name
            Any
            Empty
            one or more repetition
            zero or more repetition
            zero or one repetition
            a list of choices
            a list of sequence items
          <pre>package name.panitz.crempel.util.xml.dtd.tree;
import name.panitz.adt.*;

public @Data class DTDDef {
  @Constr public void DTDPCData(){}
  @Constr public void DTDTagName(String tagName){}
  @Constr public void DTDAny(){}
  @Constr public void DTDEmpty(){}{}
  @Constr public void DTDPlus(DTDDef dtd){}
  @Constr public void DTDStar(DTDDef dtd){}
  @Constr public void DTDQuery(DTDDef dtd){}
  @Constr public void DTDSeq(java.util.List&lt;DTDDef&gt; seqParts){}
  @Constr public void DTDChoice(java.util.List&lt;DTDDef&gt; choiceParts){}
}</pre>
<h4>3.3.2.1. Simple visitors vor DTDDef</h4>DTDDef
The first visitor returns a textual representation of 
the DTD object.<pre>package name.panitz.crempel.util.xml.dtd;

import name.panitz.crempel.util.xml.dtd.tree.*;
import java.util.List;

public class DTDShow extends DTDDefVisitor&lt;String&gt;{
  public String show(DTDDef def){return ((DTDDefAdt)def).welcome(this);}

  public String visit(DTDPCData _){return "#PCDATA";};
  public String visit(DTDTagName x){return x.tagName;}
  public String visit(DTDEmpty x){return "Empty";}
  public String visit(DTDAny x){return "Any";}
  public String visit(DTDPlus x){return show(x.dtd)+"+";};
  public String visit(DTDStar x){return show(x.dtd)+"*";};
  public String visit(DTDQuery x){return show(x.dtd)+"?";};
  public String visit(DTDSeq s){
    return aux(this,",",s.seqParts);}
  public String visit(DTDChoice c){
    return aux(this,"|",c.choiceParts);}

  private String aux
              (DTDShow visitor,String sep,List&lt;DTDDef&gt; parts){
    StringBuffer result=new StringBuffer("(");
    boolean first = true; for (DTDDef x:parts){
      if (first) first=false; else result.append(sep);
      result.append(show(x));
    }
    result.append(")");
    return result.toString();
  }
}</pre>
Now we write a visitor, which returns in Java syntax the Java type, which we
associate to a certain DTD construct:<pre>package name.panitz.crempel.util.xml.dtd;

import name.panitz.crempel.util.xml.dtd.tree.*;
import name.panitz.crempel.util.*;
import java.util.List;
import java.util.ArrayList;

public class ShowType extends DTDDefVisitor&lt;String&gt;{
  public String visit(DTDPCData x){return "String";}
  public String visit(DTDTagName x){return x.tagName;}
  public String visit(DTDEmpty x){return "Object";}
  public String visit(DTDAny x){return "Object";}
  public String visit(DTDPlus x){return "List&lt;"+showType(x.dtd)+"&gt;";}
  public String visit(DTDStar x){return "List&lt;"+showType(x.dtd)+"&gt;";}
  public String visit(DTDQuery x){return "Maybe&lt;"+showType(x.dtd)+"&gt;";}
  public String visit(DTDSeq x){
    return listAsType((List&lt;DTDDef&gt;) x.seqParts);}

  public String visit(DTDChoice x){
    List&lt;DTDDef&gt; parts = x.choiceParts;
    if (parts.size()==1) return showType(parts.get(0));
    StringBuffer result=new StringBuffer("Choice");
    for (DTDDef y:((List&lt;DTDDef&gt;) parts))
      result.append("_"+typeToIdent(showType(y)));
    return result.toString();
  }

  private  String listAsType(List&lt;DTDDef&gt; xs){
    int size=xs.size();

    if (size==1) return showType(xs.get(0));
    StringBuffer result = new StringBuffer();
    for (Integer i:new FromTo(2,size)){
      result.append("Tuple2&lt;");
    }
    boolean first=true;
    for (DTDDef dtd:xs){
      if (!first) result.append(",");
      result.append(showType(dtd));
      if (!first) result.append("&gt;");
      first=false; 
    }
    return result.toString();       
  }

  public  String showType(DTDDef def){
    return ((DTDDefAdt)def).welcome(this);}

  public  static String sShowType(DTDDef def){
    return new ShowType().showType(def);}

  static public String typeToIdent(String s ){
    return s.replace('&lt;','_').replace('&gt;','_').replace('.','_');
  }
}</pre>
<h3>3.3.3. Generation of tree classes</h3>
<pre>package name.panitz.crempel.util.xml.dtd;

//import name.panitz.crempel.util.adt.parser.ADT;
import name.panitz.crempel.util.xml.dtd.tree.*;
import name.panitz.crempel.util.*;
//import name.panitz.crempel.util.adt.*;
import java.util.List;
import java.util.ArrayList;
import java.io.Writer;
import java.io.StringReader;
import java.io.FileWriter;
import java.io.StringWriter;
import java.io.IOException;

public class GenerateADT extends DTDDefVisitor&lt;String&gt;{
  final String elementName;
  public GenerateADT(String e){elementName=e;}

  public String visit(DTDPCData x){
   return "  public @Constr void Con(String pcdata){}";}
  public String visit(DTDTagName x){
    final String typeName = ShowType.sShowType(x);
    return "  public @Constr void Con("+typeName+" the"+typeName+"){}";}
  public String visit(DTDEmpty x){return "";}
  public String visit(DTDAny x){return "";}
  public String visit(DTDPlus x){
    return "  public @Constr void Con(List&lt;"+ShowType.sShowType(x.dtd)+"&gt; xs){}";}
  public String visit(DTDStar x){
    return "  public @Constr void Con(List&lt;"+ShowType.sShowType(x.dtd)+"&gt; xs){}";}
  public String visit(DTDQuery x){
    return "  public @Constr void Con(Maybe&lt;"+ShowType.sShowType(x.dtd)+"&gt; xs){}";}
  public String visit(DTDSeq x){
    StringBuffer result = new StringBuffer("public @Constr void Con(");
    boolean first = true;
    for (DTDDef dtd :x.seqParts){
      if (!first) result.append(","); 
      final String typeName = ShowType.sShowType(dtd);
      result.append(typeName+" the"+ShowType.typeToIdent(typeName));

      first=false;
    }
    result.append("){}");
    return result.toString();
  }
  public String visit(DTDChoice x){
    StringBuffer result = new StringBuffer();
    for (DTDDef dtd :x.choiceParts){
      String typeName = ShowType.sShowType(dtd);
      final String varName = ShowType.typeToIdent(typeName);

      result.append("\n  public @Constr void C"+elementName+varName
                             +"("+typeName+" the"+varName+"){}");
    }
    return result.toString();
  }

  public static String generateADT(String element,DTDDef def){
   return ((DTDDefAdt)def).welcome(new GenerateADT(element));}

  public static void  generateADT
     (String paket,String path,List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; xs){
    try {
      for (Tuple3&lt;Boolean,String,DTDDef&gt;x:xs){
        Writer out = new FileWriter(path+"/"+x.e2+".java");
        out.write("package "+paket+";\n");
        out.write("import java.util.List;\n");
        out.write("import name.panitz.crempel.util.Maybe;\n");
        out.write("import name.panitz.adt.*;\n");
        out.write("public @Data class "+x.e2+"{\n");
        out.write(generateADT(x.e2,x.e3));
        out.write("}");
        out.close();
       }
      }catch (Exception e){e.printStackTrace();}
  }
}</pre>
<h3>3.3.4. Generation of parser code</h3>
<pre>package name.panitz.crempel.util.xml.dtd;

import name.panitz.crempel.util.xml.dtd.tree.*;
import name.panitz.crempel.util.*;
//import name.panitz.crempel.util.adt.*;
import java.util.List;
import java.util.ArrayList;
import java.io.Writer;
import java.io.StringWriter;
import java.io.IOException;

public class ParserCode extends DTDDefVisitor&lt;String&gt;{
  final String elementName;
  public ParserCode(String e){elementName=e;}

  public String visit(DTDPCData x){return "new PCData()";}
  public String visit(DTDTagName x){return "getV"+x.tagName+"()";}
  public String visit(DTDEmpty x){return "new Return(null)";}
  public String visit(DTDAny x){return null;}
  public String visit(DTDPlus x){return parserCode(x.dtd)+".plus()";}
  public String visit(DTDStar x){return parserCode(x.dtd)+".star()";}
  public String visit(DTDQuery x){return parserCode(x.dtd)+".query()";}
  public String visit(DTDSeq x){
    StringBuffer result = new StringBuffer();
    boolean first = true;
    for (DTDDef dtd:(List&lt;DTDDef&gt;) x.seqParts){
      if (!first){result.append(".seq(");}
      result.append(parserCode(dtd));
      if (!first){result.append(")");}
      first=false;
    }
    return result.toString();
  }

  public String visit(DTDChoice x){
    final List&lt;DTDDef&gt; xs =  x.choiceParts;
    if (xs.size()==1) {
      final DTDDef ch = xs.get(0);
      final String s  = parserCode(ch);
      return s;
    }
    StringBuffer result = new StringBuffer();
    boolean first = true;
    for (DTDDef dtd:xs){
      final String argType = ShowType.sShowType(dtd);
      final String resType = elementName;
      if (!first){result.append(".choice(");}
      result.append(parserCode(dtd));
      result.append(".&lt;"+resType+"&gt;map(new Function1&lt;");
      result.append(argType);
      result.append(",");
      result.append(resType);
      result.append("&gt;(){");
      result.append("\n    public "+resType+" eval("+argType+" x){");
   
      String typeName = ShowType.sShowType(dtd);
      final String varName = ShowType.typeToIdent(typeName);
      result.append("\n      return ("+resType+")new C"
             +elementName+varName
             +"(x);");
      result.append("\n    }");
      result.append("\n  })");
      if (!first){result.append(")");}
      first=false;
    }
    return result.toString();
  }

  public String parserCode(DTDDef def){
    return ((DTDDefAdt)def).welcome(this);}

  public static String parserCode(DTDDef def,String n){
   return new ParserCode(n).parserCode(def);}
}</pre>
<pre>package name.panitz.crempel.util.xml.dtd;

import name.panitz.crempel.util.xml.dtd.tree.*;
import name.panitz.crempel.util.*;
//import name.panitz.crempel.util.adt.*;
import java.util.List;
import java.util.ArrayList;
import java.io.Writer;
import java.io.StringWriter;
import java.io.IOException;

public class WriteParser extends DTDDefVisitor&lt;String&gt;{
  final String elementName;
  final boolean isGenerated  ;
  String contentType = null;
  String typeDef = null;
  String fieldName = null;
  String getterName = null;

  public WriteParser(String e,boolean g){elementName=e;isGenerated=g;}

  private void start(DTDDef def,StringBuffer result){
    contentType = ShowType.sShowType(def);
    typeDef = !isGenerated?elementName:contentType;
    fieldName = "v"+elementName;  
    getterName = "getV"+elementName+"()";  

    result.append("\n\n  private Parser&lt;"+typeDef+"&gt; "+fieldName+" = null;"); 
    result.append("\n  public Parser&lt;"+typeDef+"&gt; "+getterName+"{"); 
    result.append("\n    if ("+fieldName+"==null){"); 
    result.append("\n      "+fieldName+" = ");
    if (!isGenerated) {
      result.append("new Element&lt;"+typeDef+"&gt;(\""+typeDef+"\"");
      result.append("\n     ,");
      result.append("new Closure&lt;Parser&lt;"+typeDef+"&gt;&gt;(){public Parser&lt;"+typeDef+"&gt; eval(){return ");      
    }

  }

  private String f(DTDDef def){
    StringBuffer result=new StringBuffer();
    start(def,result);
    result.append(ParserCode.parserCode(def,elementName));
    if (!isGenerated){
      result.append("\n     .&lt;"+typeDef+"&gt;map(new Function1");
      result.append("&lt;"+contentType+","+typeDef+"&gt;(){");
      result.append("\n       public "+typeDef+" eval("+contentType+" x){");
      result.append("\n         return new "+typeDef+"(x);");
      result.append("\n       }");
      result.append("\n     })");
    } 
    end(def,result);
    return result.toString();
  }

  private void end(DTDDef def,StringBuffer result){
    if (!isGenerated){
      result.append("\n;}}//end of closure\n"); 
      result.append(")");     

    }
    result.append(";"); 
    result.append("\n    }"); 
    result.append("\n    return "+fieldName+";"); 
    result.append("\n  }");
  }

  private String startend(DTDDef def){
    StringBuffer result=new StringBuffer();
    start(def,result);
    result.append(ParserCode.parserCode(def,elementName));
    end(def,result);
    return result.toString();
  }

  public String visit(DTDPCData x){return f(x);}
  public String visit(DTDTagName x){return f(x);}
  public String visit(DTDEmpty x){return f(x);}
  public String visit(DTDAny x){return null;}
  public String visit(DTDPlus x){return f(x);}
  public String visit(DTDStar x){return f(x);}
  public String visit(DTDQuery x){return f(x);}
  public String visit(DTDChoice x){return startend(x);}
  public String visit(DTDSeq x){
    StringBuffer result = new StringBuffer();
    start(x,result);
    result.append(ParserCode.parserCode(x,elementName));
    result.append(".map(new Function1&lt;"
                 +ShowType.sShowType(x)+","+elementName+"&gt;(){");
    result.append("\n    public "+elementName);
    result.append(" eval("+ShowType.sShowType(x) +" p){");
    result.append("\n      return new "+elementName);
    unrollPairs(x.seqParts.size(),"p",result);
    result.append(";");
    result.append("\n    }");
    result.append("\n  }");
    result.append(")");
    end(x,result);
    return result.toString();
  }

  private void unrollPairs(int i,String var,StringBuffer r){
    String c = var;
    String result="";
    for (Integer j :new FromTo(2,i)){
       result=","+c+".e2"+result;
       c= c+".e1";
    }
    result=c+result;
    r.append("(");
    r.append(result);
    r.append(")");
  }

  public static String writeParser
                      (DTDDef def,String n,boolean isGenerated){
    return new WriteParser(n,isGenerated).writeParser(def);}

  public  String writeParser(DTDDef def){
    return ((DTDDefAdt)def).welcome(this);}
}</pre>
<h3>3.3.5. Flattening of a DTD definition</h3>
<pre>package name.panitz.crempel.util.xml.dtd;
import name.panitz.crempel.util.xml.dtd.tree.DTDDef;
import name.panitz.crempel.util.Tuple3;
import name.panitz.crempel.util.Tuple2;
import java.util.List;
import java.util.ArrayList;


public class FlattenResult
   extends Tuple2&lt;DTDDef,List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;&gt;{
  public FlattenResult(DTDDef dtd,List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; es){
    super(dtd,es);
  }

  public FlattenResult(DTDDef dtd){
    super(dtd,new ArrayList&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;() );
  }
}</pre>
<pre>package name.panitz.crempel.util.xml.dtd;
import name.panitz.crempel.util.xml.dtd.IsAtomic.*;
import name.panitz.crempel.util.xml.dtd.tree.*;
import name.panitz.crempel.util.Tuple3;
import name.panitz.crempel.util.Tuple2;
import name.panitz.crempel.util.Function1;
import java.util.List;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Comparator;

public class DTDDefFlatten extends DTDDefVisitor&lt;FlattenResult&gt;{
  final String elementName;
  final boolean isGenerated;
  private int counter = 0;
  private String getNextName(){
    counter=counter+1;
    return elementName+"_"+counter;
  }

  public DTDDefFlatten(boolean g,String n){elementName=n;isGenerated=g;}

  public FlattenResult visit(DTDPCData x){
    return single(x);}
  public FlattenResult visit(DTDTagName x){
    return single(x);}
  public FlattenResult visit(DTDEmpty x){
    return single(x);}
  public FlattenResult visit(DTDAny x){
    return single(x);}
  public FlattenResult visit(DTDPlus x){
    if (IsAtomic.isAtomic(x.dtd)) return single(x);
    return flattenModified(elementName,x.dtd
          ,new Function1&lt;DTDDef,DTDDef&gt;(){
             public DTDDef eval(DTDDef dtd){return new DTDPlus(dtd);}
           });
  }
  public FlattenResult visit(DTDStar x){
    if (IsAtomic.isAtomic(x.dtd)) return single(x);
    return 
     flattenModified(elementName,x.dtd
          ,new Function1&lt;DTDDef,DTDDef&gt;(){
             public DTDDef eval(DTDDef dtd){return new DTDStar(dtd);}
           });
  }
  public FlattenResult visit(DTDQuery x){
    if (IsAtomic.isAtomic(x.dtd)) return single(x);
    return flattenModified(elementName,x.dtd
          ,new Function1&lt;DTDDef,DTDDef&gt;(){
             public DTDDef eval(DTDDef dtd){return new DTDQuery(dtd);}
           });
  }
  public FlattenResult visit(DTDSeq x){
    return flattenPartList(x.seqParts
          ,new Function1&lt;List&lt;DTDDef&gt;,DTDDef&gt;(){
             public DTDDef eval(List&lt;DTDDef&gt; dtds){
               return new DTDSeq(dtds);}
           });
  }
  public FlattenResult visit(DTDChoice x){
    return flattenPartList(x.choiceParts
          ,new Function1&lt;List&lt;DTDDef&gt;,DTDDef&gt;(){
             public DTDDef eval(List&lt;DTDDef&gt; dtds){
//System.out.println("the new choice"+dtds);
               return new DTDChoice(dtds);}
           });
   }

  private FlattenResult single(DTDDef x){return new FlattenResult(x);}

  private FlattenResult flattenModified
          (final String orgElem,DTDDef content
          ,Function1&lt;DTDDef,DTDDef&gt; constr){
    List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; result 
     = new ArrayList&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;();
    if (needsNewElement(content)){
//    System.out.println("owo needs new element: "+content );
      final String newElemName
        = ShowType.typeToIdent(ShowType.sShowType(content));

      result.add(new Tuple3&lt;Boolean,String,DTDDef&gt;
         (true,newElemName,content));
      return new FlattenResult
                (constr.eval(new DTDTagName(newElemName)),result);
    } 
//    System.out.println("does not need new element");
    FlattenResult innerRes  = flatten(content);
//    System.out.println(innerRes);
    return new FlattenResult(constr.eval(innerRes.e1),innerRes.e2);
  }

  private FlattenResult flattenPartList
      (List&lt;DTDDef&gt; parts,Function1&lt;List&lt;DTDDef&gt;,DTDDef&gt; constr){
    final List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; result 
      = new ArrayList&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;();
    if (parts.size()==1) {return single(parts.get(0));}

    List&lt;DTDDef&gt; newParts = new ArrayList&lt;DTDDef&gt;();    
    for (DTDDef part:parts){
      if (IsAtomic.isAtomic(part)) {//System.out.println("atomic part:"+part);
            newParts.add(part);}
      else if (needsNewElement(part)){
        final String newElemName
          = ShowType.typeToIdent(ShowType.sShowType(part));
        result.add(new Tuple3&lt;Boolean,String,DTDDef&gt;
             (true,newElemName,part));
        newParts.add(new DTDTagName(newElemName));
      }else{
        FlattenResult innerRes  = flatten(part);
        newParts.add(innerRes.e1);
        result.addAll(innerRes.e2);
      }
    } 
    return new FlattenResult(constr.eval(newParts),result);
  }

  static private boolean needsNewElement(DTDDef d){
    return 
     (d instanceof DTDSeq &amp;&amp; ((DTDSeq)d).seqParts.size()&gt;1)
            ||
     (d instanceof DTDChoice &amp;&amp;((DTDChoice)d).choiceParts.size()&gt;1);
  }

  static public List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; 
       flattenDefList(List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; defs){
    boolean changed = true;
    List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; result = defs;
    while (changed){
      Tuple2&lt;Boolean,List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;&gt; once
        = flattenDefListOnce(result);
      changed=once.e1;
      result=once.e2;
    } 

    TreeSet&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; withoutDups
      = new TreeSet&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;(
         new Comparator&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;(){
           public int compare(Tuple3&lt;Boolean,String,DTDDef&gt; o1
                             ,Tuple3&lt;Boolean,String,DTDDef&gt; o2){
              return o1.e2.compareTo(o2.e2);
           }
         });
    withoutDups.addAll(result); 

    result = new ArrayList&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; ();
    result.addAll(withoutDups);
    return result;
  }

  private static Tuple2&lt;Boolean,List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;&gt; 
       flattenDefListOnce(List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; defs){

    final List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; result
     = new ArrayList&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;();

    boolean changed = false;

    for (Tuple3&lt;Boolean,String,DTDDef&gt; def:defs){
      final FlattenResult singleResult
        = new DTDDefFlatten(def.e1,def.e2).flatten(def.e3);
      changed=changed||singleResult.e2.size()&gt;0;
      result.addAll(singleResult.e2);
      result.add(
       new Tuple3&lt;Boolean,String,DTDDef&gt;(
         singleResult.e2.isEmpty()&amp;&amp;def.e1,def.e2,singleResult.e1));
    }
    return new Tuple2&lt;Boolean,List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;&gt;
                  (changed,result); 
  }

  public static FlattenResult flatten(DTDDef def,String n){
   return new DTDDefFlatten(false,n).flatten(def);}

  public  FlattenResult flatten(DTDDef def){
   return ((DTDDefAdt)def).welcome(this);}
}

</pre>
<pre>package name.panitz.crempel.util.xml.dtd;

import name.panitz.crempel.util.xml.dtd.tree.*;

public class IsAtomic extends DTDDefVisitor&lt;Boolean&gt;{
  public Boolean visit(DTDPCData x){return true;}
  public Boolean visit(DTDTagName x){return true;}
  public Boolean visit(DTDEmpty x){return true;}
  public Boolean visit(DTDAny x){return true;}
  public Boolean visit(DTDPlus x){return isAtomic(x.dtd);}
  public Boolean visit(DTDStar x){return isAtomic(x.dtd);}
  public Boolean visit(DTDQuery x){return isAtomic(x.dtd);}
  public Boolean visit(DTDSeq x){return false;}
  public Boolean visit(DTDChoice x){return false;}

  public static Boolean isAtomic(DTDDef def ){
   return ((DTDDefAdt)def).welcome(new IsAtomic());}
}</pre>
<h3>3.3.6. Main generation class</h3>
<pre>package name.panitz.crempel.util.xml.dtd;

import name.panitz.crempel.util.xml.dtd.tree.*;
import java.util.List;
import java.util.ArrayList;
import java.io.*;
import name.panitz.crempel.util.*;

public class GenerateClassesForDTD{
  public static void generateAll
     (String paket,String path,String n,List&lt;Tuple2&lt;String,DTDDef&gt;&gt;dtds){
    List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; xs
      = new ArrayList&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;();
    for (Tuple2&lt;String,DTDDef&gt; t:dtds)
      xs.add(new Tuple3&lt;Boolean,String,DTDDef&gt;(false,t.e1,t.e2));

    xs = DTDDefFlatten.flattenDefList(xs);

    System.out.println("vereinfacht und flachgemacht");
    for (Tuple3&lt;Boolean,String,DTDDef&gt; t:xs){
      System.out.println(t.e2);
      System.out.println(t.e3);
      System.out.println("");
    }
    
    final String parserType = dtds.get(0).e1;
    try{
      Writer out = new FileWriter(path+"/"+n+"Parser"+".java");
      out.write("package "+paket+";\n");

      out.write("import name.panitz.crempel.util.xml.parslib.*;\n");
      out.write("import name.panitz.crempel.util.*;\n");
      out.write("import java.util.*;\n");
      out.write("import org.w3c.dom.Node;\n\n");

      out.write("public class "+n+"Parser ");
      out.write("extends AbstractParser&lt;"+parserType+"&gt;{\n");

      out.write("public ParseResult&lt;"+parserType+"&gt; ");
      out.write("parse(List&lt;Node&gt; xs){");
      out.write("  return getV"+parserType+"().parse(xs);}\n\n");

      for (Tuple3&lt;Boolean,String,DTDDef&gt; x :xs)
        out.write(WriteParser.writeParser(x.e3,x.e2,x.e1));

      out.write("}");  
      out.close();  
    }catch (IOException e){e.printStackTrace();}
    GenerateADT.generateADT(paket,path,xs);
  }             
}</pre>
<h3>3.3.7. Main generator class</h3>
<pre>package name.panitz.crempel.util.xml.dtd.parser;

import java.io.*;
import java.util.*;
import name.panitz.crempel.util.*;
import name.panitz.crempel.util.xml.dtd.tree.*;
import name.panitz.crempel.util.xml.dtd.*;

public class MainDTDParse {
  public static void main(String [] args){
    try{
      final String dtdFileName = args[0];
      final String packageName = args[1].replace('/','.');

      File f = new File(dtdFileName);  
      final String path
          = f.getParentFile()==null?".":f.getParentFile().getPath();

      final DTD parser = new DTD(new FileReader(f));

      final Tuple3&lt;List&lt;Tuple2&lt;String,DTDDef&gt;&gt;,List&lt;String&gt;,String&gt; dtd
        = parser.dtd();

      for (Tuple2&lt;String,DTDDef&gt; t:dtd.e1){
        System.out.println(t.e1);
        System.out.println(t.e2);
        System.out.println("");
      }
 
      GenerateClassesForDTD
          .generateAll(packageName,path,dtd.e3,dtd.e1);
   }catch (Exception _){_.printStackTrace();System.out.println(_);} 
  }
}</pre>sep@linux:~/fh/xmlparslib/examples/src/name/panitz/album&gt; java -c
lasspath /home/sep/fh/xmlparslib/examples/classes/:/home/sep/fh/java1.5/exa
mples/classes/:/home/sep/fh/adt/examples/classes/ name.panitz.crempel.util.
xml.dtd.parser.MainDTDParse album.dtd name.panitz.album
package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class Choice_String_author{

  CChoice_String_authorString(String theString);
  CChoice_String_authorauthor(author theauthor);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class Choice_lp_cd_mc{

  CChoice_lp_cd_mclp(lp thelp);
  CChoice_lp_cd_mccd(cd thecd);
  CChoice_lp_cd_mcmc(mc themc);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class artist{
Con(String pcdata);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class author{
Con(String pcdata);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class cd{
Con(title thetitle,artist theartist,Maybe&lt;recordingyear&gt; 
 theMaybe_recordingyear_,List&lt;track&gt; theList_track_,List&lt;note&gt; theList_note_);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class lp{
Con(title thetitle,artist theartist,Maybe&lt;recordingyear&gt; 
 theMaybe_recordingyear_,List&lt;track&gt; theList_track_,List&lt;note&gt; theList_note_);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class mc{
Con(title thetitle,artist theartist,Maybe&lt;recordingyear&gt; 
 theMaybe_recordingyear_,List&lt;track&gt; theList_track_,List&lt;note&gt; theList_note_);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class musiccollection{
Con(List&lt;Choice_lp_cd_mc&gt; xs);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class note{
Con(List&lt;Choice_String_author&gt; xs);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class recordingyear{
Con(String pcdata);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class timing{
Con(String pcdata);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class title{
Con(String pcdata);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class track{
Con(title thetitle,Maybe&lt;timing&gt; theMaybe_timing_);}

sep@linux:~/fh/xmlparslib/examples/src/name/panitz/album&gt; ls
CChoice_String_authorString.java    lpVisitor.java
CChoice_String_authorauthor.java    mc.java
CChoice_lp_cd_mccd.java             mcVisitable.java
CChoice_lp_cd_mclp.java             mcVisitor.java
CChoice_lp_cd_mcmc.java             musiccollection.java
Choice_String_author.java           musiccollectionParser.java
Choice_String_authorVisitable.java  musiccollectionVisitable.java
Choice_String_authorVisitor.java    musiccollectionVisitor.java
Choice_lp_cd_mc.java                note.java
Choice_lp_cd_mcVisitable.java       noteVisitable.java
Choice_lp_cd_mcVisitor.java         noteVisitor.java
album.dtd                           recordingyear.java
artist.java                         recordingyearVisitable.java
artistVisitable.java                recordingyearVisitor.java
artistVisitor.java                  timing.java
author.java                         timingVisitable.java
authorVisitable.java                timingVisitor.java
authorVisitor.java                  title.java
cd.java                             titleVisitable.java
cdVisitable.java                    titleVisitor.java
cdVisitor.java                      track.java
lp.java                             trackVisitable.java
lpVisitable.java                    trackVisitor.java
sep@linux:~/fh/xmlparslib/examples/src/name/panitz/album&gt;<h3>3.3.8. JaxB</h3>sep@linux:~/fh/xmlparslib/&gt; ~/jwsdp-1.3/jaxb/bin/xjc.sh -dtd
  album.dtd -p name.panitz.jaxb.album
parsing a schema...
compiling a schema...
name/panitz/jaxb/album/impl/runtime/GrammarInfo.java
name/panitz/jaxb/album/impl/runtime/AbstractUnmarshallingEventHandlerImpl.java
name/panitz/jaxb/album/impl/runtime/PrefixCallback.java
name/panitz/jaxb/album/impl/runtime/Discarder.java
name/panitz/jaxb/album/impl/runtime/ValidatableObject.java
name/panitz/jaxb/album/impl/runtime/SAXUnmarshallerHandlerImpl.java
name/panitz/jaxb/album/impl/runtime/ContentHandlerAdaptor.java
name/panitz/jaxb/album/impl/runtime/ValidatorImpl.java
name/panitz/jaxb/album/impl/runtime/UnmarshallerImpl.java
name/panitz/jaxb/album/impl/runtime/GrammarInfoFacade.java
name/panitz/jaxb/album/impl/runtime/XMLSerializable.java
name/panitz/jaxb/album/impl/runtime/UnmarshallingEventHandler.java
name/panitz/jaxb/album/impl/runtime/DefaultJAXBContextImpl.java
name/panitz/jaxb/album/impl/runtime/SAXMarshaller.java
name/panitz/jaxb/album/impl/runtime/GrammarInfoImpl.java
name/panitz/jaxb/album/impl/runtime/MSVValidator.java
name/panitz/jaxb/album/impl/runtime/UnmarshallableObject.java
name/panitz/jaxb/album/impl/runtime/SAXUnmarshallerHandler.java
name/panitz/jaxb/album/impl/runtime/ErrorHandlerAdaptor.java
name/panitz/jaxb/album/impl/runtime/NamespaceContext2.java
name/panitz/jaxb/album/impl/runtime/Util.java
name/panitz/jaxb/album/impl/runtime/UnmarshallingEventHandlerAdaptor.java
name/panitz/jaxb/album/impl/runtime/ValidationContext.java
name/panitz/jaxb/album/impl/runtime/ValidatingUnmarshaller.java
name/panitz/jaxb/album/impl/runtime/MarshallerImpl.java
name/panitz/jaxb/album/impl/runtime/XMLSerializer.java
name/panitz/jaxb/album/impl/runtime/UnmarshallingContext.java
name/panitz/jaxb/album/impl/runtime/NamespaceContextImpl.java
name/panitz/jaxb/album/impl/ArtistImpl.java
name/panitz/jaxb/album/impl/AuthorImpl.java
name/panitz/jaxb/album/impl/CdImpl.java
name/panitz/jaxb/album/impl/JAXBVersion.java
name/panitz/jaxb/album/impl/LpImpl.java
name/panitz/jaxb/album/impl/McImpl.java
name/panitz/jaxb/album/impl/MusiccollectionImpl.java
name/panitz/jaxb/album/impl/NoteImpl.java
name/panitz/jaxb/album/impl/RecordingyearImpl.java
name/panitz/jaxb/album/impl/TimingImpl.java
name/panitz/jaxb/album/impl/TitleImpl.java
name/panitz/jaxb/album/impl/TrackImpl.java
name/panitz/jaxb/album/Artist.java
name/panitz/jaxb/album/Author.java
name/panitz/jaxb/album/Cd.java
name/panitz/jaxb/album/Lp.java
name/panitz/jaxb/album/Mc.java
name/panitz/jaxb/album/Musiccollection.java
name/panitz/jaxb/album/Note.java
name/panitz/jaxb/album/ObjectFactory.java
name/panitz/jaxb/album/Recordingyear.java
name/panitz/jaxb/album/Timing.java
name/panitz/jaxb/album/Title.java
name/panitz/jaxb/album/Track.java
name/panitz/jaxb/album/jaxb.properties
name/panitz/jaxb/album/bgm.ser
sep@linux:~/fh/xmlparslib/examples/src/name/panitz/album&gt;<h2>3.4. Conclusion</h2>DTDJaxB (JavaTM Architecture for XML Binding)JaxB<h2>3.5. Javacc input file for DTD parser</h2>javacc<pre>options {STATIC=false;}

PARSER_BEGIN(DTD)
package name.panitz.crempel.util.xml.dtd.parser;

import name.panitz.crempel.util.*;
import name.panitz.crempel.util.xml.dtd.tree.*;
import java.util.List;
import java.util.ArrayList;
import java.io.FileReader;

public class DTD {}
PARSER_END(DTD)

TOKEN :
{&lt;ELEMENTDEC: "&lt;!ELEMENT"&gt;
|&lt;DOCTYPE:    "&lt;!DOCTYPE"&gt; 
|&lt;ATTLIST:    "&lt;!ATTLIST"&gt; 
|&lt;REQUIRED:   "#REQUIRED"&gt; 
|&lt;IMPLIED:    "#IMPLIED"&gt; 
|&lt;EMPTY: "EMPTY"&gt;
|&lt;PCDATA: "#PCDATA"&gt;
|&lt;CDATA: "CDATA"&gt;
|&lt;ANY: "ANY"&gt;
|&lt;SYSTEM: "SYSTEM"&gt;
|&lt;PUBLIC: "PUBLIC"&gt;
|&lt;GR: "&gt;"&gt;
|&lt;QMARK: "?"&gt;
|&lt;PLUS: "+"&gt;
|&lt;STAR: "*"&gt;
|&lt;#NameStartCar: [":","A"-"Z","_","a"-"z"
                 ,"\u00C0"-"\u00D6"
                 ,"\u00D8"-"\u00F6"
                 ,"\u00F8"-"\u02FF"
                 ,"\u0370"-"\u037D"
                 ,"\u037F"-"\u1FFF"
                 ,"\u200C"-"\u200D"
                 ,"\u2070"-"\u218F"
                 ,"\u2C00"-"\u2FEF"
                 ,"\u3001"-"\uD7FF"
                 ,"\uF900"-"\uFDCF"
                 ,"\uFDF0"-"\uFFFD"]&gt;
//                 ,"\u10000"-"\uEFFFF"]&gt;
|&lt;#InnerNameChar: ["-", ".","0"-"9", "\u00B7" 
                  ,"\u0300"-"\u036F"
                  ,"\u203F"-"\u2040"]&gt;
|&lt;#NameChar: &lt;InnerNameChar&gt;|&lt;NameStartCar&gt;&gt;
|&lt;Name: &lt;NameStartCar&gt; (&lt;NameChar&gt;)* &gt;

|&lt;#ALPHA:       ["a"-"z","A"-"Z","_","."]&gt;
|&lt;#NUM:	        ["0"-"9"]&gt;
|&lt;#ALPHANUM:    &lt;ALPHA&gt; | &lt;NUM&gt;&gt;
|&lt;EQ: "="&gt;
|&lt;BAR: "|"&gt;
|&lt;LPAR: "("&gt;
|&lt;RPAR: ")"&gt;
|&lt;LBRACKET: "{"&gt;
|&lt;RBRACKET: "}"&gt;
|&lt;LSQBRACKET: "["&gt;
|&lt;RSQBRACKET: "]"&gt;
|&lt;LE: "&lt;"&gt;
|&lt;SEMICOLON: ";"&gt;
|&lt;COMMA: ","&gt;
|&lt;QUOTE: "\""&gt;
|&lt;SINGLEQUOTE: "'"&gt;
}

SKIP :
{&lt; ["\u0020","\t","\r","\n"] &gt;}

//"

void externalID():
{}
{&lt;SYSTEM&gt; systemLiteral()
 |&lt;PUBLIC&gt; systemLiteral() systemLiteral()
}

void systemLiteral():{}
{&lt;QUOTE&gt;&lt;Name&gt;&lt;QUOTE&gt;|&lt;SINGLEQUOTE&gt;&lt;Name&gt;&lt;SINGLEQUOTE&gt;
}

Tuple3&lt;List&lt;Tuple2&lt;String,DTDDef&gt;&gt;,List&lt;String&gt;,String&gt; dtd():
{ 
  Token nameToken;
  List&lt;Tuple2&lt;String,DTDDef&gt;&gt; els = new ArrayList&lt;Tuple2&lt;String,DTDDef&gt;&gt;();
  List&lt;String&gt; atts = new ArrayList&lt;String&gt;();
  Tuple2&lt;String,DTDDef&gt; el;
}
{&lt;DOCTYPE&gt; nameToken=&lt;Name&gt; externalID() &lt;LSQBRACKET&gt;

   (el=elementdecl(){ els.add(el);}
   |AttlistDecl())* 
 &lt;RSQBRACKET&gt;&lt;GR&gt;
  {return new Tuple3&lt;List&lt;Tuple2&lt;String,DTDDef&gt;&gt;,List&lt;String&gt;,String&gt;
                (els,atts,nameToken.toString());}
}

Tuple2&lt;String,DTDDef&gt; elementdecl():
{Token nameToken;
 DTDDef content;}
{&lt;ELEMENTDEC&gt; nameToken=&lt;Name&gt;  content=contentspec()  &lt;GR&gt;
  {return new Tuple2&lt;String,DTDDef&gt;(nameToken.toString(),content);}
}


DTDDef contentspec():
{DTDDef result;}
{  &lt;EMPTY&gt;{result=new DTDEmpty();} 
 | &lt;ANY&gt;{result=new DTDAny();}
 | (&lt;LPAR&gt;(result=Mixed()
          |result=children()))
 { return result;}
}

DTDDef children():
{ List&lt;DTDDef&gt; cps;
  DTDDef cp;
  Modifier mod = Modifier.none;
  boolean wasChoice = true;
}
{cp=cp()
  (cps=choice()| cps=seq(){wasChoice=false;})
   {cps.add(0,cp);} 
   &lt;RPAR&gt;(&lt;QMARK&gt;{mod=Modifier.query;}
     |&lt;STAR&gt;{mod=Modifier.star;}
     |&lt;PLUS&gt;{mod=Modifier.plus;})?
  {DTDDef result=wasChoice?ParserAux.createDTDChoice(cps)
                          :ParserAux.createDTDSeq(cps);
   return mod.mkDTDDef(result);
  }
}

List&lt;DTDDef&gt; choice():
{ DTDDef cp;
  List&lt;DTDDef&gt; result = new ArrayList&lt;DTDDef&gt;();}
{(&lt;BAR&gt; cp=cp() {result.add(cp);} )+
  {return result;}
}

DTDDef cp():
{ Token nameToken=null;
  List&lt;DTDDef&gt; cps=new ArrayList&lt;DTDDef&gt;();
  DTDDef cp;
  Modifier mod=Modifier.none;
  boolean wasChoice = true;
  boolean wasTagName = false;
}
{((nameToken = &lt;Name&gt;{wasTagName=true;})
 |(&lt;LPAR&gt;cp=cp()
         (cps=choice()|cps=seq(){wasChoice=false;})
    {cps.add(0,cp);}
   &lt;RPAR&gt;
  )
 ) 
     (&lt;QMARK&gt;{mod=Modifier.query;}
     |&lt;STAR&gt;{mod=Modifier.star;}
     |&lt;PLUS&gt;{mod=Modifier.plus;})?
{
 DTDDef result;
 if (wasTagName) result=new DTDTagName(nameToken.toString());
 else result=wasChoice?ParserAux.createDTDChoice(cps)
                      :ParserAux.createDTDSeq(cps);
 return mod.mkDTDDef(result);
}
}

List&lt;DTDDef&gt; seq():
{  List&lt;DTDDef&gt; result = new ArrayList&lt;DTDDef&gt;();
   DTDDef cp;
}
{(&lt;COMMA&gt; cp=cp(){result.add(cp);} )*
  {return result;}
}

DTDDef Mixed():
{Token nameToken;
 List&lt;DTDDef&gt; xs = new ArrayList&lt;DTDDef&gt;();
 Modifier mod=Modifier.none;
}
{  &lt;PCDATA&gt; {xs.add(new DTDPCData());}
  ((&lt;BAR&gt; nameToken=&lt;Name&gt; 
    {xs.add(new DTDTagName(nameToken.toString()));}
   )* &lt;RPAR&gt;(&lt;STAR&gt;{mod=Modifier.star;})?)
{return mod.mkDTDDef(ParserAux.createDTDChoice(xs));}

}

void AttlistDecl():
{Token nameToken;}
{&lt;ATTLIST&gt; nameToken=&lt;Name&gt; (AttDef() )*
{}}

void AttDef():
{Token nameToken;
 boolean isRequired;}
{nameToken=&lt;Name&gt; AttType() isRequired=DefaultDecl()
  {}
}

void AttType():
{}
{ StringType()}//|TokenizedType()|EnumeratedType()}

void StringType():
{}
{&lt;CDATA&gt;}


boolean DefaultDecl():
{ boolean isRequired=false;}

{(&lt;REQUIRED&gt;{isRequired=true;} | &lt;IMPLIED&gt;)
//| (('#FIXED' S)? AttValue)
{return isRequired;}
}</pre>
<pre>package name.panitz.crempel.util.xml.dtd.parser;

import name.panitz.crempel.util.xml.dtd.tree.*;
import java.util.List;

public class ParserAux{
  static public DTDDef createDTDSeq(List&lt;DTDDef&gt; xs){
    return new DTDSeq(xs);
  }
  static public DTDDef createDTDChoice(List&lt;DTDDef&gt; xs){
    return new DTDChoice(xs);
  }  
}</pre>
<pre>package name.panitz.crempel.util.xml.dtd.tree;

public enum Modifier { none, star, plus, query;

  public String toString(){
    switch(this) {
          case star:   return "*";
          case plus:   return "+";
          case query:  return "?";
    }
    return "";
  }

  public DTDDef mkDTDDef(DTDDef dtd){
    switch(this) {
      case star:   return new DTDStar(dtd);
      case plus:   return new DTDPlus(dtd);
      case query:  return new DTDQuery(dtd);
    }
    return dtd;
  }
}</pre>
    
<h1>4. Hilfklasssen zu Swing</h1>
<pre>package name.panitz.swing.threadTest;
import javax.swing.SwingUtilities;

/**
 * This is the 3rd version of SwingWorker (also known as
 * SwingWorker 3), an abstract class that you subclass to
 * perform GUI-related work in a dedicated thread.  For
 * instructions on using this class, see:
 * 
 * http://java.sun.com/docs/books/tutorial/uiswing/misc/threads.html
 *
 * Note that the API changed slightly in the 3rd version:
 * You must now invoke start() on the SwingWorker after
 * creating it.
 */
public abstract class SwingWorker {
    private Object value;  // see getValue(), setValue()
    private Thread thread;

    /** 
     * Class to maintain reference to current worker thread
     * under separate synchronization control.
     */
    private static class ThreadVar {
        private Thread thread;
        ThreadVar(Thread t) { thread = t; }
        synchronized Thread get() { return thread; }
        synchronized void clear() { thread = null; }
    }

    private ThreadVar threadVar;

    /** 
     * Get the value produced by the worker thread, or null if it 
     * hasn't been constructed yet.
     */
    protected synchronized Object getValue() { 
        return value; 
    }

    /** 
     * Set the value produced by worker thread 
     */
    private synchronized void setValue(Object x) { 
        value = x; 
    }

    /** 
     * Compute the value to be returned by the &lt;code&gt;get&lt;/code&gt; method. 
     */
    public abstract Object construct();

    /**
     * Called on the event dispatching thread (not on the worker thread)
     * after the &lt;code&gt;construct&lt;/code&gt; method has returned.
     */
    public void finished() {
    }

    /**
     * A new method that interrupts the worker thread.  Call this method
     * to force the worker to stop what it's doing.
     */
    public void interrupt() {
        Thread t = threadVar.get();
        if (t != null) {
            t.interrupt();
        }
        threadVar.clear();
    }

    /**
     * Return the value created by the &lt;code&gt;construct&lt;/code&gt; method.  
     * Returns null if either the constructing thread or the current
     * thread was interrupted before a value was produced.
     * 
     * @return the value created by the &lt;code&gt;construct&lt;/code&gt; method
     */
    public Object get() {
        while (true) {  
            Thread t = threadVar.get();
            if (t == null) {
                return getValue();
            }
            try {
                t.join();
            }
            catch (InterruptedException e) {
                Thread.currentThread().interrupt(); // propagate
                return null;
            }
        }
    }


    /**
     * Start a thread that will call the &lt;code&gt;construct&lt;/code&gt; method
     * and then exit.
     */
    public SwingWorker() {
        final Runnable doFinished = new Runnable() {
           public void run() { finished(); }
        };

        Runnable doConstruct = new Runnable() { 
            public void run() {
                try {
                    setValue(construct());
                }
                finally {
                    threadVar.clear();
                }

                SwingUtilities.invokeLater(doFinished);
            }
        };

        Thread t = new Thread(doConstruct);
        threadVar = new ThreadVar(t);
    }

    /**
     * Start the worker thread.
     */
    public void start() {
        Thread t = threadVar.get();
        if (t != null) {
            t.start();
        }
    }
}</pre>
    
<h1>5. Fragen und Antworten als Lernhilfe</h1>
        
          Ist Java eine kompilierte oder interpretierte Sprache?
          Im Prinzip beides: Ein Compiler &uuml;bersetzt den Quelltext in
.class-Dateien, die Code f&uuml;r eine virtuelle Maschine enthalten. Ein
Interpreter ist in der Lage diesen Code auszuf&uuml;hren. 
        
        
          Wie ist ein Javaprogramm strukturiert?
          Pro Datei eine Klasse (oder Schnittstelle oder Aufz&auml;hlung), die den
Namen der Datei tr&auml;gt.
        
        
          Gibt es einen Pr&auml;prozessor?
          Nein.
        
        
          Gibt es einen Linker?
          Nein, aber die virtuelle Maschine hat einen Klassenlader, der den
Code der einzelnen Klassen bei Bedarf l&auml;dt.
        
        
          Welche Namenskonventionen gibt es?
          Klassennamen beginnen mit einem Gro&szlig;buchstaben, globale Konstanten
sind komplett in Gro&szlig;buchstaben geschrieben. Pakete, Parameter, Variablen
beginnen mit einem Kleinbuchstaben. Bei Bezeichnern aus mehreren W&ouml;rter f&auml;ngt
das n&auml;chste Wort immer mit einem Gro&szlig;buchstaben an.
        
        
          Ist Java statisch getypt?
          Ja, der Compiler &uuml;berpr&uuml;ft, ob das Programm korrekt 
getypt ist. 
        
        
          Gibt es auch dynamische Typ&uuml;berpr&uuml;fung zur Laufzeit?
          Ja, zum einem verifiziert die virtuelle Maschine noch einmal
den Code, zum anderen bewirkt eine Typzusicherung (cast) eine
Laufzeittyp&uuml;berpr&uuml;fung. 
        
        
          Kann ich sicherstellen, da&szlig; die Typzusicherung w&auml;hrend der Laufzeit
nicht fehlschl&auml;gt.
          Ja, indem vor der Typzusicherung der Test mit instanceof
gemacht wird.
        
        
          Wie schreibt man Unterprogramme oder Funktionen?
          Immer innerhalb einer Klasse. Sie werden als Methoden 
bezeichnet.
        
        
          Was sind die Eigenschaften einer Klasse?
          Zum einen die Felder (auch als Attribute) bezeichnet, in denen
Referenzen auf Objekte abgelegt werden k&ouml;nnen. Zum anderen die Methoden und
Konstruktoren.  
        
        
          Was ist das this-Objekt?
          Damit wird das Objekt bezeichnet, in dem sich eine Eigenschaft
befindet. 
        
        
          Was ist Vererbung?
          Jede Klasse hat genau eine Oberklasse, die in 
der extends-Klausel angegeben wird. Objekte k&ouml;nnen alle
Eigenschaften die in ihrer Oberklasse zur Verf&uuml;gung stehen benutzen.
        
        
          Was ist wenn ich keine Oberklasse angebe?
          Dann ist automatisch die Klasse Object die Oberklasse.
        
        
          Was sind Konstruktoren?
          Konstruktoren sind der Code einer Klasse, der beim Erzeugen von neuen
Objekten ausgef&uuml;hrt wird und in der Regel die Felder des Objektes initialisiert.
        
        
          Wie werden Konstruktoren definiert?
          &Auml;hnlich wie Methoden. Sie haben den Namen der Klasse und keinen
R&uuml;ckgabetyp. 
        
        
          Wie werden Konstuktoren aufgerufen?
          Durch das Schl&uuml;sselwort new gefolgt von dem 
Klassennamen.
        
        
          Hat jede Klasse einen Konstruktor?
          Ja.
        
        
          Und wenn ich keinen Konstruktor f&uuml;r meine Klasse schreibe?
          Dann f&uuml;gt Java einen leeren Konstruktor ohne Parameter ein.
        
        
          Was ist der Unterschied zwischen statischen und nicht statischen
Eigenschaften einer Klasse?
          Eine statische Eigenschaft ist nicht an spezielle Objekte
gebunden. Sie hat daher auch kein this-Objekt. Eine statische
Eigenschaft existiert nur einmal f&uuml;r alle Objekte einer
Klasse. Nicht-statische Methoden werden auch als Objektmethoden 
bezeichnet. 
        
        
          Gibt es auch statische Konstruktoren?
          Ja, pro Klasse genau einen, der keine Parameter hat.
        
        
          Kann ich den statischen Konstruktor auch selbst definieren?
          Ja, mit dem Schl&uuml;ssenwort static gefolgt von in geschweiften
Klammern eingeschlossenen Code.
        
        
          Was bedeutet &Uuml;berschreiben von Methoden?
          Methoden, die es in der Oberklasse bereits gibt in einer Unterklasse
neu zu definieren.
        
        
          Kann ich auch Konstruktoren &uuml;berschreiben?
          Nein.
        
        
          Was bezeichnet man als Polymorphie?
          Wenn eine Methode in verschiedenen Unterklassen einer Klasse
&uuml;berschrieben wird.
        
        
          Kann ich in einer &uuml;berschreibenen Methode, die &uuml;berschriebene Methode
aufrufen?
          Ja, indem man das Schl&uuml;sselwort super benutzt und mit einem
Punkt abgetrennt den eigentlichen Methodenaufruf folgen l&auml;&szlig;t.
        
        
          Kann ich Konstruktoren der Oberklasse aufrufen.
          Ja, aber nur im Konstruktor als erste Anweisung. Hier mu&szlig; sogar der
Aufruf eines Konstruktors der Oberklasse stehen. Dieser Aufruf wird durch das
Schl&uuml;sselwort super gefolgt von der Parameterliste gemacht.
        
        
          Was ist, wenn ich im Konstruktor keinen Aufruf an einen Konstruktor der
Oberklasse schreiben. 
          Dann generiert Java den Aufruf eines Konstruktors der Oberklasse ohne
Parameter als erste Anweisung in den Konstruktor. Sollte so ein parameterloser
Konstruktor nicht existieren, dann gibt es allerdings einen 
Folgefehler. 
        
        
          Was ist sp&auml;te Bindung (late binding)?
          Beim Aufruf von Objektmethoden wird immer der Methodencode
ausgef&uuml;hrt, der in der Klasse implementiert wurde, von der das Objekt, auf dem
diese Methode aufgerufen wurde, erzeugt wurde. Es wird also immer
die &uuml;berschreibende Version einer Methode benutzt.
        
        
          Was sind virtuelle Methoden und gibt es sie in Java?
          In C++ werden Methoden, f&uuml;r die sp&auml;te Bindung gew&uuml;nscht ist als
virtuell markiert. In Java funktioniert die sp&auml;te Bindung f&uuml;r alle 
Objektmethoden. 
        
        
          Funktioniert sp&auml;te Bindung auch f&uuml;r Felder?
          Nein.
        
        
          Funktioniert sp&auml;te Bindung auch f&uuml;r statische Methoden?
          Nein.
        
        
          Funktioniert sp&auml;te Bindung auch f&uuml;r Konstruktoren?
          Nein.
        
        
          Was sind &uuml;berladene Methoden? 
          Methoden gleichen Namens in einer Klasse, die sich in Typ/Anzahl der
Parameter unterscheiden.
        
        
          K&ouml;nnen auch Konstruktoren &uuml;berladen werden?
          Ja.
        
        
          Gibt es das Prinzip von sp&auml;ter Bindung auch f&uuml;r die verschiedenen
&uuml;berladenen Versionen einer Methode? 
          Nein! Die Aufl&ouml;sung, welche der &uuml;berladenen Versionen einer Methode
ausgef&uuml;hrt wird, wird bereits statisch vom Compiler vorgenommen und nicht
dynamisch w&auml;hrend der laufzeit.
        
        
          Was sind abstrakte Klassen?
          Klassen, die als abstract deklariert sind. Nur abstrakte
Klassen k&ouml;nnen abstrakte Eigenschaften enthalten.
        
        
          Und was sind abstrakte Eigenschaften?
          Das sind Methoden, die keinen Methodenrumpf haben. 
        
        
          K&ouml;nnen abstrakte Klassen Konstruktoren haben?
          Ja, allerdings k&ouml;nnen von abstrakten Klassen keine Objekte 
mit new erzeugt werden.
        
        
          Wie kann ich dann Objekte einer abstrakten Klassen erzeugen und wozu
haben die dann Konstruktoren?
          Indem Objekte einer nicht abstrakten Unterklasse 
mit new erzeugt werden. Im Konstrukor der Unterklasse wird ein
Konstruktor der abstrakten Oberklasse aufgerufen.
        
        
          Kann eine Klasse mehrere abstrakte Oberklassen haben?
          Nein, auch abstrakte Klassen sind Klassen und es gilt die Regel: jede
Klasse hat genau eine Oberklasse.
        
        
          Kann ich in einer abstrakten Klasse abstrakte Methoden aufrufen?
          Ja, im Rumpf einer nicht-abstrakten Methode k&ouml;nnen bereits abstrakte
Klassen aufgerufen werden.
        
        
          Was sind Schnittstellen?
          Man kann Schnittstellen als abstrakte Klassen ansehen, in denen jeder
Methode abstrakt ist.
        
        
          Warum gibt es dann Schnittstellen?
          Schnittstellen gelten nicht als Klassen. Eine Klasse kann nur eine
Oberklasse haben, aber zus&auml;tzlich mehrere Schnittstellen 
implementieren.
        
        
          Wie wird deklariert, da&szlig; eine Klasse eine Schnitstelle implementiert?
          Durch die implements-Klausel in der Klassendeklaration. In
ihr k&ouml;nnen mehrere Komma getrennte Schnittstellen angegeben werden. 
        
        
          Kann eine Schnittstelle eine Oberklasse haben?
          Nein.
        
        
          Kann eine Schnittstelle weitere Oberschnittstellen haben.
          Ja, diese werden in der extends-Klausel angegeben.
        
        
          Mu&szlig; eine Klasse die eine Schnittstelle implementiert alle Methoden der
Schnittstelle implementieren?
          Im Prinzip ja, jedoch nicht, wenn die Klasse selbst abstrakt ist.
        
        
          Haben Schnittstellen auch Objektfelder?
          Nein! Nur Methoden und statische Felder.
        
        
          Gibt es Zeiger?
          Explizit nicht. Implizit wird au&szlig;er bei Werten primitiver Typen immer
mit Referenzen auf Objekte gearbeitet.
        
        
          Sind alle Daten in Java Objekte?
          Nein, es gibt 8 primitive Typen, deren Daten keine Objekte sind. Es
gibt aber zu jeden dieser 8 primitiven Typen eine Klasse, die die Daten
entsprechend als Objekt speichern.
        
        
          Welches sind die primitiven Typen?
          byte, short, int, long, double, float, char, boolean
        
        
          Sind Strings Objekte?
          Ja, die Klasse String ist eine Klasse wie Du und ich.
        
        
          Sind Reihungen (arrays) Objekte?
          Ja, und sie haben sogar ein Attribut, das ihre L&auml;nge speichert. 
        
        
          Was sind generische Typen?
          Klassen oder Schnittstellen, in denen ein oder mehrere Typen variabel
gehalten sind.
        
        
          Wie erzeugt man Objekte einer generischen Klasse? 
          Indem beim Konstruktoraufruf in spitzen Klammern konkrete Typen f&uuml;r
die Typvariablen angegeben werden.
        
        
          Was passiert, wenn ich f&uuml;r generische Typen die spitzen Klammern bei
der Benutzung weglasse?
          Dann gibt der Compiler eine Warnung und nimmt den allgemeinsten Typ
f&uuml;r die Typvariablen an. Meistens ist das der Typ Object.
        
        
          Was sind generische Methoden?
          Methoden in denen ein oder mehrere Parametertypen variabel gehalten
sind. 
        
        
          Mu&szlig; ich bei der Benutzung von generischen Methoden die konkreten Typen
f&uuml;r die Typvariablen mit angeben?
          Anders als beim Konstruktoraufruf f&uuml;r generische Klassen nicht.
        
        
          Was passiert, wenn ich sie nicht angebe?
          Dann inferriert der Typchecker die konkreten Typen, sofern das
m&ouml;glich ist.
        
        
          Was sind typische Beispiel f&uuml;r generische Typen? 
          Alle Sammlungsklassen und Abbildungsklassen im 
Paket java.util, zB die Klassen ArrayList,LinkedList, HashSet, Vector oder die Schnittstellen List, Map, Set.
        
        
          Wo wir gerade dabei sind. Was sollte ich bei der 
Klasse Vector beachten?
          In 90\% der F&auml;lle ist ein Objekt der 
Klasse ArrayList einem Objekt der 
Klasse Vector vorzuziehen. Vector ist eine sehr alte
Klasse. Ihre Objekte sind synchronisiert, die anderen Sammlungsklassen nicht,
es lassen sich von den anderen Sammlungsklassen allerdings synchronisierte
Kopien machen. Am besten Vector gar nie benutzen.
        
        
          Was ist automatisches Boxing und Unboxing?
          Die Konvertierung von Daten primitiver Typen in Objekte der
korrespondierenden Klassen und umgekehrt wird automatisch 
vorgenommen.
        
        
          Welche zusammengesetzten Befehle gibt es? 
          if, while, for, switch
        
        
          Was hat es mit der besonderen for-Schleife auf sich?
          Es handelt sich um eine sogenannte for-each-Schleife. Syntaktisch
trennt hier ein Doppelpunkt die lokale Schleifenvariable das Sammlungsobjekt. 
        
        
          F&uuml;r welche Objekte kann die for-each-Schleife benutzt werden?
          F&uuml;r alle Objekte, die die Schnittstelle Iterable
implementieren und f&uuml;r Reihungen.
        
        
          Bedeutet das, ich kann die for-each Schleife auch f&uuml;r meine Klassen benutzen?
          Ja, genau, man mu&szlig; nur die Schnittstelle Iterable hierzu implementieren.
        
        
          K&ouml;nnen Operatoren &uuml;berladen oder neu definiert werden?
          Nein.
        
        
          Was sind Ausnahme?
          Objekte von Unterklassen der Klasse Exception. Zus&auml;tzlich
gibt es die Klasse  Error und die gemeinsame KlasseThrowable. 
        
        
          Wozu sind Ausnahmen gut?
          Um in bestimmten Situationen mit einem throw Befehl den
Programmflu&szlig; abzubrechen um eine besondere Ausnahmesituation zu 
signalisieren. 
        
        
          Was f&uuml;r Objekte d&uuml;rfen in eine throw geworfen werden?
          Nur Objekte einer Unterklasse von Throwable.
        
        
          Wie werden geworfene Ausnahme behandelt?
          Indem man sie innerhalb eines try-catch-Konstruktes
wieder abf&auml;ngt.
        
        
          Kann man auf unterschiedliche Ausnahmen in einem catch
unterschiedlich reagieren?
          Ja, einfach mehrere catch untereinanderschreiben. Das als
erstes zutreffende catch ist dann aktiv.
        
        
          Was ist das mit dem finally beim try-catch?
          Hier kann Code angegeben werden, der immer ausgef&uuml;hrt werden soll,
egal ob und welche Ausnahme aufgetreten ist. Dieses ist sinnvoll um eventuell
externe Verbindungen und &auml;hnliches immer sauber zu schlie&szlig;en.
        
        
          Darf man beliebig Ausnahmen werfen?
          Ausnahmen, die nicht in einem catch abgefangen werden m&uuml;ssen
in der throws-Klausel einer Methode deklariert werden.
        
        
          Alle?
          Nein, Ausnahmeobjekte von RuntimeException d&uuml;rfen auch
geworfen werden, wenn sie nicht in der throws-Klausel einer Methode
stehen. 
        
        
          Wozu sind Pakete da?
          Unter anderen damit man nicht Milliarden von Klassen in einem Ordner 
hat und dabei die &Uuml;bersicht verliert. 
        
        
          Ist mir egal. Pakete sind mir zu umst&auml;ndlich.
          Das ist aber dumm, wenn man Klassen gleichen Namens aus verschiedenen
Bibliotheken 
benutzen will. Die kann man nur unterscheiden, wenn sie in verschiedenen
Paketen sind.
        
        
          OK, ich sehs ein. Wie nenne ich mein Paket?
          Am besten die eigene Webdomain r&uuml;ckw&auml;rsts nehmen also f&uuml;r uns an der
FH: de.fhwiesbaden.informatik.panitz.meineApplikation
        
        
          Da fehlt doch der Bindestrich.
          Der ist kein g&uuml;ltiges Zeichen innerhalb eines Bezeichners in Java (es
ist ja der Minusoperator). Bindestriche in Webadressen sind eine recht
deutsche Krankheit.
        
        
          Mu&szlig; ich imports machen um Klassen aus anderen Paketen zu benutzen?
          Nein. Das macht die Sache nur bewuemer, weil sonst der Klassenname
immer und &uuml;berall komplett mit seinem Paket angegeben werden mu&szlig;, auch beim
Konstruktoraufruf oder z.B. instanceof.
        
        
          Machen Import-Anweisungen das Programm langsamer oder gr&ouml;&szlig;er?
          Nein! Sie haben insbesondere nichts mit includes in C gemein. Sie
entsprechen eher dem using namespace aus C++.
        
        
          Da gibt es doch auch noch public, private und protected. 
          Jaja, die Sichtbarkeiten. Hinzu kommt, wenn man keine Sichtbarkeit
hinschreibt. public hei&szlig;t von &uuml;berall aufrufbar, protected hei&szlig;t in Unterklassen und gleichem Paket aufrufbar, package das ist wenn man nichts hinschreibt, hei&szlig;t nur im gleichen Paket
sichtbar, und private nur in der Klasse.
        
        
          Und dann war da noch das final.
          Das hat zwei Bedeutungen: bei Variablen und Feldern, da&szlig; sie nur
einmal einen Wert zugewiesen bekommen, bei Klassen, da&szlig; keine Unterklassen von
der Klasse definiert werden
        
        
          Ich will GUIs programmieren.
          Wunderbar, da gibt es zwei Bibliotheken: Swing und AWT.
        
        
          Na toll, warum zwei?
          Historisch.
        
        
          Und welche sol ich jetzt benutzen?
          Swing!
        
        
          Also kann ich alles &uuml;ber AWT vergessen, insbesondere das 
Paket java.awt? 
          Nein. Swing benutzt gro&szlig;e Teile aus AWT. Insbesondere hat jede
Swingkomponente eine Oberklasse aus AWT. Aber auch die
Ereignisbehandlungsklassen werden 
vollst&auml;ndig aus AWT benutzt.
        
        
          Und woran erkenne ich jetzt, wann ich Komponente aus AWT bnutzen mu&szlig;,
obwohl ich in Swing programmiere?
          Alle graphischen AWT-Komponenten haben ein Swing Pendant, das mit dem
dem Buchstaben J beginnt, z.B. javax.swing.JButton im
Gegensatz zu java.awt.Button.
        
        
          Sonst noch paar Tipps, zum benutzen von Swing?
          Keine eigenen Threads schreiben! Nicht die 
Methode paint sondern paintComponent &uuml;berschreiben.
        
        
          Toll, wenn ich keine Threads schreiben soll, wie mache ich dann
z.B. zeitgesteuerte Ereignisse in Swing?
          Da gibt es die Klasse javax.swing.Timer f&uuml;r.
        
        
          Ich will XML verarbeiten.
          Kein Problem, alles vorhanden, soll es das DOM-Api oder SAX sein?
        
        
          Wei&szlig; nicht? Was ist der Unterschied?
          In DOM wird eine Baumstruktur f&uuml;r ein XML-Dokument im Speicher
aufgebaut. Mit der kann man alles machen, was man mit einem Baum machen kann.
        
        
          Super. Wozu ist dann SAX?
          Oft braucht man nie die ganze Baumstruktur, sondern mu&szlig; das Dokument
nur einmal von vorne nach hinten durcharbeiten. Dabei hilft SAX
        
        
          Ist dann effizienter sch&auml;tze ich?
          Ganz genau, insbesondere wird viel weniger Speicher 
ben&ouml;tigt. 
        
        
          Na ich wei&szlig; nicht, ob ich jetzt gen&uuml;gend wei&szlig; f&uuml;r die Klausur?
          Das wei&szlig; ich auch nicht, &uuml;ber alles haben wir hier nicht
gesprochen. Ich denke aber  es reicht an Wissen aus.
        
      
    <h1>6. W&ouml;rterliste</h1>
        In dieser Mitschrift habe  ich mich bem&uuml;ht, soweit
existent oder naheliegend, deutsche Ausdr&uuml;cke f&uuml;r die vielen in der
Informatik auftretenden englischen Fachbegriffe zu benutzen. Dieses ist
nicht aus einem nationalen Chauvinismus heraus, sondern 
f&uuml;r eine fl&uuml;ssige Lesbarkeit des Textes geschehen. Ein mit sehr vielen
englischen W&ouml;rtern durchsetzter Text ist schwerer zu lesen, insbesondere
auch f&uuml;r Menschen, deren Muttersprache nicht deutsch ist.

Es folgen hier 
Tabellen der verwendeten deutschen Ausdr&uuml;cke mit ihrer englischen
Entsprechung. 
        
          
            Klasse
            class
          
          
            Schnittstelle
            interface
          
          
            Eigenschaft
            feature
          
          
            Feld
            field
          
          
            Methode
            method
          
          
            Blubbersortierung
            bubble sort
          
          
            &Uuml;bersetzer
            compiler
          
          
            Interpreter
            interpreter
          
          
            Beh&auml;lter
            container
          
          
            Zeichenkette
            string
          
          
            Sammlung
            collection
          
          
            Ausnahme
            exception
          
          
            Erreichbarkeit
            visibility
          
          
            Sichtbarkeit
            visibility
          
          
            Modellierung
            design
          
          
            Paket
            package
          
          
            Befehl
            statement
          
          
            Ausdruck
            expression
          
          
            Zuweisung
            assignment
          
          
            Typzusicherung
            type cast
          
          
            Kommandozeile
            command line
          
          
            R&uuml;ckgabetyp
            return type
          
          
            Typ
            type
          
          
            Ordner
            folder
          
          
            Datei
            file
          
          
            Deklaration
            declaration
          
          
            Verzeichnis
            directory
          
          
            Reihung
            array
          
          
            Unterklasse
            subclass
          
          
            Oberklasse
            superclass
          
          
            gesch&uuml;tzt
            protected
          
          
            &ouml;ffentlich
            public
          
          
            privat
            private
          
          
            Auswertung
            evaluation
          
          
            Attribut
            modifier
          
          
            Schleife
            loop
          
          
            Bedingung
            condition
          
          
            Hauruckverfahren
            bruteforce
          
          
            Rumpf
            body
          
          
            Fabrikmethode
            factory method
          
          
            vollqualifizierter Name
            fully qualified name
          
          
            Keller
            stack
          
          
            Aufrufkeller
            stack trace
          
          
            Abbildung
            map
          
          
            Strom
            stream
          
          
            Menge
            set
          
          
            Zeichen
            character
          
          
            Steuerfaden
            thread
          
          
            Verklemmung
            dead lock
          
          
            Implementierung
            implementation
          
          
            Puffer
            buffer
          
          
            nebenl&auml;ufig
            concurrent
          
          
            strikt
            strict
          
          
            faul
            lazy
          
        
      
    
    
    
    
  </body>
</html>
